{"remainingRequest":"D:\\cdRule\\node_modules\\thread-loader\\dist\\cjs.js!D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js!D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js!D:\\cdRule\\src\\components\\Tree\\jquery.ztree.core.js","dependencies":[{"path":"D:\\cdRule\\src\\components\\Tree\\jquery.ztree.core.js","mtime":1673402177014},{"path":"D:\\cdRule\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\thread-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.regexp.replace\";\nimport \"core-js/modules/es6.regexp.split\";\nimport \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.regexp.replace\";\nimport \"core-js/modules/es6.regexp.split\";\nimport \"core-js/modules/es6.regexp.to-string\";\n/*\n * JQuery zTree core v3.5.40\n * http://treejs.cn/\n *\n * Copyright (c) 2010 Hunter.z\n *\n * Licensed same as jquery - MIT License\n * http://www.opensource.org/licenses/mit-license.php\n *\n * email: hunter.z@263.net\n * Date: 2019-01-18\n */\n\n(function (_$) {\n  var settings = {},\n      roots = {},\n      caches = {},\n      _consts = {\n    className: {\n      BUTTON: \"button\",\n      LEVEL: \"level\",\n      ICO_LOADING: \"ico_loading\",\n      SWITCH: \"switch\",\n      NAME: 'node_name'\n    },\n    event: {\n      NODECREATED: \"ztree_nodeCreated\",\n      CLICK: \"ztree_click\",\n      EXPAND: \"ztree_expand\",\n      COLLAPSE: \"ztree_collapse\",\n      ASYNC_SUCCESS: \"ztree_async_success\",\n      ASYNC_ERROR: \"ztree_async_error\",\n      REMOVE: \"ztree_remove\",\n      SELECTED: \"ztree_selected\",\n      UNSELECTED: \"ztree_unselected\"\n    },\n    id: {\n      DIV: '_div',\n      A: \"_a\",\n      ICON: \"_ico\",\n      SPAN: \"_span\",\n      SWITCH: \"_switch\",\n      UL: \"_ul\"\n    },\n    line: {\n      ROOT: \"root\",\n      ROOTS: \"roots\",\n      CENTER: \"center\",\n      BOTTOM: \"bottom\",\n      NOLINE: \"noline\",\n      LINE: \"line\"\n    },\n    folder: {\n      OPEN: \"open\",\n      CLOSE: \"close\",\n      DOCU: \"docu\"\n    }\n  },\n      _setting = {\n    treeId: \"\",\n    treeObj: null,\n    view: {\n      addDiyDom: null,\n      dblClickExpand: true,\n      expandSpeed: \"\",\n      //fast\n      nameIsHTML: false,\n      showLine: true,\n      txtSelectedEnable: false,\n      nameFunction: null,\n      iconUrlFunction: null,\n      iconCssFunction: null,\n      titleFunction: null,\n      hideFunction: null\n    },\n    data: {\n      key: {\n        name: \"name\",\n        parent: \"parent\",\n        children: \"children\"\n      },\n      keep: {\n        parent: false,\n        leaf: false\n      }\n    },\n    async: {\n      enable: false,\n      contentType: \"application/x-www-form-urlencoded\",\n      type: \"post\",\n      dataType: \"text\",\n      headers: {},\n      xhrFields: {},\n      url: \"\",\n      autoParam: [],\n      otherParam: [],\n      dataFilter: null\n    },\n    callback: {\n      beforeAsync: null,\n      beforeClick: null,\n      beforeDblClick: null,\n      beforeRightClick: null,\n      beforeMouseDown: null,\n      beforeMouseUp: null,\n      beforeExpand: null,\n      beforeCollapse: null,\n      beforeRemove: null,\n      onAsyncError: null,\n      onAsyncSuccess: null,\n      onNodeCreated: null,\n      onClick: null,\n      onDblClick: null,\n      onRightClick: null,\n      onMouseDown: null,\n      onMouseUp: null,\n      onExpand: null,\n      onCollapse: null,\n      onRemove: null,\n      onMouseOver: null,\n      onMouseOut: null\n    }\n  },\n      _initRoot = function _initRoot(setting) {\n    var r = data.getRoot(setting);\n\n    if (!r) {\n      r = {};\n      data.setRoot(setting, r);\n    }\n\n    r[setting.data.key.children] = [];\n    r.expandTriggerFlag = false;\n    r.curSelectedList = [];\n    r.noSelection = true;\n    r.createdNodes = [];\n    r.zId = r.zId || 0;\n    r._ver = new Date().getTime();\n  },\n      _initCache = function _initCache(setting) {\n    var c = data.getCache(setting);\n    !c && data.setCache(setting, c = {});\n    c.nodes = [];\n  },\n      _bindEvent = function _bindEvent(setting) {\n    var o = setting.treeObj,\n        c = consts.event;\n    o.bind(c.NODECREATED, function (event, node) {\n      tools.apply(setting.callback.onNodeCreated, [node, event]);\n    });\n    o.bind(c.CLICK, function (event, srcEvent, node) {\n      tools.apply(setting.callback.onClick, [node, srcEvent]);\n    });\n    o.bind(c.EXPAND, function (event, node) {\n      tools.apply(setting.callback.onExpand, [node, event]);\n    });\n    o.bind(c.COLLAPSE, function (event, node) {\n      tools.apply(setting.callback.onCollapse, [node, event]);\n    });\n    o.bind(c.ASYNC_SUCCESS, function (event, node, msg) {\n      tools.apply(setting.callback.onAsyncSuccess, [node, event, msg]);\n    });\n    o.bind(c.ASYNC_ERROR, function (event, node, XMLHttpRequest, textStatus, errorThrown) {\n      tools.apply(setting.callback.onAsyncError, [node, event, XMLHttpRequest, textStatus, errorThrown]);\n    });\n    o.bind(c.REMOVE, function (event, node) {\n      tools.apply(setting.callback.onRemove, [node, event]);\n    });\n    o.bind(c.SELECTED, function (event, node) {\n      tools.apply(setting.callback.onSelected, [node, event]);\n    });\n    o.bind(c.UNSELECTED, function (event, node) {\n      tools.apply(setting.callback.onUnSelected, [node, event]);\n    });\n  },\n      _unbindEvent = function _unbindEvent(setting) {\n    var o = setting.treeObj,\n        c = consts.event;\n    o.unbind(c.NODECREATED).unbind(c.CLICK).unbind(c.EXPAND).unbind(c.COLLAPSE).unbind(c.ASYNC_SUCCESS).unbind(c.ASYNC_ERROR).unbind(c.REMOVE).unbind(c.SELECTED).unbind(c.UNSELECTED);\n  },\n      _eventProxy = function _eventProxy(event) {\n    var target = event.target,\n        setting = data.getSetting(event.data.treeId),\n        tId = \"\",\n        node = null,\n        nodeEventType = \"\",\n        treeEventType = \"\",\n        nodeEventCallback = null,\n        treeEventCallback = null,\n        tmp = null;\n\n    if (tools.eqs(event.type, \"mousedown\")) {\n      treeEventType = \"mousedown\";\n    } else if (tools.eqs(event.type, \"mouseup\")) {\n      treeEventType = \"mouseup\";\n    } else if (tools.eqs(event.type, \"mouseover\")) {\n      treeEventType = \"mouseover\";\n    } else if (tools.eqs(event.type, \"mouseout\")) {\n      treeEventType = \"mouseout\";\n    } else if (tools.eqs(event.type, \"contextmenu\")) {\n      treeEventType = \"contextmenu\";\n    } else if (tools.eqs(event.type, \"click\")) {\n      if (tools.eqs(target.tagName, \"span\") && target.getAttribute(\"treeNode\" + consts.id.SWITCH) !== null) {\n        tId = tools.getNodeMainDom(target).id;\n        nodeEventType = \"switchNode\";\n      } else {\n        tmp = tools.getMDom(setting, target, [{\n          tagName: \"div\",\n          attrName: \"treeNode\" + consts.id.DIV\n        }]);\n\n        if (tmp) {\n          tId = tools.getNodeMainDom(tmp).id;\n          nodeEventType = \"clickNode\";\n        }\n      }\n    } else if (tools.eqs(event.type, \"dblclick\")) {\n      treeEventType = \"dblclick\";\n      tmp = tools.getMDom(setting, target, [{\n        tagName: \"div\",\n        attrName: \"treeNode\" + consts.id.DIV\n      }]);\n\n      if (tmp) {\n        tId = tools.getNodeMainDom(tmp).id;\n        nodeEventType = \"switchNode\";\n      }\n    }\n\n    if (treeEventType.length > 0 && tId.length == 0) {\n      tmp = tools.getMDom(setting, target, [{\n        tagName: \"div\",\n        attrName: \"treeNode\" + consts.id.DIV\n      }]);\n\n      if (tmp) {\n        tId = tools.getNodeMainDom(tmp).id;\n      }\n    } // event to node\n\n\n    if (tId.length > 0) {\n      node = data.getNodeCache(setting, tId);\n\n      switch (nodeEventType) {\n        case \"switchNode\":\n          if (node == null || !node[setting.treeId].isParent) {\n            nodeEventType = \"\";\n          } else if (tools.eqs(event.type, \"click\") || tools.eqs(event.type, \"dblclick\") && tools.apply(setting.view.dblClickExpand, [node], setting.view.dblClickExpand)) {\n            nodeEventCallback = handler.onSwitchNode;\n          } else {\n            nodeEventType = \"\";\n          }\n\n          break;\n\n        case \"clickNode\":\n          nodeEventCallback = handler.onClickNode;\n          break;\n      }\n    } // event to zTree\n\n\n    switch (treeEventType) {\n      case \"mousedown\":\n        treeEventCallback = handler.onZTreeMousedown;\n        break;\n\n      case \"mouseup\":\n        treeEventCallback = handler.onZTreeMouseup;\n        break;\n\n      case \"mouseover\":\n        treeEventCallback = handler.onZTreeMouseover;\n        break;\n\n      case \"mouseout\":\n        treeEventCallback = handler.onZTreeMouseout;\n        break;\n\n      case \"dblclick\":\n        treeEventCallback = handler.onZTreeDblclick;\n        break;\n\n      case \"contextmenu\":\n        treeEventCallback = handler.onZTreeContextmenu;\n        break;\n    }\n\n    var proxyResult = {\n      stop: false,\n      node: node,\n      nodeEventType: nodeEventType,\n      nodeEventCallback: nodeEventCallback,\n      treeEventType: treeEventType,\n      treeEventCallback: treeEventCallback\n    };\n    return proxyResult;\n  },\n      //default init node of core\n  _initNode = function _initNode(setting, level, n, parentNode, isFirstNode, isLastNode, openFlag) {\n    if (!n) return;\n    var r = data.getRoot(setting),\n        children = n[setting.data.key.children];\n    var Z = n[setting.treeId] = n[setting.treeId] || {};\n    Z.level = level;\n    Z.tId = setting.treeId + \"_\" + ++r.zId;\n    Z.open = !!Z.open;\n\n    if (tools.isArray(children)) {\n      Z.isParent = true;\n      Z.zAsync = true;\n    } else {\n      Z.open = Z.isParent && !setting.async.enable ? Z.open : false;\n      Z.zAsync = !Z.isParent;\n    }\n\n    Z.isFirstNode = isFirstNode;\n    Z.isLastNode = isLastNode;\n    Z.isAjaxing = false;\n  },\n      _init = {\n    bind: [_bindEvent],\n    unbind: [_unbindEvent],\n    caches: [_initCache],\n    nodes: [_initNode],\n    proxys: [_eventProxy],\n    roots: [_initRoot],\n    beforeA: [],\n    afterA: [],\n    innerBeforeA: [],\n    innerAfterA: [],\n    innerAfterIcon: [],\n    zTreeTools: []\n  },\n      //method of operate data\n  data = {\n    addNodeCache: function addNodeCache(setting, node) {\n      data.getCache(setting).nodes[data.getNodeCacheId(node[setting.treeId].tId)] = node;\n    },\n    getNodeCacheId: function getNodeCacheId(tId) {\n      return tId.substring(tId.lastIndexOf(\"_\") + 1);\n    },\n    addAfterA: function addAfterA(afterA) {\n      _init.afterA.push(afterA);\n    },\n    addBeforeA: function addBeforeA(beforeA) {\n      _init.beforeA.push(beforeA);\n    },\n    addInnerAfterA: function addInnerAfterA(innerAfterA) {\n      _init.innerAfterA.push(innerAfterA);\n    },\n    addInnerBeforeA: function addInnerBeforeA(innerBeforeA) {\n      _init.innerBeforeA.push(innerBeforeA);\n    },\n    addInnerAfterIcon: function addInnerAfterIcon(innerAfterIcon) {\n      _init.innerAfterIcon.push(innerAfterIcon);\n    },\n    addInitBind: function addInitBind(bindEvent) {\n      _init.bind.push(bindEvent);\n    },\n    addInitUnBind: function addInitUnBind(unbindEvent) {\n      _init.unbind.push(unbindEvent);\n    },\n    addInitCache: function addInitCache(initCache) {\n      _init.caches.push(initCache);\n    },\n    addInitNode: function addInitNode(initNode) {\n      _init.nodes.push(initNode);\n    },\n    addInitProxy: function addInitProxy(initProxy, isFirst) {\n      if (!!isFirst) {\n        _init.proxys.splice(0, 0, initProxy);\n      } else {\n        _init.proxys.push(initProxy);\n      }\n    },\n    addInitRoot: function addInitRoot(initRoot) {\n      _init.roots.push(initRoot);\n    },\n    addNodesData: function addNodesData(setting, parentNode, index, nodes) {\n      var children = parentNode[setting.data.key.children] || [],\n          Z;\n\n      if (children.length == nodes.length) {\n        parentNode[setting.treeId].isParent = true;\n        return;\n      }\n\n      if (index === 0) {\n        var first = children[nodes.length - 1];\n        Z = first[setting.treeId];\n        Z ? Z.isFirstNode = false : Z = {\n          isFirstNode: false\n        };\n        view.setNodeLineIcos(setting, first, Z);\n      } else if (index < 0) {\n        var last = children[children.length - nodes.length - 1];\n\n        if (last) {\n          Z = last[setting.treeId] || {};\n          Z.isLastNode = false;\n          view.setNodeLineIcos(setting, last, Z);\n        }\n      }\n\n      parentNode[setting.treeId].isParent = true; //            var children = parentNode[setting.data.key.children], params;\n      //            if (!children) {\n      //                children = parentNode[setting.data.key.children] = [];\n      //                index = -1;\n      //            } else if (index >= children.length) {\n      //                index = -1;\n      //            }\n      //            if (children.length > 0 && index === 0) {\n      //                children[0][setting.treeId].isFirstNode = false;\n      //                view.setNodeLineIcos(setting, children[0]);\n      //            } else if (children.length > 0 && index < 0) {\n      //                children[children.length - 1][setting.treeId].isLastNode = false;\n      //                view.setNodeLineIcos(setting, children[children.length - 1]);\n      //            }\n      //            parentNode[setting.treeId].isParent = true;\n      //            if (index < 0) {\n      //                parentNode[setting.data.key.children] = children.concat(nodes);\n      //            } else {\n      //                params = [index, 0].concat(nodes);\n      //                children.splice.apply(children, params);\n      //            }\n    },\n    addSelectedNode: function addSelectedNode(setting, node) {\n      if (!data.isSelectedNode(setting, node)) {\n        var root = data.getRoot(setting);\n        root.curSelectedList.push(node);\n      }\n    },\n    addCreatedNode: function addCreatedNode(setting, node) {\n      if (!!setting.callback.onNodeCreated || !!setting.view.addDiyDom) {\n        var root = data.getRoot(setting);\n        root.createdNodes.push(node);\n      }\n    },\n    addZTreeTools: function addZTreeTools(zTreeTools) {\n      _init.zTreeTools.push(zTreeTools);\n    },\n    exSetting: function exSetting(s) {\n      _$.extend(true, _setting, s);\n    },\n    getAfterA: function getAfterA(setting, node, array) {\n      for (var i = 0, j = _init.afterA.length; i < j; i++) {\n        _init.afterA[i].apply(this, arguments);\n      }\n    },\n    getBeforeA: function getBeforeA(setting, node, array) {\n      for (var i = 0, j = _init.beforeA.length; i < j; i++) {\n        _init.beforeA[i].apply(this, arguments);\n      }\n    },\n    getInnerAfterIcon: function getInnerAfterIcon(setting, node, array) {\n      for (var i = 0, j = _init.innerAfterIcon.length; i < j; i++) {\n        _init.innerAfterIcon[i].apply(this, arguments);\n      }\n    },\n    getInnerAfterA: function getInnerAfterA(setting, node, array) {\n      for (var i = 0, j = _init.innerAfterA.length; i < j; i++) {\n        _init.innerAfterA[i].apply(this, arguments);\n      }\n    },\n    getInnerBeforeA: function getInnerBeforeA(setting, node, array) {\n      for (var i = 0, j = _init.innerBeforeA.length; i < j; i++) {\n        _init.innerBeforeA[i].apply(this, arguments);\n      }\n    },\n    getCache: function getCache(setting) {\n      return caches[setting.treeId];\n    },\n    getNodeByParam: function getNodeByParam(setting, nodes, key, value) {\n      if (!nodes || !key) return null;\n\n      for (var i = 0, l = nodes.length; i < l; i++) {\n        var node = nodes[i];\n\n        if (node[key] == value) {\n          return nodes[i];\n        }\n\n        var children = node[setting.data.key.children];\n        var tmp = data.getNodeByParam(setting, children, key, value);\n        if (tmp) return tmp;\n      }\n\n      return null;\n    },\n    getNodeCache: function getNodeCache(setting, tId) {\n      if (!tId) return null;\n      return caches[setting.treeId].nodes[data.getNodeCacheId(tId)] || 0;\n    },\n    getNodes: function getNodes(setting) {\n      return data.getRoot(setting)[setting.data.key.children];\n    },\n    getNodesByParam: function getNodesByParam(setting, nodes, key, value) {\n      if (!nodes || !key) return [];\n      var result = [];\n\n      for (var i = 0, l = nodes.length; i < l; i++) {\n        var node = nodes[i];\n\n        if (node[key] == value) {\n          result.push(node);\n        }\n\n        var children = node[setting.data.key.children];\n        result = result.concat(data.getNodesByParam(setting, children, key, value));\n      }\n\n      return result;\n    },\n    getNodesByParamFuzzy: function getNodesByParamFuzzy(setting, nodes, key, value) {\n      if (!nodes || !key) return [];\n      var result = [];\n      value = value.toLowerCase();\n\n      for (var i = 0, l = nodes.length; i < l; i++) {\n        var node = nodes[i];\n\n        if (typeof node[key] == \"string\" && nodes[i][key].toLowerCase().indexOf(value) > -1) {\n          result.push(node);\n        }\n\n        var children = node[setting.data.key.children];\n        result = result.concat(data.getNodesByParamFuzzy(setting, children, key, value));\n      }\n\n      return result;\n    },\n    getNodesByFilter: function getNodesByFilter(setting, nodes, filter, isSingle, invokeParam) {\n      if (!nodes) return isSingle ? null : [];\n      var result = isSingle ? null : [];\n\n      for (var i = 0, l = nodes.length; i < l; i++) {\n        var node = nodes[i];\n\n        if (tools.apply(filter, [node, invokeParam], false)) {\n          if (isSingle) {\n            return node;\n          }\n\n          result.push(node);\n        }\n\n        var children = node[setting.data.key.children];\n        var tmpResult = data.getNodesByFilter(setting, children, filter, isSingle, invokeParam);\n\n        if (isSingle && !!tmpResult) {\n          return tmpResult;\n        }\n\n        result = isSingle ? tmpResult : result.concat(tmpResult);\n      }\n\n      return result;\n    },\n    getRoot: function getRoot(setting) {\n      return setting ? roots[setting.treeId] : null;\n    },\n    getRoots: function getRoots() {\n      return roots;\n    },\n    getSetting: function getSetting(treeId) {\n      return settings[treeId];\n    },\n    getSettings: function getSettings() {\n      return settings;\n    },\n    getZTreeTools: function getZTreeTools(treeId) {\n      var r = this.getRoot(this.getSetting(treeId));\n      return r ? r.treeTools : null;\n    },\n    initCache: function initCache(setting) {\n      for (var i = 0, j = _init.caches.length; i < j; i++) {\n        _init.caches[i].apply(this, arguments);\n      }\n    },\n    initNode: function initNode(setting, level, node, parentNode, preNode, nextNode) {\n      for (var i = 0, j = _init.nodes.length; i < j; i++) {\n        _init.nodes[i].apply(this, arguments);\n      }\n    },\n    initRoot: function initRoot(setting) {\n      for (var i = 0, j = _init.roots.length; i < j; i++) {\n        _init.roots[i].apply(this, arguments);\n      }\n    },\n    isSelectedNode: function isSelectedNode(setting, node) {\n      var root = data.getRoot(setting);\n\n      for (var i = 0, j = root.curSelectedList.length; i < j; i++) {\n        if (node === root.curSelectedList[i]) return true;\n      }\n\n      return false;\n    },\n    nodeName: function nodeName(setting, node) {\n      return setting.view.nameFunction ? setting.view.nameFunction(node) : node[setting.data.key.name];\n    },\n    removeNodeCache: function removeNodeCache(setting, node) {\n      var children = node[setting.data.key.children];\n\n      if (children) {\n        for (var i = 0, l = children.length; i < l; i++) {\n          data.removeNodeCache(setting, children[i]);\n        }\n      }\n\n      data.getCache(setting).nodes[data.getNodeCacheId(node[setting.treeId].tId)] = null;\n    },\n    removeSelectedNode: function removeSelectedNode(setting, node) {\n      var root = data.getRoot(setting);\n\n      for (var i = 0, j = root.curSelectedList.length; i < j; i++) {\n        if (node === root.curSelectedList[i] || !data.getNodeCache(setting, root.curSelectedList[i][setting.treeId].tId)) {\n          root.curSelectedList.splice(i, 1);\n          setting.treeObj.trigger(consts.event.UNSELECTED, [node]);\n          i--;\n          j--;\n        }\n      }\n    },\n    setCache: function setCache(setting, cache) {\n      caches[setting.treeId] = cache;\n    },\n    setRoot: function setRoot(setting, root) {\n      roots[setting.treeId] = root;\n    },\n    setZTreeTools: function setZTreeTools(setting, zTreeTools) {\n      for (var i = 0, j = _init.zTreeTools.length; i < j; i++) {\n        _init.zTreeTools[i].apply(this, arguments);\n      }\n    },\n    transformToArrayFormat: function transformToArrayFormat(setting, nodes) {\n      if (!nodes) return [];\n      var r = [];\n\n      if (tools.isArray(nodes)) {\n        for (var i = 0, l = nodes.length; i < l; i++) {\n          _do(nodes[i]);\n        }\n      } else {\n        _do(nodes);\n      }\n\n      return r;\n\n      function _do(_node) {\n        r.push(_node);\n        var children = _node[setting.data.key.children];\n\n        if (children) {\n          r = r.concat(data.transformToArrayFormat(setting, children));\n        }\n      }\n    }\n  },\n      //method of event proxy\n  event = {\n    bindEvent: function bindEvent(setting) {\n      for (var i = 0, j = _init.bind.length; i < j; i++) {\n        _init.bind[i].apply(this, arguments);\n      }\n    },\n    unbindEvent: function unbindEvent(setting) {\n      for (var i = 0, j = _init.unbind.length; i < j; i++) {\n        _init.unbind[i].apply(this, arguments);\n      }\n    },\n    bindTree: function bindTree(setting) {\n      var eventParam = {\n        treeId: setting.treeId\n      },\n          o = setting.treeObj;\n\n      if (!setting.view.txtSelectedEnable) {\n        // for can't select text\n        o.bind('selectstart', handler.onSelectStart).css({\n          \"-moz-user-select\": \"-moz-none\"\n        });\n      }\n\n      o.bind('click', eventParam, event.proxy);\n      o.bind('dblclick', eventParam, event.proxy);\n      o.bind('mouseover', eventParam, event.proxy);\n      o.bind('mouseout', eventParam, event.proxy);\n      o.bind('mousedown', eventParam, event.proxy);\n      o.bind('mouseup', eventParam, event.proxy);\n      o.bind('contextmenu', eventParam, event.proxy);\n    },\n    unbindTree: function unbindTree(setting) {\n      var o = setting.treeObj;\n      o.unbind('selectstart', handler.onSelectStart).unbind('click', event.proxy).unbind('dblclick', event.proxy).unbind('mouseover', event.proxy).unbind('mouseout', event.proxy).unbind('mousedown', event.proxy).unbind('mouseup', event.proxy).unbind('contextmenu', event.proxy);\n    },\n    doProxy: function doProxy(e) {\n      var results = [];\n\n      for (var i = 0, j = _init.proxys.length; i < j; i++) {\n        var proxyResult = _init.proxys[i].apply(this, arguments);\n\n        results.push(proxyResult);\n\n        if (proxyResult.stop) {\n          break;\n        }\n      }\n\n      return results;\n    },\n    proxy: function proxy(e) {\n      var results = event.doProxy(e),\n          r = true,\n          x = false;\n\n      for (var i = 0, l = results.length; i < l; i++) {\n        var proxyResult = results[i];\n\n        if (proxyResult.nodeEventCallback) {\n          x = true;\n          r = proxyResult.nodeEventCallback.apply(proxyResult, [e, proxyResult.node]) && r;\n        }\n\n        if (proxyResult.treeEventCallback) {\n          x = true;\n          r = proxyResult.treeEventCallback.apply(proxyResult, [e, proxyResult.node]) && r;\n        }\n      }\n\n      return r;\n    }\n  },\n      //method of event handler\n  handler = {\n    onSwitchNode: function onSwitchNode(event, node) {\n      var setting = data.getSetting(event.data.treeId);\n\n      if (node[setting.treeId].open) {\n        if (tools.apply(setting.callback.beforeCollapse, [node, event], true) == false) return true;\n        data.getRoot(setting).expandTriggerFlag = true;\n        view.switchNode(setting, node, true);\n      } else {\n        if (tools.apply(setting.callback.beforeExpand, [node, event], true) == false) return true;\n        data.getRoot(setting).expandTriggerFlag = true;\n        view.switchNode(setting, node, false);\n      }\n\n      return true;\n    },\n    onClickNode: function onClickNode(event, node) {\n      var setting = data.getSetting(event.data.treeId);\n      if (tools.apply(setting.callback.beforeClick, [node, event], true) == false) return true;\n      view.selectNode(setting, node, true);\n      setting.treeObj.trigger(consts.event.CLICK, [event, node]);\n      return true;\n    },\n    onZTreeMousedown: function onZTreeMousedown(event, node) {\n      var setting = data.getSetting(event.data.treeId);\n\n      if (tools.apply(setting.callback.beforeMouseDown, [node, event], true)) {\n        tools.apply(setting.callback.onMouseDown, [node, event]);\n      }\n\n      return true;\n    },\n    onZTreeMouseup: function onZTreeMouseup(event, node) {\n      var setting = data.getSetting(event.data.treeId);\n\n      if (tools.apply(setting.callback.beforeMouseUp, [node, event], true)) {\n        tools.apply(setting.callback.onMouseUp, [node, event]);\n      }\n\n      return true;\n    },\n    onZTreeMouseover: function onZTreeMouseover(event, node) {\n      var setting = data.getSetting(event.data.treeId);\n      tools.apply(setting.callback.onMouseOver, [node, event]);\n      return true;\n    },\n    onZTreeMouseout: function onZTreeMouseout(event, node) {\n      var setting = data.getSetting(event.data.treeId);\n      tools.apply(setting.callback.onMouseOut, [node, event]);\n      return true;\n    },\n    onZTreeDblclick: function onZTreeDblclick(event, node) {\n      var setting = data.getSetting(event.data.treeId);\n\n      if (tools.apply(setting.callback.beforeDblClick, [node, event], true)) {\n        tools.apply(setting.callback.onDblClick, [node, event]);\n      }\n\n      return true;\n    },\n    onZTreeContextmenu: function onZTreeContextmenu(event, node) {\n      var setting = data.getSetting(event.data.treeId);\n\n      if (tools.apply(setting.callback.beforeRightClick, [node, event], true)) {\n        tools.apply(setting.callback.onRightClick, [node, event]);\n      }\n\n      return typeof setting.callback.onRightClick != \"function\";\n    },\n    onSelectStart: function onSelectStart(e) {\n      var n = e.originalEvent.srcElement.nodeName.toLowerCase();\n      return n === \"input\" || n === \"textarea\";\n    }\n  },\n      //method of tools for zTree\n  tools = {\n    apply: function apply(fun, param, defaultValue) {\n      if (typeof fun == \"function\") {\n        return fun.apply(zt, param ? param : []);\n      }\n\n      return defaultValue;\n    },\n    canAsync: function canAsync(setting, node) {\n      var children = node[setting.data.key.children];\n      var isParent = node[setting.treeId].isParent;\n      return setting.async.enable && node && isParent && !(node[setting.treeId].zAsync || children && children.length > 0);\n    },\n    clone: function clone(obj) {\n      if (obj === null) return null;\n      var o = tools.isArray(obj) ? [] : {};\n\n      for (var i in obj) {\n        o[i] = obj[i] instanceof Date ? new Date(obj[i].getTime()) : typeof obj[i] === \"object\" ? tools.clone(obj[i]) : obj[i];\n      }\n\n      return o;\n    },\n    eqs: function eqs(str1, str2) {\n      return str1.toLowerCase() === str2.toLowerCase();\n    },\n    isArray: function isArray(arr) {\n      return Object.prototype.toString.apply(arr) === \"[object Array]\";\n    },\n    $: function $(node, exp, setting) {\n      if (!!exp && typeof exp != \"string\") {\n        setting = exp;\n        exp = \"\";\n      }\n\n      if (typeof node == \"string\") {\n        return _$(node, setting ? setting.treeObj.get(0).ownerDocument : null);\n      } else {\n        if (!node[setting.treeId]) {\n          return _$();\n        }\n\n        return _$(\"#\" + node[setting.treeId].tId + exp, setting ? setting.treeObj : null);\n      }\n    },\n    getMDom: function getMDom(setting, curDom, targetExpr) {\n      if (!curDom) return null;\n\n      while (curDom && curDom.id !== setting.treeId) {\n        for (var i = 0, l = targetExpr.length; curDom.tagName && i < l; i++) {\n          if (tools.eqs(curDom.tagName, targetExpr[i].tagName) && curDom.getAttribute(targetExpr[i].attrName) !== null) {\n            return curDom;\n          }\n        }\n\n        curDom = curDom.parentNode;\n      }\n\n      return null;\n    },\n    getNodeMainDom: function getNodeMainDom(target) {\n      return _$(target).parent(\"li\").get(0) || _$(target).parentsUntil(\"li\").parent().get(0);\n    }\n  },\n      //method of operate ztree dom\n  view = {\n    addNodes: function addNodes(setting, parentNode, index, newNodes, isSilent) {\n      if (setting.data.keep.leaf && parentNode && !parentNode[setting.treeId].isParent) {\n        return;\n      }\n\n      if (!tools.isArray(newNodes)) {\n        newNodes = [newNodes];\n      }\n\n      if (parentNode) {\n        var target_switchObj = $$(parentNode, consts.id.SWITCH, setting),\n            target_icoObj = $$(parentNode, consts.id.ICON, setting),\n            target_ulObj = $$(parentNode, consts.id.UL, setting);\n        var Z = parentNode[setting.treeId];\n\n        if (!Z.open) {\n          view.replaceSwitchClass(Z.level, target_switchObj, consts.folder.CLOSE);\n          view.replaceIcoClass(target_icoObj, setting, parentNode, Z);\n          Z.open = false;\n          target_ulObj.css({\n            \"display\": \"none\"\n          });\n        }\n\n        data.addNodesData(setting, parentNode, index, newNodes);\n        view.createNodes(setting, Z.level + 1, newNodes, parentNode, index);\n\n        if (!isSilent) {\n          view.expandCollapseParentNode(setting, parentNode, true);\n        }\n      } else {\n        data.addNodesData(setting, data.getRoot(setting), index, newNodes);\n        view.createNodes(setting, 0, newNodes, null, index);\n      }\n    },\n    appendNodes: function appendNodes(setting, level, nodes, parentNode, index, initFlag, openFlag) {\n      if (!nodes) return [];\n      var tmpPNode = parentNode || data.getRoot(setting),\n          tmpPChild = tmpPNode[setting.data.key.children],\n          html = [],\n          isFirstNode,\n          isLastNode;\n\n      if (!tmpPChild || index >= tmpPChild.length - nodes.length) {\n        index = -1;\n      }\n\n      for (var i = 0, l = nodes.length, Z; i < l; i++) {\n        var node = nodes[i];\n\n        if (initFlag) {\n          isFirstNode = (index === 0 || tmpPChild.length == nodes.length) && i == 0;\n          isLastNode = index < 0 && i == nodes.length - 1;\n          data.initNode(setting, level, node, parentNode, isFirstNode, isLastNode, openFlag);\n          data.addNodeCache(setting, node);\n        }\n\n        Z = node[setting.treeId];\n        var childHtml = [];\n        var children = node[setting.data.key.children];\n\n        if (children && children.length > 0) {\n          //make child html first, because checkType\n          childHtml = view.appendNodes(setting, level + 1, children, node, -1, initFlag, openFlag && Z.open);\n        }\n\n        if (openFlag && Z) {\n          view.makeDOMNodeMainBefore(html, setting, node, Z);\n          view.makeDOMNodeDiv(html, setting, node, Z);\n          view.makeDOMNodeLine(html, setting, node, Z);\n          data.getBeforeA(setting, node, html);\n          view.makeDOMNodeNameBefore(html, setting, node, Z);\n          data.getInnerBeforeA(setting, node, html);\n          view.makeDOMNodeIcon(html, setting, node, Z);\n          data.getInnerAfterIcon(setting, node, html);\n          view.makeDOMNodeName(html, setting, node, Z);\n          data.getInnerAfterA(setting, node, html);\n          html.push(\"</a>\"); //view.makeDOMNodeNameAfter(html, setting, node);\n\n          data.getAfterA(setting, node, html);\n          html.push(\"</div>\");\n\n          if (Z.isParent && Z.open) {\n            view.makeUlHtml(setting, node, html, childHtml.join(''), Z);\n          }\n\n          html.push(\"</li>\"); //view.makeDOMNodeMainAfter(html, setting, node);\n\n          data.addCreatedNode(setting, node);\n          Z.dom = true;\n        }\n      }\n\n      return html;\n    },\n    appendParentULDom: function appendParentULDom(setting, node) {\n      var html = [],\n          nObj = $$(node, setting),\n          Z = node[setting.treeId],\n          parent;\n\n      if (!nObj.get(0) && !!(parent = node[setting.data.key.parent])) {\n        view.appendParentULDom(setting, parent);\n        parent = null;\n        nObj = $$(node, setting);\n      }\n\n      var ulObj = $$(node, consts.id.UL, setting);\n\n      if (ulObj.get(0)) {\n        ulObj.remove();\n      }\n\n      var children = node[setting.data.key.children],\n          childHtml = view.appendNodes(setting, Z.level + 1, children, node, -1, false, true);\n      view.makeUlHtml(setting, node, html, childHtml.join(''), Z);\n      nObj.append(html.join(''));\n    },\n    asyncNode: function asyncNode(setting, node, isSilent, callback) {\n      if (node && !node[setting.treeId].isParent) {\n        tools.apply(callback);\n        return false;\n      } else if (node && node[setting.treeId].isAjaxing) {\n        return false;\n      } else if (tools.apply(setting.callback.beforeAsync, [node], true) == false) {\n        tools.apply(callback);\n        return false;\n      }\n\n      if (node) {\n        node[setting.treeId].isAjaxing = true;\n        var icoObj = $$(node, consts.id.ICON, setting);\n        icoObj.attr({\n          \"style\": \"\",\n          \"class\": consts.className.BUTTON + \" \" + consts.className.ICO_LOADING\n        });\n      }\n\n      var i,\n          l,\n          tmpParam = {};\n      var autoParam = tools.apply(setting.async.autoParam, [node], setting.async.autoParam);\n\n      for (i = 0, l = autoParam.length; node && i < l; i++) {\n        var pKey = autoParam[i].split(\"=\"),\n            spKey = pKey;\n\n        if (pKey.length > 1) {\n          spKey = pKey[1];\n          pKey = pKey[0];\n        }\n\n        tmpParam[spKey] = node[pKey];\n      }\n\n      var otherParam = tools.apply(setting.async.otherParam, [node], setting.async.otherParam);\n\n      if (tools.isArray(otherParam)) {\n        for (i = 0, l = otherParam.length; i < l; i += 2) {\n          tmpParam[otherParam[i]] = otherParam[i + 1];\n        }\n      } else {\n        for (var p in otherParam) {\n          tmpParam[p] = otherParam[p];\n        }\n      }\n\n      var _tmpV = data.getRoot(setting)._ver;\n\n      _$.ajax({\n        contentType: setting.async.contentType,\n        cache: false,\n        type: setting.async.type,\n        url: tools.apply(setting.async.url, [node], setting.async.url),\n        data: setting.async.contentType.indexOf('application/json') > -1 ? JSON.stringify(tmpParam) : tmpParam,\n        dataType: setting.async.dataType,\n        headers: setting.async.headers,\n        xhrFields: setting.async.xhrFields,\n        success: function success(msg) {\n          if (_tmpV != data.getRoot(setting)._ver) {\n            return;\n          }\n\n          var newNodes = [];\n\n          try {\n            if (!msg || msg.length == 0) {\n              newNodes = [];\n            } else if (typeof msg == \"string\") {\n              newNodes = eval(\"(\" + msg + \")\");\n            } else {\n              newNodes = msg;\n            }\n          } catch (err) {\n            newNodes = msg;\n          }\n\n          var Z = node ? node[setting.treeId] : null;\n\n          if (Z) {\n            Z.isAjaxing = null;\n            Z.zAsync = true;\n          }\n\n          view.setNodeLineIcos(setting, node, Z);\n\n          if (newNodes && newNodes !== \"\") {\n            newNodes = tools.apply(setting.async.dataFilter, [node, newNodes], newNodes);\n            view.addNodes(setting, node, -1, !!newNodes ? newNodes : [], !!isSilent);\n          } else {\n            view.addNodes(setting, node, -1, [], !!isSilent);\n          }\n\n          setting.treeObj.trigger(consts.event.ASYNC_SUCCESS, [node, msg]);\n          tools.apply(callback);\n        },\n        error: function error(XMLHttpRequest, textStatus, errorThrown) {\n          if (_tmpV != data.getRoot(setting)._ver) {\n            return;\n          }\n\n          var Z = node ? node[setting.treeId] : null;\n          Z && (Z.isAjaxing = null);\n          view.setNodeLineIcos(setting, node, Z);\n          setting.treeObj.trigger(consts.event.ASYNC_ERROR, [node, XMLHttpRequest, textStatus, errorThrown]);\n        }\n      });\n\n      return true;\n    },\n    cancelPreSelectedNode: function cancelPreSelectedNode(setting, node, excludeNode) {\n      var list = data.getRoot(setting).curSelectedList,\n          i,\n          n;\n\n      for (i = list.length - 1; i >= 0; i--) {\n        n = list[i];\n\n        if (node === n || !node && (!excludeNode || excludeNode !== n)) {\n          $$(n, consts.id.DIV, setting).css('background-color', '');\n\n          if (node) {\n            data.removeSelectedNode(setting, node);\n            break;\n          } else {\n            list.splice(i, 1);\n            setting.treeObj.trigger(consts.event.UNSELECTED, [n]);\n          }\n        }\n      }\n    },\n    createNodeCallback: function createNodeCallback(setting) {\n      if (!!setting.callback.onNodeCreated || !!setting.view.addDiyDom) {\n        var root = data.getRoot(setting);\n\n        while (root.createdNodes.length > 0) {\n          var node = root.createdNodes.shift();\n          tools.apply(setting.view.addDiyDom, [node]);\n\n          if (!!setting.callback.onNodeCreated) {\n            setting.treeObj.trigger(consts.event.NODECREATED, [node]);\n          }\n        }\n      }\n    },\n    createNodes: function createNodes(setting, level, nodes, parentNode, index) {\n      if (!nodes || nodes.length == 0) return;\n      var root = data.getRoot(setting),\n          openFlag = !parentNode || parentNode[setting.treeId].open || !!$$(parentNode[setting.data.key.children][0], setting).get(0);\n      root.createdNodes = [];\n      var zTreeHtml = view.appendNodes(setting, level, nodes, parentNode, index, true, openFlag),\n          parentObj,\n          nextObj;\n\n      if (!parentNode) {\n        parentObj = setting.treeObj;\n      } else {\n        var ulObj = $$(parentNode, consts.id.UL, setting);\n\n        if (ulObj.get(0)) {\n          parentObj = ulObj;\n        }\n      }\n\n      if (parentObj) {\n        if (index >= 0) {\n          nextObj = parentObj.children()[index];\n        }\n\n        if (index >= 0 && nextObj) {\n          _$(nextObj).before(zTreeHtml.join(''));\n        } else {\n          parentObj.append(zTreeHtml.join(''));\n        }\n      }\n\n      view.createNodeCallback(setting);\n    },\n    destroy: function destroy(setting) {\n      if (!setting) return;\n\n      let _data$getCache = data.getCache(setting),\n          nodes = _data$getCache.nodes;\n\n      if (nodes) {\n        for (let i in nodes) {\n          if (nodes[i]) delete nodes[i][setting.treeId];\n        }\n      }\n\n      data.initCache(setting);\n      data.initRoot(setting);\n      event.unbindTree(setting);\n      event.unbindEvent(setting);\n      setting.treeObj.empty();\n      delete settings[setting.treeId];\n    },\n    expandCollapseNode: function expandCollapseNode(setting, node, expandFlag, animateFlag, callback) {\n      var root = data.getRoot(setting);\n\n      var _callback;\n\n      if (!node) {\n        tools.apply(callback, []);\n        return;\n      }\n\n      var children = node[setting.data.key.children];\n      var Z = node[setting.treeId];\n\n      if (root.expandTriggerFlag) {\n        _callback = callback;\n\n        callback = function callback() {\n          if (_callback) _callback();\n          setting.treeObj.trigger(Z.open ? consts.event.EXPAND : consts.event.COLLAPSE, [node]);\n        };\n\n        root.expandTriggerFlag = false;\n      }\n\n      Z ? Z = Z : Z = {\n        open: null\n      };\n\n      if (!Z.open && Z.isParent && (!$$(node, consts.id.UL, setting).get(0) || children && children.length > 0 && !$$(children[0], setting).get(0))) {\n        view.appendParentULDom(setting, node);\n        view.createNodeCallback(setting);\n      }\n\n      if (Z.open == expandFlag) {\n        tools.apply(callback, []);\n        return;\n      }\n\n      var ulObj = $$(node, consts.id.UL, setting),\n          switchObj = $$(node, consts.id.SWITCH, setting),\n          icoObj = $$(node, consts.id.ICON, setting);\n\n      if (Z.isParent) {\n        Z.open = !Z.open;\n\n        if (setting.view.iconUrlFunction) {\n          icoObj.attr(\"style\", view.makeNodeIcoStyle(setting, node, Z));\n        }\n\n        if (Z.open) {\n          view.replaceSwitchClass(Z.level, switchObj, consts.folder.OPEN);\n          view.replaceIcoClass(icoObj, setting, node, Z);\n\n          if (animateFlag == false || setting.view.expandSpeed == \"\") {\n            ulObj.show();\n            tools.apply(callback, []);\n          } else {\n            if (children && children.length > 0) {\n              ulObj.slideDown(setting.view.expandSpeed, callback);\n            } else {\n              ulObj.show();\n              tools.apply(callback, []);\n            }\n          }\n        } else {\n          view.replaceSwitchClass(Z.level, switchObj, consts.folder.CLOSE);\n          view.replaceIcoClass(icoObj, setting, node, Z);\n\n          if (animateFlag == false || setting.view.expandSpeed == \"\" || !(children && children.length > 0)) {\n            ulObj.hide();\n            tools.apply(callback, []);\n          } else {\n            ulObj.slideUp(setting.view.expandSpeed, callback);\n          }\n        }\n      } else {\n        tools.apply(callback, []);\n      }\n    },\n    expandCollapseParentNode: function expandCollapseParentNode(setting, node, expandFlag, animateFlag, callback) {\n      if (!node) return;\n      var parent = node[setting.data.key.parent];\n      var Z = parent ? parent[setting.treeId] : null;\n      parent = Z ? data.getNodeCache(setting, Z.tId) : null;\n\n      if (!parent) {\n        view.expandCollapseNode(setting, node, expandFlag, animateFlag, callback);\n      } else {\n        view.expandCollapseNode(setting, node, expandFlag, animateFlag);\n        view.expandCollapseParentNode(setting, parent, expandFlag, animateFlag, callback);\n      }\n    },\n    expandCollapseSonNode: function expandCollapseSonNode(setting, node, expandFlag, animateFlag, callback) {\n      var root = data.getRoot(setting),\n          treeNodes = node ? node[setting.data.key.children] : root[setting.data.key.children],\n          selfAnimateSign = node ? false : animateFlag,\n          expandTriggerFlag = data.getRoot(setting).expandTriggerFlag;\n      data.getRoot(setting).expandTriggerFlag = false;\n\n      if (treeNodes) {\n        for (var i = 0, l = treeNodes.length; i < l; i++) {\n          if (treeNodes[i]) view.expandCollapseSonNode(setting, treeNodes[i], expandFlag, selfAnimateSign);\n        }\n      }\n\n      data.getRoot(setting).expandTriggerFlag = expandTriggerFlag;\n      view.expandCollapseNode(setting, node, expandFlag, animateFlag, callback);\n    },\n    isSelectedNode: function isSelectedNode(setting, node) {\n      if (!node) {\n        return false;\n      }\n\n      var list = data.getRoot(setting).curSelectedList,\n          i;\n\n      for (i = list.length - 1; i >= 0; i--) {\n        if (node === list[i]) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n    makeDOMNodeDiv: function makeDOMNodeDiv(html, setting, node, Z) {\n      html.push(\"<div id='\" + Z.tId + \"_div' treeNode_div style='height:22px\");\n\n      if (setting.view.hideFunction) {\n        Z.hide = setting.view.hideFunction(node);\n        Z.hide && html.push(\";display:none\");\n      }\n\n      html.push(\"'\");\n\n      if (setting.view.titleFunction) {\n        var title = setting.view.titleFunction(node);\n        if (title) html.push(\" title='\", title.replace(/'/g, \"&#39;\").replace(/</g, '&lt;').replace(/>/g, '&gt;'), \"'\");\n      }\n\n      html.push(\">\");\n    },\n    makeDOMNodeIcon: function makeDOMNodeIcon(html, setting, node, Z) {\n      html.push(\"<span id='\", Z.tId, consts.id.ICON, \"' treeNode\", consts.id.ICON, \" class='\", view.makeNodeIcoClass(setting, node, Z), \"' style='\", view.makeNodeIcoStyle(setting, node, Z), \"'></span>\");\n    },\n    makeDOMNodeName: function makeDOMNodeName(html, setting, node, Z) {\n      var nameStr = data.nodeName(setting, node),\n          name = nameStr ? setting.view.nameIsHTML ? nameStr : nameStr.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;') : '';\n      html.push(\"<span id='\", Z.tId, consts.id.SPAN, \"' class='\", consts.className.NAME, \"'>\", name, \"</span>\");\n    },\n    makeDOMNodeLine: function makeDOMNodeLine(html, setting, node, Z) {\n      html.push(\"<span id='\", Z.tId, consts.id.SWITCH, \"' class='\", view.makeNodeLineClass(setting, node, Z), \"' treeNode\", consts.id.SWITCH, \"></span>\");\n    },\n    makeDOMNodeMainBefore: function makeDOMNodeMainBefore(html, setting, node, Z) {\n      html.push(\"<li id='\", Z.tId, \"' class='\", consts.className.LEVEL, Z.level, \"' tabindex='0' hidefocus='true' treenode>\");\n    },\n    makeDOMNodeNameBefore: function makeDOMNodeNameBefore(html, setting, node, Z) {\n      html.push(\"<a id='\", Z.tId, consts.id.A, \"' class='\", consts.className.LEVEL, Z.level, \"' treeNode\", consts.id.A, \">\"); //, \" onclick=\\\"\", (Z.click || ''), \"\\\" \", \"style='\", fontStyle.join(''), \"'\"\n    },\n    makeNodeIcoClass: function makeNodeIcoClass(setting, node, Z) {\n      var iconCss = consts.className.BUTTON + \" ico \";\n\n      if (!Z.isAjaxing) {\n        if (setting.view.iconCssFunction) {\n          var css = setting.view.iconCssFunction(node, Z.open);\n          if (css) return iconCss + css;\n        }\n\n        if (Z.isParent) {\n          iconCss += 'ico_' + (Z.open ? consts.folder.OPEN : consts.folder.CLOSE);\n        } else {\n          iconCss += 'ico_' + consts.folder.DOCU;\n        }\n      }\n\n      return iconCss;\n    },\n    makeNodeIcoStyle: function makeNodeIcoStyle(setting, node, Z) {\n      if (!Z.isAjaxing && setting.view.iconUrlFunction) {\n        var iconUrl = setting.view.iconUrlFunction(node, Z.open);\n        if (iconUrl) return \"background-size:16px 16px;background-image:url(\" + iconUrl + \");\";\n      }\n\n      return '';\n    },\n    makeNodeLineClass: function makeNodeLineClass(setting, node, Z) {\n      var lineClass = [];\n\n      if (setting.view.showLine) {\n        if (Z.level == 0 && Z.isFirstNode && Z.isLastNode) {\n          lineClass.push(consts.line.ROOT);\n        } else if (Z.level == 0 && Z.isFirstNode) {\n          lineClass.push(consts.line.ROOTS);\n        } else if (Z.isLastNode) {\n          lineClass.push(consts.line.BOTTOM);\n        } else {\n          lineClass.push(consts.line.CENTER);\n        }\n      } else {\n        lineClass.push(consts.line.NOLINE);\n      }\n\n      if (Z.isParent) {\n        lineClass.push(Z.open ? consts.folder.OPEN : consts.folder.CLOSE);\n      } else {\n        lineClass.push(consts.folder.DOCU);\n      }\n\n      return view.makeNodeLineClassEx(Z.level) + lineClass.join('_');\n    },\n    makeNodeLineClassEx: function makeNodeLineClassEx(level) {\n      return consts.className.BUTTON + \" \" + consts.className.LEVEL + level + \" \" + consts.className.SWITCH + \" \";\n    },\n    makeUlHtml: function makeUlHtml(setting, node, html, content, Z) {\n      html.push(\"<ul id='\", Z.tId, consts.id.UL, \"' class='\", consts.className.LEVEL, Z.level, \" \", view.makeUlLineClass(setting, Z), \"' style='display:\", Z.open ? \"block\" : \"none\", \"'>\");\n      html.push(content);\n      html.push(\"</ul>\");\n    },\n    makeUlLineClass: function makeUlLineClass(setting, Z) {\n      return setting.view.showLine && !Z.isLastNode ? consts.line.LINE : \"\";\n    },\n    removeChildNodes: function removeChildNodes(setting, node) {\n      if (!node) return;\n      var nodes = node[setting.data.key.children];\n      if (!nodes) return;\n\n      for (var i = 0, l = nodes.length; i < l; i++) {\n        data.removeNodeCache(setting, nodes[i]);\n        delete nodes[i][setting.treeId];\n      }\n\n      data.removeSelectedNode(setting);\n      delete node[setting.data.key.children];\n\n      if (!setting.data.keep.parent) {\n        var Z = node[setting.treeId];\n        Z.isParent = false;\n        Z.open = false;\n        var tmp_switchObj = $$(node, consts.id.SWITCH, setting),\n            tmp_icoObj = $$(node, consts.id.ICON, setting);\n        view.replaceSwitchClass(Z.level, tmp_switchObj, consts.folder.DOCU);\n        view.replaceIcoClass(tmp_icoObj, setting, node, Z);\n        $$(node, consts.id.UL, setting).remove();\n      } else {\n        $$(node, consts.id.UL, setting).empty();\n      }\n    },\n    scrollIntoView: function scrollIntoView(setting, dom) {\n      if (!dom) {\n        return;\n      } // support IE 7\n\n\n      if (typeof Element === 'undefined') {\n        var contRect = setting.treeObj.get(0).getBoundingClientRect(),\n            findMeRect = dom.getBoundingClientRect();\n\n        if (findMeRect.top < contRect.top || findMeRect.bottom > contRect.bottom || findMeRect.right > contRect.right || findMeRect.left < contRect.left) {\n          dom.scrollIntoView();\n        }\n\n        return;\n      } // CC-BY jocki84@googlemail.com, https://gist.github.com/jocki84/6ffafd003387179a988e\n\n\n      if (!Element.prototype.scrollIntoViewIfNeeded) {\n        Element.prototype.scrollIntoViewIfNeeded = function (centerIfNeeded) {\n          \"use strict\";\n\n          function makeRange(start, length) {\n            return {\n              \"start\": start,\n              \"length\": length,\n              \"end\": start + length\n            };\n          }\n\n          function coverRange(inner, outer) {\n            if (false === centerIfNeeded || outer.start < inner.end && inner.start < outer.end) {\n              return Math.max(inner.end - outer.length, Math.min(outer.start, inner.start));\n            }\n\n            return (inner.start + inner.end - outer.length) / 2;\n          }\n\n          function makePoint(x, y) {\n            return {\n              \"x\": x,\n              \"y\": y,\n              \"translate\": function translate(dX, dY) {\n                return makePoint(x + dX, y + dY);\n              }\n            };\n          }\n\n          function absolute(elem, pt) {\n            while (elem) {\n              pt = pt.translate(elem.offsetLeft, elem.offsetTop);\n              elem = elem.offsetParent;\n            }\n\n            return pt;\n          }\n\n          var target = absolute(this, makePoint(0, 0)),\n              extent = makePoint(this.offsetWidth, this.offsetHeight),\n              elem = this.parentNode,\n              origin;\n\n          while (elem instanceof HTMLElement) {\n            // Apply desired scroll amount.\n            origin = absolute(elem, makePoint(elem.clientLeft, elem.clientTop)); //elem.scrollLeft = coverRange(makeRange(target.x - origin.x, extent.x), makeRange(elem.scrollLeft, elem.clientWidth));\n\n            elem.scrollTop = coverRange(makeRange(target.y - origin.y, extent.y), makeRange(elem.scrollTop, elem.clientHeight)); // Determine actual scroll amount by reading back scroll properties.\n\n            target = target.translate(-elem.scrollLeft, -elem.scrollTop);\n            elem = elem.parentNode;\n          }\n        };\n      }\n\n      dom.scrollIntoViewIfNeeded();\n      let treeDom = setting.treeObj.get(0).parentNode;\n      treeDom.scrollBy(-1000, 0);\n    },\n    setFirstNode: function setFirstNode(setting, parentNode) {\n      var children = parentNode[setting.data.key.children];\n\n      if (children && children.length > 0) {\n        children[0][setting.treeId].isFirstNode = true;\n      }\n    },\n    setLastNode: function setLastNode(setting, parentNode) {\n      var children = parentNode[setting.data.key.children];\n\n      if (children && children.length > 0) {\n        children[children.length - 1][setting.treeId].isLastNode = true;\n      }\n    },\n    removeNode: function removeNode(setting, node) {\n      var root = data.getRoot(setting),\n          parentNode = node[setting.data.key.parent] || root,\n          Z = node[setting.treeId];\n      Z.isFirstNode = false;\n      Z.isLastNode = false;\n\n      if (!data.getNodeCache(setting, Z.tId)) {\n        return;\n      }\n\n      $$(node, setting).remove();\n      data.removeNodeCache(setting, node);\n      data.removeSelectedNode(setting, node);\n      var children = parentNode[setting.data.key.children] || [];\n\n      for (var i = 0, l = children.length; i < l; i++) {\n        if (children[i][setting.treeId].tId == Z.tId) {\n          children.splice(i, 1);\n          break;\n        }\n      }\n\n      delete node[setting.treeId];\n      view.setFirstNode(setting, parentNode);\n      view.setLastNode(setting, parentNode);\n      var tmp_ulObj,\n          tmp_switchObj,\n          tmp_icoObj,\n          childLength = children.length; //repair nodes old parent\n\n      if (!setting.data.keep.parent && childLength == 0) {\n        //old parentNode has no child nodes\n        var pZ = parentNode[setting.treeId];\n        pZ.isParent = false;\n        pZ.open = false;\n        delete parentNode[setting.data.key.children];\n        tmp_ulObj = $$(parentNode, consts.id.UL, setting);\n        tmp_switchObj = $$(parentNode, consts.id.SWITCH, setting);\n        tmp_icoObj = $$(parentNode, consts.id.ICON, setting);\n        view.replaceSwitchClass(pZ.level, tmp_switchObj, consts.folder.DOCU);\n        view.replaceIcoClass(tmp_icoObj, setting, parentNode, pZ);\n        tmp_ulObj.css(\"display\", \"none\");\n      } else if (setting.view.showLine && childLength > 0) {\n        //old parentNode has child nodes\n        var newLast = children[childLength - 1];\n        tmp_ulObj = $$(newLast, consts.id.UL, setting);\n        tmp_switchObj = $$(newLast, consts.id.SWITCH, setting);\n        tmp_icoObj = $$(newLast, consts.id.ICON, setting);\n\n        if (parentNode == root) {\n          if (children.length == 1) {\n            //node was root, and ztree has only one root after move node\n            view.replaceSwitchClass(newLast[setting.treeId].level, tmp_switchObj, consts.line.ROOT);\n          } else {\n            var tmp_first_switchObj = $$(children[0], consts.id.SWITCH, setting);\n            view.replaceSwitchClass(children[0][setting.treeId].level, tmp_first_switchObj, consts.line.ROOTS);\n            view.replaceSwitchClass(newLast[setting.treeId].level, tmp_switchObj, consts.line.BOTTOM);\n          }\n        } else {\n          view.replaceSwitchClass(newLast[setting.treeId].level, tmp_switchObj, consts.line.BOTTOM);\n        }\n\n        tmp_ulObj.removeClass(consts.line.LINE);\n      }\n    },\n    replaceIcoClass: function replaceIcoClass(obj, setting, node, Z) {\n      if (!obj || Z.isAjaxing) return;\n      obj.attr(\"class\", this.makeNodeIcoClass(setting, node, Z));\n    },\n    replaceSwitchClass: function replaceSwitchClass(level, obj, newName) {\n      if (!obj) return;\n      var tmpName = obj.attr(\"class\");\n      if (tmpName == undefined) return;\n      var tmpList = tmpName.split(\"_\");\n\n      switch (newName) {\n        case consts.line.ROOT:\n        case consts.line.ROOTS:\n        case consts.line.CENTER:\n        case consts.line.BOTTOM:\n        case consts.line.NOLINE:\n          tmpList[0] = view.makeNodeLineClassEx(level) + newName;\n          break;\n\n        case consts.folder.OPEN:\n        case consts.folder.CLOSE:\n        case consts.folder.DOCU:\n          tmpList[1] = newName;\n          break;\n      }\n\n      obj.attr(\"class\", tmpList.join(\"_\"));\n\n      if (newName !== consts.folder.DOCU) {\n        obj.removeAttr(\"disabled\");\n      } else {\n        obj.attr(\"disabled\", \"disabled\");\n      }\n    },\n    selectNode: function selectNode(setting, node) {\n      view.cancelPreSelectedNode(setting, null, node);\n      $$(node, consts.id.DIV, setting).css('background-color', $_theme.selected_color);\n      data.addSelectedNode(setting, node);\n      setting.treeObj.trigger(consts.event.SELECTED, [node]);\n    },\n    setNodeLineIcos: function setNodeLineIcos(setting, node, Z) {\n      if (!node) return;\n      var switchObj = $$(node, consts.id.SWITCH, setting),\n          ulObj = $$(node, consts.id.UL, setting),\n          icoObj = $$(node, consts.id.ICON, setting),\n          ulLine = view.makeUlLineClass(setting, Z);\n\n      if (ulLine.length == 0) {\n        ulObj.removeClass(consts.line.LINE);\n      } else {\n        ulObj.addClass(ulLine);\n      }\n\n      switchObj.attr(\"class\", view.makeNodeLineClass(setting, node, Z));\n\n      if (Z.isParent) {\n        switchObj.removeAttr(\"disabled\");\n      } else {\n        switchObj.attr(\"disabled\", \"disabled\");\n      }\n\n      icoObj.removeAttr(\"style\");\n      icoObj.attr(\"style\", view.makeNodeIcoStyle(setting, node, Z));\n      icoObj.attr(\"class\", view.makeNodeIcoClass(setting, node, Z));\n    },\n    setNodeName: function setNodeName(setting, node) {\n      var nObj = $$(node, consts.id.SPAN, setting);\n      nObj.empty();\n\n      if (setting.view.nameIsHTML) {\n        nObj.html(data.nodeName(setting, node));\n      } else {\n        nObj.text(data.nodeName(setting, node));\n      }\n    },\n    setNodeTitle: function setNodeTitle(setting, node) {\n      if (setting.view.titleFunction) {\n        var title = setting.view.titleFunction(node);\n        $$(node, consts.id.DIV, setting).attr(\"title\", !title ? \"\" : title);\n      }\n    },\n    setNodeHide: function setNodeHide(setting, node, Z) {\n      if (setting.view.hideFunction) {\n        var hide = setting.view.hideFunction(node);\n        if ((Z.hide || false) === hide) return;\n        Z.hide = hide;\n        $$(node, consts.id.DIV, setting).css(\"display\", hide ? \"none\" : '');\n        $$(node, consts.id.UL, setting).css(\"display\", hide ? \"none\" : '');\n      }\n    },\n    switchNode: function switchNode(setting, node, open) {\n      if (open || !tools.canAsync(setting, node)) {\n        view.expandCollapseNode(setting, node, !open);\n      } else if (setting.async.enable) {\n        if (!view.asyncNode(setting, node)) {\n          view.expandCollapseNode(setting, node, !open);\n          return;\n        }\n      } else if (node) {\n        view.expandCollapseNode(setting, node, !open);\n      }\n    }\n  }; // zTree defind\n\n\n  _$.fn.zTree = {\n    consts: _consts,\n    _z: {\n      tools: tools,\n      view: view,\n      event: event,\n      data: data\n    },\n    getZTreeObj: function getZTreeObj(treeId) {\n      var o = data.getZTreeTools(treeId);\n      return o ? o : null;\n    },\n    destroy: function destroy(treeId) {\n      if (!!treeId && treeId.length > 0) {\n        view.destroy(data.getSetting(treeId));\n      } else {\n        for (var s in settings) {\n          view.destroy(settings[s]);\n        }\n      }\n    },\n    init: function init(obj, zSetting, zNodes) {\n      var setting = tools.clone(_setting);\n\n      _$.extend(true, setting, zSetting);\n\n      setting.treeId = obj.attr(\"id\");\n      setting.treeObj = obj;\n      setting.treeObj.empty();\n      settings[setting.treeId] = setting; //For some older browser,(e.g., ie6)\n\n      if (typeof document.body.style.maxHeight === \"undefined\") {\n        setting.view.expandSpeed = \"\";\n      }\n\n      data.initRoot(setting);\n      var root = data.getRoot(setting);\n      zNodes = zNodes ? tools.isArray(zNodes) ? zNodes : [zNodes] : [];\n      root[setting.data.key.children] = zNodes;\n      data.initCache(setting);\n      event.unbindTree(setting);\n      event.bindTree(setting);\n      event.unbindEvent(setting);\n      event.bindEvent(setting);\n      var zTreeTools = {\n        setting: setting,\n        addNodes: function addNodes(parentNode, index, newNodes, isSilent) {\n          if (!parentNode) parentNode = null;\n          if (parentNode && !parentNode[setting.treeId].isParent && setting.data.keep.leaf) return null;\n          var i = parseInt(index, 10);\n\n          if (isNaN(i)) {\n            isSilent = !!newNodes;\n            newNodes = index;\n            index = -1;\n          } else {\n            index = i;\n          }\n\n          if (!newNodes) return null;\n          var xNewNodes = tools.isArray(newNodes) ? newNodes : [newNodes];\n\n          function addCallback() {\n            view.addNodes(setting, parentNode, index, xNewNodes, isSilent == true);\n          }\n\n          if (tools.canAsync(setting, parentNode)) {\n            view.asyncNode(setting, parentNode, isSilent, addCallback);\n          } else {\n            addCallback();\n          }\n\n          return xNewNodes;\n        },\n        cancelSelectedNode: function cancelSelectedNode(node) {\n          view.cancelPreSelectedNode(setting, node);\n        },\n        destroy: function destroy() {\n          view.destroy(setting);\n        },\n        expandAll: function expandAll(expandFlag) {\n          expandFlag = !!expandFlag;\n          view.expandCollapseSonNode(setting, null, expandFlag, true);\n          return expandFlag;\n        },\n        expandNode: function expandNode(node, expandFlag, sonSign, focus, callbackFlag) {\n          if (!node) return null;\n          var Z = node[setting.treeId];\n          if (!Z.isParent || expandFlag === !!Z.open) return null;\n\n          if (expandFlag !== true && expandFlag !== false) {\n            expandFlag = !Z.open;\n          }\n\n          callbackFlag = !!callbackFlag;\n\n          if (callbackFlag && expandFlag && tools.apply(setting.callback.beforeExpand, [node], true) == false) {\n            return null;\n          } else if (callbackFlag && !expandFlag && tools.apply(setting.callback.beforeCollapse, [node], true) == false) {\n            return null;\n          }\n\n          var parent;\n\n          if (expandFlag && (parent = node[setting.data.key.parent])) {\n            view.expandCollapseParentNode(setting, parent, expandFlag, false);\n            parent = null;\n          }\n\n          if (expandFlag === Z.open && !sonSign) {\n            return null;\n          }\n\n          data.getRoot(setting).expandTriggerFlag = callbackFlag;\n\n          if (!tools.canAsync(setting, node) && sonSign) {\n            view.expandCollapseSonNode(setting, node, expandFlag, true, showNodeFocus);\n          } else {\n            Z.open = !expandFlag;\n            view.switchNode(this.setting, node, Z.open);\n            showNodeFocus();\n          }\n\n          return expandFlag;\n\n          function showNodeFocus() {\n            var a = $$(node, setting).get(0);\n\n            if (a && focus !== false) {\n              view.scrollIntoView(setting, a);\n            }\n          }\n        },\n        getNodes: function getNodes() {\n          return data.getNodes(setting);\n        },\n        getNodeByParam: function getNodeByParam(key, value, parentNode) {\n          if (!key) return null;\n          return data.getNodeByParam(setting, parentNode ? parentNode[setting.data.key.children] : data.getNodes(setting), key, value);\n        },\n        getNodeByTId: function getNodeByTId(tId) {\n          return data.getNodeCache(setting, tId);\n        },\n        getNodesByParam: function getNodesByParam(key, value, parentNode) {\n          if (!key) return null;\n          return data.getNodesByParam(setting, parentNode ? parentNode[setting.data.key.children] : data.getNodes(setting), key, value);\n        },\n        getNodesByParamFuzzy: function getNodesByParamFuzzy(key, value, parentNode) {\n          if (!key) return null;\n          return data.getNodesByParamFuzzy(setting, parentNode ? parentNode[setting.data.key.children] : data.getNodes(setting), key, value);\n        },\n        getNodesByFilter: function getNodesByFilter(filter, isSingle, parentNode, invokeParam) {\n          isSingle = !!isSingle;\n          if (!filter || typeof filter != \"function\") return isSingle ? null : [];\n          return data.getNodesByFilter(setting, parentNode ? parentNode[setting.data.key.children] : data.getNodes(setting), filter, isSingle, invokeParam);\n        },\n        getSelectedNodes: function getSelectedNodes() {\n          var r = [],\n              list = data.getRoot(setting).curSelectedList;\n\n          for (var i = 0, l = list.length; i < l; i++) {\n            r.push(list[i]);\n          }\n\n          return r;\n        },\n        isSelectedNode: function isSelectedNode(node) {\n          return data.isSelectedNode(setting, node);\n        },\n        reAsyncChildNodesPromise: function reAsyncChildNodesPromise(parentNode, reloadType, isSilent) {\n          var promise = new Promise(function (resolve, reject) {\n            try {\n              zTreeTools.reAsyncChildNodes(parentNode, reloadType, isSilent, function () {\n                resolve(parentNode);\n              });\n            } catch (e) {\n              reject(e);\n            }\n          });\n          return promise;\n        },\n        reAsyncChildNodes: function reAsyncChildNodes(parentNode, reloadType, isSilent, callback) {\n          if (!this.setting.async.enable) return;\n          var isRoot = !parentNode;\n\n          if (isRoot) {\n            parentNode = data.getRoot(setting);\n          }\n\n          if (reloadType == \"refresh\") {\n            var children = parentNode[setting.data.key.children];\n\n            for (var i = 0, l = children ? children.length : 0; i < l; i++) {\n              data.removeNodeCache(setting, children[i]);\n            }\n\n            data.removeSelectedNode(setting);\n            parentNode[setting.data.key.children] = [];\n\n            if (isRoot) {\n              this.setting.treeObj.empty();\n            } else {\n              var ulObj = $$(parentNode, consts.id.UL, setting);\n              ulObj.empty();\n            }\n          }\n\n          view.asyncNode(this.setting, isRoot ? null : parentNode, !!isSilent, callback);\n        },\n        refresh: function refresh(nodes) {\n          let selectedList = data.getRoot(setting).curSelectedList || [];\n          this.setting.treeObj.empty();\n          var root = data.getRoot(setting);\n          nodes = nodes || root[setting.data.key.children];\n          data.initRoot(setting);\n          root[setting.data.key.children] = nodes;\n          data.initCache(setting);\n          view.createNodes(setting, 0, nodes, null, -1);\n          selectedList.forEach(node => view.selectNode(setting, node));\n        },\n        reset: function reset(zNodes) {\n          let keep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n          let _data$getCache2 = data.getCache(this.setting),\n              nodes = _data$getCache2.nodes;\n\n          if (nodes) {\n            let treeId = this.setting.treeId,\n                node;\n\n            for (let i in nodes) {\n              node = nodes[i];\n              if (!node || !node[treeId]) continue;\n              !keep ? delete node[treeId] : node[treeId].dom = false;\n            }\n          }\n\n          zNodes = zNodes ? tools.isArray(zNodes) ? zNodes : [zNodes] : [];\n          zNodes.length == 1 && (zNodes[0][this.setting.treeId] = zNodes[0][this.setting.treeId] || {\n            open: true\n          });\n          this.setting.treeObj.empty();\n          var root = data.getRoot(setting);\n          data.initRoot(setting);\n          root[setting.data.key.children] = zNodes;\n          data.initCache(setting);\n          view.createNodes(setting, 0, zNodes, null, -1);\n        },\n        removeChildNodes: function removeChildNodes(node) {\n          if (!node) return null;\n          var nodes = node[setting.data.key.children];\n          view.removeChildNodes(setting, node);\n          return nodes ? nodes : null;\n        },\n        removeNode: function removeNode(node, callbackFlag) {\n          if (!node || !node[setting.treeId]) return;\n          callbackFlag = !!callbackFlag;\n          if (callbackFlag && tools.apply(setting.callback.beforeRemove, [node], true) == false) return;\n          view.removeNode(setting, node);\n\n          if (callbackFlag) {\n            this.setting.treeObj.trigger(consts.event.REMOVE, [node]);\n          }\n        },\n        selectNode: function selectNode(node, isSilent) {\n          if (!node) return;\n          var parent = node[setting.data.key.parent];\n          var Z = parent ? parent[setting.treeId] : null;\n          parent = Z ? data.getNodeCache(setting, Z.tId) : null;\n\n          if (parent) {\n            view.expandCollapseParentNode(setting, parent, true, false, showNodeFocus);\n            parent = null;\n          } else if (!isSilent) {\n            try {\n              $$(node, setting).focus().blur();\n            } catch (e) {}\n          }\n\n          view.selectNode(setting, node);\n\n          function showNodeFocus() {\n            if (isSilent) {\n              return;\n            }\n\n            var a = $$(node, setting).get(0);\n            view.scrollIntoView(setting, a);\n          }\n        },\n        transformTozTreeNodes: function transformTozTreeNodes(simpleNodes) {\n          return data.transformTozTreeFormat(setting, simpleNodes);\n        },\n        transformToArray: function transformToArray(nodes) {\n          return data.transformToArrayFormat(setting, nodes);\n        },\n        updateNodeName: function updateNodeName(node) {\n          var Z = node[setting.treeId];\n          Z && Z.dom && view.setNodeName(setting, node);\n          return !!(Z && Z.dom);\n        },\n        updateNodeIcon: function updateNodeIcon(node) {\n          var Z = node[setting.treeId];\n          Z && Z.dom && view.setNodeLineIcos(setting, node, Z);\n          return !!(Z && Z.dom);\n        },\n        updateNodeTitle: function updateNodeTitle(node) {\n          var Z = node[setting.treeId];\n          Z && Z.dom && view.setNodeTitle(setting, node);\n          return !!(Z && Z.dom);\n        },\n        updateNodeHide: function updateNodeHide(node) {\n          var Z = node[setting.treeId];\n          Z && Z.dom && view.setNodeHide(setting, node, Z);\n          return !!(Z && Z.dom);\n        },\n        updateNode: function updateNode(node) {\n          var Z = node[setting.treeId];\n\n          if (Z && Z.dom) {\n            view.setNodeLineIcos(setting, node, Z);\n            view.setNodeName(setting, node);\n            view.setNodeTitle(setting, node);\n            view.setNodeHide(setting, node, Z);\n          }\n\n          return !!(Z && Z.dom);\n        },\n        getA: function getA(node) {\n          return $$(node, consts.id.A, setting);\n        }\n      };\n      root.treeTools = zTreeTools;\n      data.setZTreeTools(setting, zTreeTools);\n      var children = root[setting.data.key.children];\n\n      if (children && children.length > 0) {\n        view.createNodes(setting, 0, children, null, -1);\n      } else if (setting.async.enable && setting.async.url && setting.async.url !== '') {\n        view.asyncNode(setting);\n      }\n\n      return zTreeTools;\n    }\n  };\n  var zt = _$.fn.zTree,\n      $$ = tools.$,\n      consts = zt.consts;\n})(jQuery);",null]}