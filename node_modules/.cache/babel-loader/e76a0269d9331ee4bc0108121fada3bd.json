{"remainingRequest":"D:\\cdRule\\node_modules\\thread-loader\\dist\\cjs.js!D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js!D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js!D:\\cdRule\\src\\components\\Table\\export\\src\\mixin.js","dependencies":[{"path":"D:\\cdRule\\src\\components\\Table\\export\\src\\mixin.js","mtime":1635230120954},{"path":"D:\\cdRule\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\thread-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.regexp.split\";\nimport \"core-js/modules/es6.regexp.replace\";\nimport \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.regexp.split\";\nimport \"core-js/modules/es6.regexp.replace\";\nimport \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/web.dom.iterable\";\nimport XEUtils from 'xe-utils';\nimport GlobalConfig from '../../v-x-e-table/src/conf';\nimport VXETable from '../../v-x-e-table';\nimport { UtilTools } from '../../tools';\nimport { mergeBodyMethod } from '../../table/src/util';\nimport { browse } from '../../tools/src/dom';\nconst formatText = UtilTools.formatText; // 默认导出或打印的 HTML 样式\n\nconst defaultHtmlStyle = 'body{margin:0;color:#333333;font-size:14px;font-family:\"Microsoft YaHei\",微软雅黑,\"MicrosoftJhengHei\",华文细黑,STHeiti,MingLiu}body *{-webkit-box-sizing:border-box;box-sizing:border-box}.vxe-table{border-collapse:collapse;text-align:left;border-spacing:0}.vxe-table:not(.is--print){table-layout:fixed}.vxe-table,.vxe-table th,.vxe-table td,.vxe-table td{border-color:#D0D0D0;border-style:solid;border-width:0}.vxe-table.is--print{width:100%}.border--default,.border--full,.border--outer{border-top-width:1px}.border--default,.border--full,.border--outer{border-left-width:1px}.border--outer,.border--default th,.border--default td,.border--full th,.border--full td,.border--outer th,.border--inner th,.border--inner td{border-bottom-width:1px}.border--default,.border--outer,.border--full th,.border--full td{border-right-width:1px}.border--default th,.border--full th,.border--outer th{background-color:#f8f8f9}.vxe-table td>div,.vxe-table th>div{padding:.5em .4em}.col--center{text-align:center}.col--right{text-align:right}.vxe-table:not(.is--print) .col--ellipsis>div{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;word-break:break-all}.vxe-table--tree-node{text-align:left}.vxe-table--tree-node-wrapper{position:relative}.vxe-table--tree-icon-wrapper{position:absolute;top:50%;width:1em;height:1em;text-align:center;-webkit-transform:translateY(-50%);transform:translateY(-50%);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer}.vxe-table--tree-unfold-icon,.vxe-table--tree-fold-icon{position:absolute;width:0;height:0;border-style:solid;border-width:.5em;border-right-color:transparent;border-bottom-color:transparent}.vxe-table--tree-unfold-icon{left:.3em;top:0;border-left-color:#939599;border-top-color:transparent}.vxe-table--tree-fold-icon{left:0;top:.3em;border-left-color:transparent;border-top-color:#939599}.vxe-table--tree-cell{display:block;padding-left:1.5em}.vxe-table input[type=\"checkbox\"]{margin:0}.vxe-table input[type=\"checkbox\"],.vxe-table input[type=\"radio\"],.vxe-table input[type=\"checkbox\"]+span,.vxe-table input[type=\"radio\"]+span{vertical-align:middle;padding-left:0.4em}';\nlet htmlCellElem; // 导入\n\nlet fileForm;\nlet fileInput; // 打印\n\nlet printFrame;\nconst csvBOM = '\\ufeff';\nconst enterSymbol = '\\r\\n';\n\nfunction createFrame() {\n  const frame = document.createElement('iframe');\n  frame.className = 'vxe-table--print-frame';\n  return frame;\n}\n\nfunction getExportBlobByContent(content, options) {\n  if (window.Blob) {\n    return new Blob([content], {\n      type: `text/${options.type}`\n    });\n  }\n\n  return null;\n}\n\nfunction hasTreeChildren($xetable, row) {\n  const treeOpts = $xetable.treeOpts;\n  return row[treeOpts.children] && row[treeOpts.children].length > 0;\n}\n\nfunction getSeq($xetable, row, rowIndex, column, columnIndex) {\n  const seqOpts = $xetable.seqOpts;\n  const seqMethod = seqOpts.seqMethod || column.seqMethod;\n  return seqMethod ? seqMethod({\n    row,\n    rowIndex,\n    column,\n    columnIndex\n  }) : seqOpts.startIndex + rowIndex + 1;\n}\n\nfunction defaultFilterExportColumn(column) {\n  return column.property || ['seq', 'index', 'checkbox', 'radio'].indexOf(column.type) > -1;\n}\n\nfunction toTableBorder(border) {\n  if (border === true) {\n    return 'full';\n  }\n\n  if (border) {\n    return border;\n  }\n\n  return 'default';\n}\n\nfunction toBooleanValue(cellValue) {\n  return XEUtils.isBoolean(cellValue) ? cellValue ? 'TRUE' : 'FALSE' : cellValue;\n}\n\nfunction getLabelData($xetable, opts, columns, datas) {\n  const isAllExpand = opts.isAllExpand;\n  const treeConfig = $xetable.treeConfig,\n        treeOpts = $xetable.treeOpts,\n        radioOpts = $xetable.radioOpts,\n        checkboxOpts = $xetable.checkboxOpts;\n\n  if (!htmlCellElem) {\n    htmlCellElem = document.createElement('div');\n  }\n\n  if (treeConfig) {\n    // 如果是树表格只允许导出数据源\n    const rest = [];\n    XEUtils.eachTree(datas, (item, rowIndex, items, path, parent, nodes) => {\n      const row = item._row || item;\n      const parentRow = parent && parent._row ? parent._row : parent;\n\n      if (isAllExpand || !parentRow || $xetable.isTreeExpandByRow(parentRow)) {\n        const hasRowChild = hasTreeChildren($xetable, row);\n        const item = {\n          _row: row,\n          _level: nodes.length - 1,\n          _hasChild: hasRowChild,\n          _expand: hasRowChild && $xetable.isTreeExpandByRow(row)\n        };\n        columns.forEach((column, columnIndex) => {\n          let cellValue = '';\n          const renderOpts = column.editRender || column.cellRender;\n          let exportLabelMethod = column.exportMethod;\n\n          if (!exportLabelMethod && renderOpts && renderOpts.name) {\n            const compConf = VXETable.renderer.get(renderOpts.name);\n\n            if (compConf) {\n              exportLabelMethod = compConf.exportMethod || compConf.cellExportMethod;\n            }\n          }\n\n          if (exportLabelMethod) {\n            cellValue = exportLabelMethod({\n              $table: $xetable,\n              row,\n              column,\n              options: opts\n            });\n          } else {\n            switch (column.type) {\n              case 'index':\n              case 'seq':\n                cellValue = getSeq($xetable, row, rowIndex, column, columnIndex);\n                break;\n\n              case 'checkbox':\n                cellValue = toBooleanValue($xetable.isCheckedByCheckboxRow(row));\n                item._checkboxLabel = checkboxOpts.labelField ? XEUtils.get(row, checkboxOpts.labelField) : '';\n                item._checkboxDisabled = checkboxOpts.checkMethod && !checkboxOpts.checkMethod({\n                  row\n                });\n                break;\n\n              case 'radio':\n                cellValue = toBooleanValue($xetable.isCheckedByRadioRow(row));\n                item._radioLabel = radioOpts.labelField ? XEUtils.get(row, radioOpts.labelField) : '';\n                item._radioDisabled = radioOpts.checkMethod && !radioOpts.checkMethod({\n                  row\n                });\n                break;\n\n              default:\n                if (opts.original) {\n                  cellValue = UtilTools.getCellValue(row, column);\n                } else {\n                  cellValue = $xetable.getCellLabel(row, column);\n\n                  if (column.type === 'html') {\n                    htmlCellElem.innerHTML = cellValue;\n                    cellValue = htmlCellElem.innerText.trim();\n                  } else {\n                    const cell = $xetable.getCell(row, column);\n\n                    if (cell) {\n                      cellValue = cell.innerText.trim();\n                    }\n                  }\n                }\n\n            }\n          }\n\n          item[column.id] = XEUtils.toString(cellValue);\n        });\n        rest.push(Object.assign(item, row));\n      }\n    }, treeOpts);\n    return rest;\n  }\n\n  return datas.map((row, rowIndex) => {\n    const item = {\n      _row: row\n    };\n    columns.forEach((column, columnIndex) => {\n      let cellValue = '';\n      const renderOpts = column.editRender || column.cellRender;\n      let exportLabelMethod = column.exportMethod;\n\n      if (!exportLabelMethod && renderOpts && renderOpts.name) {\n        const compConf = VXETable.renderer.get(renderOpts.name);\n\n        if (compConf) {\n          exportLabelMethod = compConf.exportMethod || compConf.cellExportMethod;\n        }\n      }\n\n      if (exportLabelMethod) {\n        cellValue = exportLabelMethod({\n          $table: $xetable,\n          row,\n          column,\n          options: opts\n        });\n      } else {\n        switch (column.type) {\n          case 'index':\n          case 'seq':\n            cellValue = getSeq($xetable, row, rowIndex, column, columnIndex);\n            break;\n\n          case 'checkbox':\n            cellValue = toBooleanValue($xetable.isCheckedByCheckboxRow(row));\n            item._checkboxLabel = checkboxOpts.labelField ? XEUtils.get(row, checkboxOpts.labelField) : '';\n            item._checkboxDisabled = checkboxOpts.checkMethod && !checkboxOpts.checkMethod({\n              row\n            });\n            break;\n\n          case 'radio':\n            cellValue = toBooleanValue($xetable.isCheckedByRadioRow(row));\n            item._radioLabel = radioOpts.labelField ? XEUtils.get(row, radioOpts.labelField) : '';\n            item._radioDisabled = radioOpts.checkMethod && !radioOpts.checkMethod({\n              row\n            });\n            break;\n\n          default:\n            if (opts.original) {\n              cellValue = UtilTools.getCellValue(row, column);\n            } else {\n              cellValue = $xetable.getCellLabel(row, column);\n\n              if (column.type === 'html') {\n                htmlCellElem.innerHTML = cellValue;\n                cellValue = htmlCellElem.innerText.trim();\n              } else {\n                const cell = $xetable.getCell(row, column);\n\n                if (cell) {\n                  cellValue = cell.innerText.trim();\n                }\n              }\n            }\n\n        }\n      }\n\n      item[column.id] = XEUtils.toString(cellValue);\n    });\n    return item;\n  });\n}\n\nfunction getExportData($xetable, opts) {\n  const columns = opts.columns,\n        dataFilterMethod = opts.dataFilterMethod;\n  let datas = opts.data;\n\n  if (dataFilterMethod) {\n    datas = datas.filter((row, index) => dataFilterMethod({\n      row,\n      $rowIndex: index\n    }));\n  }\n\n  return getLabelData($xetable, opts, columns, datas);\n}\n\nfunction getBooleanValue(cellValue) {\n  return cellValue === 'TRUE' || cellValue === 'true' || cellValue === true;\n}\n\nfunction getHeaderTitle(opts, column) {\n  return (opts.original ? column.property : column.getTitle()) || '';\n}\n\nfunction getFooterCellValue($xetable, opts, items, column) {\n  const renderOpts = column.editRender || column.cellRender;\n  let exportLabelMethod = column.footerExportMethod;\n\n  if (!exportLabelMethod && renderOpts && renderOpts.name) {\n    const compConf = VXETable.renderer.get(renderOpts.name);\n\n    if (compConf) {\n      exportLabelMethod = compConf.footerExportMethod || compConf.footerCellExportMethod;\n    }\n  }\n\n  const _columnIndex = $xetable.getVTColumnIndex(column);\n\n  const cellValue = exportLabelMethod ? exportLabelMethod({\n    $table: $xetable,\n    items,\n    itemIndex: _columnIndex,\n    _columnIndex,\n    column,\n    options: opts\n  }) : XEUtils.toString(items[_columnIndex]);\n  return cellValue;\n}\n\nfunction getFooterData(opts, footerTableData) {\n  const footerFilterMethod = opts.footerFilterMethod;\n  return footerFilterMethod ? footerTableData.filter((items, index) => footerFilterMethod({\n    items,\n    $rowIndex: index\n  })) : footerTableData;\n}\n\nfunction getCsvCellTypeLabel(column, cellValue) {\n  if (cellValue) {\n    switch (column.cellType) {\n      case 'string':\n        if (!isNaN(cellValue)) {\n          return `\\t${cellValue}`;\n        }\n\n        break;\n\n      case 'number':\n        break;\n\n      default:\n        if (cellValue.length >= 12 && !isNaN(cellValue)) {\n          return `\\t${cellValue}`;\n        }\n\n        break;\n    }\n  }\n\n  return cellValue;\n}\n\nfunction toTxtCellLabel(val) {\n  if (/[\",\\s\\n]/.test(val)) {\n    return `\"${val.replace(/\"/g, '\"\"')}\"`;\n  }\n\n  return val;\n}\n\nfunction toCsv($xetable, opts, columns, datas) {\n  let content = csvBOM;\n\n  if (opts.isHeader) {\n    content += columns.map(column => toTxtCellLabel(getHeaderTitle(opts, column))).join(',') + enterSymbol;\n  }\n\n  datas.forEach(row => {\n    content += columns.map(column => toTxtCellLabel(getCsvCellTypeLabel(column, row[column.id]))).join(',') + enterSymbol;\n  });\n\n  if (opts.isFooter) {\n    const footerTableData = $xetable.footerTableData;\n    const footers = getFooterData(opts, footerTableData);\n    footers.forEach(rows => {\n      content += columns.map(column => toTxtCellLabel(getFooterCellValue($xetable, opts, rows, column))).join(',') + enterSymbol;\n    });\n  }\n\n  return content;\n}\n\nfunction toTxt($xetable, opts, columns, datas) {\n  let content = '';\n\n  if (opts.isHeader) {\n    content += columns.map(column => toTxtCellLabel(getHeaderTitle(opts, column))).join('\\t') + enterSymbol;\n  }\n\n  datas.forEach(row => {\n    content += columns.map(column => toTxtCellLabel(row[column.id])).join('\\t') + enterSymbol;\n  });\n\n  if (opts.isFooter) {\n    const footerTableData = $xetable.footerTableData;\n    const footers = getFooterData(opts, footerTableData);\n    footers.forEach(rows => {\n      content += columns.map(column => toTxtCellLabel(getFooterCellValue($xetable, opts, rows, column))).join(',') + enterSymbol;\n    });\n  }\n\n  return content;\n}\n\nfunction hasEllipsis($xetable, column, property, allColumnOverflow) {\n  const columnOverflow = column[property];\n  const headOverflow = XEUtils.isUndefined(columnOverflow) || XEUtils.isNull(columnOverflow) ? allColumnOverflow : columnOverflow;\n  const showEllipsis = headOverflow === 'ellipsis';\n  const showTitle = headOverflow === 'title';\n  const showTooltip = headOverflow === true || headOverflow === 'tooltip';\n  let isEllipsis = showTitle || showTooltip || showEllipsis; // 虚拟滚动不支持动态高度\n\n  if (($xetable.scrollXLoad || $xetable.scrollYLoad) && !isEllipsis) {\n    isEllipsis = true;\n  }\n\n  return isEllipsis;\n}\n\nfunction createHtmlPage(opts, content) {\n  const style = opts.style;\n  return ['<!DOCTYPE html><html>', '<head>', '<meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,minimal-ui\">', `<title>${opts.sheetName}</title>`, `<style>${defaultHtmlStyle}</style>`, style ? `<style>${style}</style>` : '', '</head>', `<body>${content}</body>`, '</html>'].join('');\n}\n\nfunction toHtml($xetable, opts, columns, datas) {\n  const id = $xetable.id,\n        border = $xetable.border,\n        treeConfig = $xetable.treeConfig,\n        treeOpts = $xetable.treeOpts,\n        isAllSelected = $xetable.isAllSelected,\n        isIndeterminate = $xetable.isIndeterminate,\n        allHeaderAlign = $xetable.headerAlign,\n        allAlign = $xetable.align,\n        allFooterAlign = $xetable.footerAlign,\n        allColumnOverflow = $xetable.showOverflow,\n        allColumnHeaderOverflow = $xetable.showHeaderOverflow,\n        mergeList = $xetable.mergeList;\n  const isPrint = opts.print,\n        isHeader = opts.isHeader,\n        isFooter = opts.isFooter,\n        isColgroup = opts.isColgroup,\n        isMerge = opts.isMerge,\n        colgroups = opts.colgroups,\n        original = opts.original;\n  const allCls = 'check-all';\n  const clss = ['vxe-table', `border--${toTableBorder(border)}`, isPrint ? 'is--print' : '', isHeader ? 'is--header' : ''].filter(cls => cls);\n  const tables = [`<table class=\"${clss.join(' ')}\" border=\"0\" cellspacing=\"0\" cellpadding=\"0\">`, `<colgroup>${columns.map(column => `<col style=\"width:${column.renderWidth}px\">`).join('')}</colgroup>`];\n\n  if (isHeader) {\n    tables.push('<thead>');\n\n    if (isColgroup && !original) {\n      colgroups.forEach(cols => {\n        tables.push(`<tr>${cols.map(column => {\n          const headAlign = column.headerAlign || column.align || allHeaderAlign || allAlign;\n          const classNames = hasEllipsis($xetable, column, 'showHeaderOverflow', allColumnHeaderOverflow) ? ['col--ellipsis'] : [];\n          const cellTitle = getHeaderTitle(opts, column);\n          let childWidth = 0;\n          let countChild = 0;\n          XEUtils.eachTree([column], item => {\n            if (!item.childNodes || !column.childNodes.length) {\n              countChild++;\n            }\n\n            childWidth += item.renderWidth;\n          }, {\n            children: 'childNodes'\n          });\n          const cellWidth = childWidth - countChild;\n\n          if (headAlign) {\n            classNames.push(`col--${headAlign}`);\n          }\n\n          if (column.type === 'checkbox') {\n            return `<th class=\"${classNames.join(' ')}\" colspan=\"${column._colSpan}\" rowspan=\"${column._rowSpan}\"><div ${isPrint ? '' : `style=\"width: ${cellWidth}px\"`}><input type=\"checkbox\" class=\"${allCls}\" ${isAllSelected ? 'checked' : ''}><span>${cellTitle}</span></div></th>`;\n          }\n\n          return `<th class=\"${classNames.join(' ')}\" colspan=\"${column._colSpan}\" rowspan=\"${column._rowSpan}\" title=\"${cellTitle}\"><div ${isPrint ? '' : `style=\"width: ${cellWidth}px\"`}><span>${formatText(cellTitle, true)}</span></div></th>`;\n        }).join('')}</tr>`);\n      });\n    } else {\n      tables.push(`<tr>${columns.map(column => {\n        const headAlign = column.headerAlign || column.align || allHeaderAlign || allAlign;\n        const classNames = hasEllipsis($xetable, column, 'showHeaderOverflow', allColumnHeaderOverflow) ? ['col--ellipsis'] : [];\n        const cellTitle = getHeaderTitle(opts, column);\n\n        if (headAlign) {\n          classNames.push(`col--${headAlign}`);\n        }\n\n        if (column.type === 'checkbox') {\n          return `<th class=\"${classNames.join(' ')}\"><div ${isPrint ? '' : `style=\"width: ${column.renderWidth}px\"`}><input type=\"checkbox\" class=\"${allCls}\" ${isAllSelected ? 'checked' : ''}><span>${cellTitle}</span></div></th>`;\n        }\n\n        return `<th class=\"${classNames.join(' ')}\" title=\"${cellTitle}\"><div ${isPrint ? '' : `style=\"width: ${column.renderWidth}px\"`}><span>${formatText(cellTitle, true)}</span></div></th>`;\n      }).join('')}</tr>`);\n    }\n\n    tables.push('</thead>');\n  }\n\n  if (datas.length) {\n    tables.push('<tbody>');\n\n    if (treeConfig) {\n      datas.forEach(item => {\n        tables.push('<tr>' + columns.map(column => {\n          const cellAlign = column.align || allAlign;\n          const classNames = hasEllipsis($xetable, column, 'showOverflow', allColumnOverflow) ? ['col--ellipsis'] : [];\n          const cellValue = item[column.id];\n\n          if (cellAlign) {\n            classNames.push(`col--${cellAlign}`);\n          }\n\n          if (column.treeNode) {\n            let treeIcon = '';\n\n            if (item._hasChild) {\n              treeIcon = `<i class=\"${item._expand ? 'vxe-table--tree-fold-icon' : 'vxe-table--tree-unfold-icon'}\"></i>`;\n            }\n\n            classNames.push('vxe-table--tree-node');\n\n            if (column.type === 'radio') {\n              return `<td class=\"${classNames.join(' ')}\" title=\"${cellValue}\"><div ${isPrint ? '' : `style=\"width: ${column.renderWidth}px\"`}><div class=\"vxe-table--tree-node-wrapper\" style=\"padding-left: ${item._level * treeOpts.indent}px\"><div class=\"vxe-table--tree-icon-wrapper\">${treeIcon}</div><div class=\"vxe-table--tree-cell\"><input type=\"radio\" name=\"radio_${id}\" ${item._radioDisabled ? 'disabled ' : ''}${getBooleanValue(cellValue) ? 'checked' : ''}><span>${item._radioLabel}</span></div></div></div></td>`;\n            } else if (column.type === 'checkbox') {\n              return `<td class=\"${classNames.join(' ')}\" title=\"${cellValue}\"><div ${isPrint ? '' : `style=\"width: ${column.renderWidth}px\"`}><div class=\"vxe-table--tree-node-wrapper\" style=\"padding-left: ${item._level * treeOpts.indent}px\"><div class=\"vxe-table--tree-icon-wrapper\">${treeIcon}</div><div class=\"vxe-table--tree-cell\"><input type=\"checkbox\" ${item._checkboxDisabled ? 'disabled ' : ''}${getBooleanValue(cellValue) ? 'checked' : ''}><span>${item._checkboxLabel}</span></div></div></div></td>`;\n            }\n\n            return `<td class=\"${classNames.join(' ')}\" title=\"${cellValue}\"><div ${isPrint ? '' : `style=\"width: ${column.renderWidth}px\"`}><div class=\"vxe-table--tree-node-wrapper\" style=\"padding-left: ${item._level * treeOpts.indent}px\"><div class=\"vxe-table--tree-icon-wrapper\">${treeIcon}</div><div class=\"vxe-table--tree-cell\">${cellValue}</div></div></div></td>`;\n          }\n\n          if (column.type === 'radio') {\n            return `<td class=\"${classNames.join(' ')}\"><div ${isPrint ? '' : `style=\"width: ${column.renderWidth}px\"`}><input type=\"radio\" name=\"radio_${id}\" ${item._radioDisabled ? 'disabled ' : ''}${getBooleanValue(cellValue) ? 'checked' : ''}><span>${item._radioLabel}</span></div></td>`;\n          } else if (column.type === 'checkbox') {\n            return `<td class=\"${classNames.join(' ')}\"><div ${isPrint ? '' : `style=\"width: ${column.renderWidth}px\"`}><input type=\"checkbox\" ${item._checkboxDisabled ? 'disabled ' : ''}${getBooleanValue(cellValue) ? 'checked' : ''}><span>${item._checkboxLabel}</span></div></td>`;\n          }\n\n          return `<td class=\"${classNames.join(' ')}\" title=\"${cellValue}\"><div ${isPrint ? '' : `style=\"width: ${column.renderWidth}px\"`}>${formatText(cellValue, true)}</div></td>`;\n        }).join('') + '</tr>');\n      });\n    } else {\n      datas.forEach(item => {\n        tables.push('<tr>' + columns.map(column => {\n          const cellAlign = column.align || allAlign;\n          const classNames = hasEllipsis($xetable, column, 'showOverflow', allColumnOverflow) ? ['col--ellipsis'] : [];\n          const cellValue = item[column.id];\n          let rowSpan = 1;\n          let colSpan = 1;\n\n          if (isMerge && mergeList.length) {\n            const _rowIndex = $xetable.getVTRowIndex(item._row);\n\n            const _columnIndex = $xetable.getVTColumnIndex(column);\n\n            const spanRest = mergeBodyMethod(mergeList, _rowIndex, _columnIndex);\n\n            if (spanRest) {\n              const rowspan = spanRest.rowspan,\n                    colspan = spanRest.colspan;\n\n              if (!rowspan || !colspan) {\n                return '';\n              }\n\n              if (rowspan > 1) {\n                rowSpan = rowspan;\n              }\n\n              if (colspan > 1) {\n                colSpan = colspan;\n              }\n            }\n          }\n\n          if (cellAlign) {\n            classNames.push(`col--${cellAlign}`);\n          }\n\n          if (column.type === 'radio') {\n            return `<td class=\"${classNames.join(' ')}\" rowspan=\"${rowSpan}\" colspan=\"${colSpan}\"><div ${isPrint ? '' : `style=\"width: ${column.renderWidth}px\"`}><input type=\"radio\" name=\"radio_${id}\" ${item._radioDisabled ? 'disabled ' : ''}${getBooleanValue(cellValue) ? 'checked' : ''}><span>${item._radioLabel}</span></div></td>`;\n          } else if (column.type === 'checkbox') {\n            return `<td class=\"${classNames.join(' ')}\" rowspan=\"${rowSpan}\" colspan=\"${colSpan}\"><div ${isPrint ? '' : `style=\"width: ${column.renderWidth}px\"`}><input type=\"checkbox\" ${item._checkboxDisabled ? 'disabled ' : ''}${getBooleanValue(cellValue) ? 'checked' : ''}><span>${item._checkboxLabel}</span></div></td>`;\n          }\n\n          return `<td class=\"${classNames.join(' ')}\" rowspan=\"${rowSpan}\" colspan=\"${colSpan}\" title=\"${cellValue}\"><div ${isPrint ? '' : `style=\"width: ${column.renderWidth}px\"`}>${formatText(cellValue, true)}</div></td>`;\n        }).join('') + '</tr>');\n      });\n    }\n\n    tables.push('</tbody>');\n  }\n\n  if (isFooter) {\n    const footerTableData = $xetable.footerTableData;\n    const footers = getFooterData(opts, footerTableData);\n\n    if (footers.length) {\n      tables.push('<tfoot>');\n      footers.forEach(rows => {\n        tables.push(`<tr>${columns.map(column => {\n          const footAlign = column.footerAlign || column.align || allFooterAlign || allAlign;\n          const classNames = hasEllipsis($xetable, column, 'showOverflow', allColumnOverflow) ? ['col--ellipsis'] : [];\n          const cellValue = getFooterCellValue($xetable, opts, rows, column);\n\n          if (footAlign) {\n            classNames.push(`col--${footAlign}`);\n          }\n\n          return `<td class=\"${classNames.join(' ')}\" title=\"${cellValue}\"><div ${isPrint ? '' : `style=\"width: ${column.renderWidth}px\"`}>${formatText(cellValue, true)}</div></td>`;\n        }).join('')}</tr>`);\n      });\n      tables.push('</tfoot>');\n    }\n  } // 是否半选状态\n\n\n  const script = !isAllSelected && isIndeterminate ? `<script>(function(){var a=document.querySelector(\".${allCls}\");if(a){a.indeterminate=true}})()</script>` : '';\n  tables.push('</table>', script);\n  return isPrint ? tables.join('') : createHtmlPage(opts, tables.join(''));\n}\n\nfunction toXML($xetable, opts, columns, datas) {\n  let xml = ['<?xml version=\"1.0\"?>', '<?mso-application progid=\"Excel.Sheet\"?>', '<Workbook xmlns=\"urn:schemas-microsoft-com:office:spreadsheet\" xmlns:o=\"urn:schemas-microsoft-com:office:office\" xmlns:x=\"urn:schemas-microsoft-com:office:excel\" xmlns:ss=\"urn:schemas-microsoft-com:office:spreadsheet\" xmlns:html=\"http://www.w3.org/TR/REC-html40\">', '<DocumentProperties xmlns=\"urn:schemas-microsoft-com:office:office\">', '<Version>16.00</Version>', '</DocumentProperties>', '<ExcelWorkbook xmlns=\"urn:schemas-microsoft-com:office:excel\">', '<WindowHeight>7920</WindowHeight>', '<WindowWidth>21570</WindowWidth>', '<WindowTopX>32767</WindowTopX>', '<WindowTopY>32767</WindowTopY>', '<ProtectStructure>False</ProtectStructure>', '<ProtectWindows>False</ProtectWindows>', '</ExcelWorkbook>', `<Worksheet ss:Name=\"${opts.sheetName}\">`, '<Table>', columns.map(column => `<Column ss:Width=\"${column.renderWidth}\"/>`).join('')].join('');\n\n  if (opts.isHeader) {\n    xml += `<Row>${columns.map(column => `<Cell><Data ss:Type=\"String\">${getHeaderTitle(opts, column)}</Data></Cell>`).join('')}</Row>`;\n  }\n\n  datas.forEach(row => {\n    xml += '<Row>' + columns.map(column => `<Cell><Data ss:Type=\"String\">${row[column.id]}</Data></Cell>`).join('') + '</Row>';\n  });\n\n  if (opts.isFooter) {\n    const footerTableData = $xetable.footerTableData;\n    const footers = getFooterData(opts, footerTableData);\n    footers.forEach(rows => {\n      xml += `<Row>${columns.map(column => `<Cell><Data ss:Type=\"String\">${getFooterCellValue($xetable, opts, rows, column)}</Data></Cell>`).join('')}</Row>`;\n    });\n  }\n\n  return `${xml}</Table></Worksheet></Workbook>`;\n}\n\nfunction getContent($xetable, opts, columns, datas) {\n  if (columns.length) {\n    switch (opts.type) {\n      case 'csv':\n        return toCsv($xetable, opts, columns, datas);\n\n      case 'txt':\n        return toTxt($xetable, opts, columns, datas);\n\n      case 'html':\n        return toHtml($xetable, opts, columns, datas);\n\n      case 'xml':\n        return toXML($xetable, opts, columns, datas);\n    }\n  }\n\n  return '';\n}\n/**\r\n * 保存文件到本地\r\n * @param {*} options 参数\r\n */\n\n\nexport function saveLocalFile(options) {\n  const filename = options.filename,\n        type = options.type,\n        content = options.content;\n  const name = `${filename}.${type}`;\n\n  if (window.Blob) {\n    const blob = content instanceof Blob ? content : getExportBlobByContent(XEUtils.toString(content), options);\n\n    if (navigator.msSaveBlob) {\n      navigator.msSaveBlob(blob, name);\n    } else {\n      const linkElem = document.createElement('a');\n      linkElem.target = '_blank';\n      linkElem.download = name;\n      linkElem.href = URL.createObjectURL(blob);\n      document.body.appendChild(linkElem);\n      linkElem.click();\n      document.body.removeChild(linkElem);\n    }\n\n    return Promise.resolve();\n  }\n\n  return Promise.reject(new Error(UtilTools.getLog('vxe.error.notExp')));\n}\n\nfunction downloadFile($xetable, opts, content) {\n  const filename = opts.filename,\n        type = opts.type,\n        download = opts.download;\n\n  if (!download) {\n    const blob = getExportBlobByContent(content, opts);\n    return Promise.resolve({\n      type,\n      content,\n      blob\n    });\n  }\n\n  saveLocalFile({\n    filename,\n    type,\n    content\n  }).then(() => {\n    if (opts.message !== false) {\n      VXETable.modal.message({\n        content: GlobalConfig.i18n('vxe.table.expSuccess'),\n        status: 'success'\n      });\n    }\n  });\n}\n\nfunction clearColumnConvert(columns) {\n  XEUtils.eachTree(columns, column => {\n    delete column._level;\n    delete column._colSpan;\n    delete column._rowSpan;\n    delete column._children;\n    delete column.childNodes;\n  }, {\n    children: 'children'\n  });\n}\n\nfunction handleExport($xetable, opts) {\n  const remote = opts.remote,\n        columns = opts.columns,\n        colgroups = opts.colgroups,\n        exportMethod = opts.exportMethod,\n        afterExportMethod = opts.afterExportMethod;\n  return new Promise(resolve => {\n    if (remote) {\n      const params = {\n        options: opts,\n        $table: $xetable,\n        $grid: $xetable.$xegrid\n      };\n      resolve(exportMethod ? exportMethod(params) : params);\n    } else {\n      const datas = getExportData($xetable, opts);\n      resolve($xetable.preventEvent(null, 'event.export', {\n        options: opts,\n        columns,\n        colgroups,\n        datas\n      }, () => {\n        return downloadFile($xetable, opts, getContent($xetable, opts, columns, datas));\n      }));\n    }\n  }).then(params => {\n    clearColumnConvert(columns);\n\n    if (!opts.print) {\n      if (afterExportMethod) {\n        afterExportMethod({\n          status: true,\n          options: opts,\n          $table: $xetable,\n          $grid: $xetable.$xegrid\n        });\n      }\n    }\n\n    return Object.assign({\n      status: true\n    }, params);\n  }).catch(() => {\n    clearColumnConvert(columns);\n\n    if (!opts.print) {\n      if (afterExportMethod) {\n        afterExportMethod({\n          status: false,\n          options: opts,\n          $table: $xetable,\n          $grid: $xetable.$xegrid\n        });\n      }\n    }\n\n    const params = {\n      status: false\n    };\n    return Promise.reject(params);\n  });\n}\n\nfunction getElementsByTagName(elem, qualifiedName) {\n  return elem.getElementsByTagName(qualifiedName);\n}\n\nfunction getTxtCellKey(now) {\n  return `#${now}@${XEUtils.uniqueId()}`;\n}\n\nfunction replaceTxtCell(cell, vMaps) {\n  return cell.replace(/#\\d+@\\d+/g, key => XEUtils.hasOwnProp(vMaps, key) ? vMaps[key] : key);\n}\n\nfunction getTxtCellValue(val, vMaps) {\n  const rest = replaceTxtCell(val, vMaps);\n  return rest.replace(/^\"+$/g, qVal => '\"'.repeat(Math.ceil(qVal.length / 2)));\n}\n\nfunction parseCsvAndTxt(columns, content, cellSeparator) {\n  const list = content.split(enterSymbol);\n  const rows = [];\n  let fields = [];\n\n  if (list.length) {\n    const vMaps = {};\n    const now = Date.now();\n    list.forEach(rVal => {\n      if (rVal) {\n        const item = {};\n        rVal = rVal.replace(/(\"\")|(\\n)/g, (text, dVal) => {\n          const key = getTxtCellKey(now);\n          vMaps[key] = dVal ? '\"' : '\\n';\n          return key;\n        }).replace(/\"(.*?)\"/g, (text, cVal) => {\n          const key = getTxtCellKey(now);\n          vMaps[key] = replaceTxtCell(cVal, vMaps);\n          return key;\n        });\n        const cells = rVal.split(cellSeparator);\n\n        if (!fields.length) {\n          fields = cells.map(val => getTxtCellValue(val.trim(), vMaps));\n        } else {\n          cells.forEach((val, colIndex) => {\n            if (colIndex < fields.length) {\n              item[fields[colIndex]] = getTxtCellValue(val, vMaps);\n            }\n          });\n          rows.push(item);\n        }\n      }\n    });\n  }\n\n  return {\n    fields,\n    rows\n  };\n}\n\nfunction parseCsv(columns, content) {\n  return parseCsvAndTxt(columns, content, ',');\n}\n\nfunction parseTxt(columns, content) {\n  return parseCsvAndTxt(columns, content, '\\t');\n}\n\nfunction parseHTML(columns, content) {\n  const domParser = new DOMParser();\n  const xmlDoc = domParser.parseFromString(content, 'text/html');\n  const bodyNodes = getElementsByTagName(xmlDoc, 'body');\n  const rows = [];\n  const fields = [];\n\n  if (bodyNodes.length) {\n    const tableNodes = getElementsByTagName(bodyNodes[0], 'table');\n\n    if (tableNodes.length) {\n      const theadNodes = getElementsByTagName(tableNodes[0], 'thead');\n\n      if (theadNodes.length) {\n        XEUtils.arrayEach(getElementsByTagName(theadNodes[0], 'tr'), rowNode => {\n          XEUtils.arrayEach(getElementsByTagName(rowNode, 'th'), cellNode => {\n            fields.push(cellNode.textContent);\n          });\n        });\n        const tbodyNodes = getElementsByTagName(tableNodes[0], 'tbody');\n\n        if (tbodyNodes.length) {\n          XEUtils.arrayEach(getElementsByTagName(tbodyNodes[0], 'tr'), rowNode => {\n            const item = {};\n            XEUtils.arrayEach(getElementsByTagName(rowNode, 'td'), (cellNode, colIndex) => {\n              if (fields[colIndex]) {\n                item[fields[colIndex]] = cellNode.textContent || '';\n              }\n            });\n            rows.push(item);\n          });\n        }\n      }\n    }\n  }\n\n  return {\n    fields,\n    rows\n  };\n}\n\nfunction parseXML(columns, content) {\n  const domParser = new DOMParser();\n  const xmlDoc = domParser.parseFromString(content, 'application/xml');\n  const sheetNodes = getElementsByTagName(xmlDoc, 'Worksheet');\n  const rows = [];\n  const fields = [];\n\n  if (sheetNodes.length) {\n    const tableNodes = getElementsByTagName(sheetNodes[0], 'Table');\n\n    if (tableNodes.length) {\n      const rowNodes = getElementsByTagName(tableNodes[0], 'Row');\n\n      if (rowNodes.length) {\n        XEUtils.arrayEach(getElementsByTagName(rowNodes[0], 'Cell'), cellNode => {\n          fields.push(cellNode.textContent);\n        });\n        XEUtils.arrayEach(rowNodes, (rowNode, index) => {\n          if (index) {\n            const item = {};\n            const cellNodes = getElementsByTagName(rowNode, 'Cell');\n            XEUtils.arrayEach(cellNodes, (cellNode, colIndex) => {\n              if (fields[colIndex]) {\n                item[fields[colIndex]] = cellNode.textContent;\n              }\n            });\n            rows.push(item);\n          }\n        });\n      }\n    }\n  }\n\n  return {\n    fields,\n    rows\n  };\n}\n/**\r\n * 检查导入的列是否完整\r\n * @param {Array} fields 字段名列表\r\n * @param {Array} rows 数据列表\r\n */\n\n\nfunction checkImportData(columns, fields) {\n  const tableFields = [];\n  columns.forEach(column => {\n    const field = column.property;\n\n    if (field) {\n      tableFields.push(field);\n    }\n  });\n  return fields.some(field => tableFields.indexOf(field) > -1);\n}\n\nfunction handleImport($xetable, content, opts) {\n  const tableFullColumn = $xetable.tableFullColumn,\n        _importResolve = $xetable._importResolve,\n        _importReject = $xetable._importReject;\n  let rest = {\n    fields: [],\n    rows: []\n  };\n\n  switch (opts.type) {\n    case 'csv':\n      rest = parseCsv(tableFullColumn, content);\n      break;\n\n    case 'txt':\n      rest = parseTxt(tableFullColumn, content);\n      break;\n\n    case 'html':\n      rest = parseHTML(tableFullColumn, content);\n      break;\n\n    case 'xml':\n      rest = parseXML(tableFullColumn, content);\n      break;\n  }\n\n  const _rest = rest,\n        fields = _rest.fields,\n        rows = _rest.rows;\n  const status = checkImportData(tableFullColumn, fields);\n\n  if (status) {\n    $xetable.createData(rows).then(data => {\n      let loadRest;\n\n      if (opts.mode === 'insert') {\n        loadRest = $xetable.insert(data);\n      } else {\n        loadRest = $xetable.reloadData(data);\n      }\n\n      if (opts.message !== false) {\n        VXETable.modal.message({\n          content: GlobalConfig.i18n('vxe.table.impSuccess', [rows.length]),\n          status: 'success'\n        });\n      }\n\n      return loadRest.then(() => {\n        if (_importResolve) {\n          _importResolve({\n            status: true\n          });\n        }\n      });\n    });\n  } else if (opts.message !== false) {\n    VXETable.modal.message({\n      content: GlobalConfig.i18n('vxe.error.impFields'),\n      status: 'error'\n    });\n\n    if (_importReject) {\n      _importReject({\n        status: false\n      });\n    }\n  }\n}\n\nfunction handleFileImport($xetable, file, opts) {\n  const importMethod = opts.importMethod,\n        afterImportMethod = opts.afterImportMethod;\n\n  const _UtilTools$parseFile = UtilTools.parseFile(file),\n        type = _UtilTools$parseFile.type,\n        filename = _UtilTools$parseFile.filename; // 检查类型，如果为自定义导出，则不需要校验类型\n\n\n  if (!importMethod && !XEUtils.includes(VXETable.config.importTypes, type)) {\n    if (opts.message !== false) {\n      VXETable.modal.message({\n        content: GlobalConfig.i18n('vxe.error.notType', [type]),\n        status: 'error'\n      });\n    }\n\n    const params = {\n      status: false\n    };\n    return Promise.reject(params);\n  }\n\n  const rest = new Promise((resolve, reject) => {\n    const _importResolve = params => {\n      resolve(params);\n      $xetable._importResolve = null;\n      $xetable._importReject = null;\n    };\n\n    const _importReject = params => {\n      reject(params);\n      $xetable._importResolve = null;\n      $xetable._importReject = null;\n    };\n\n    $xetable._importResolve = _importResolve;\n    $xetable._importReject = _importReject;\n\n    if (window.FileReader) {\n      const options = Object.assign({\n        mode: 'insert'\n      }, opts, {\n        type,\n        filename\n      });\n\n      if (options.remote) {\n        if (importMethod) {\n          Promise.resolve(importMethod({\n            file,\n            options,\n            $table: $xetable\n          })).then(() => {\n            _importResolve({\n              status: true\n            });\n          }).catch(() => {\n            _importResolve({\n              status: true\n            });\n          });\n        } else {\n          _importResolve({\n            status: true\n          });\n        }\n      } else {\n        $xetable.preventEvent(null, 'event.import', {\n          file,\n          options,\n          columns: $xetable.tableFullColumn\n        }, () => {\n          const reader = new FileReader();\n\n          reader.onerror = () => {\n            UtilTools.error('vxe.error.notType', [type]);\n\n            _importReject({\n              status: false\n            });\n          };\n\n          reader.onload = e => {\n            handleImport($xetable, e.target.result, options);\n          };\n\n          reader.readAsText(file, 'UTF-8');\n        });\n      }\n    } else {\n      // 不支持的浏览器\n      if (process.env.VUE_APP_VXE_TABLE_ENV === 'development') {\n        UtilTools.error('vxe.error.notExp');\n      }\n\n      _importResolve({\n        status: true\n      });\n    }\n  });\n  return rest.then(() => {\n    if (afterImportMethod) {\n      afterImportMethod({\n        status: true,\n        options: opts,\n        $table: $xetable\n      });\n    }\n  }).catch(e => {\n    if (afterImportMethod) {\n      afterImportMethod({\n        status: false,\n        options: opts,\n        $table: $xetable\n      });\n    }\n\n    return Promise.reject(e);\n  });\n}\n/**\r\n * 读取本地文件\r\n * @param {*} options 参数\r\n */\n\n\nexport function readLocalFile() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (!fileForm) {\n    fileForm = document.createElement('form');\n    fileInput = document.createElement('input');\n    fileForm.className = 'vxe-table--file-form';\n    fileInput.name = 'file';\n    fileInput.type = 'file';\n    fileForm.appendChild(fileInput);\n    document.body.appendChild(fileForm);\n  }\n\n  return new Promise((resolve, reject) => {\n    const types = options.types || [];\n    const isAllType = !types.length || types.some(type => type === '*');\n    fileInput.multiple = !!options.multiple;\n    fileInput.accept = isAllType ? '' : `.${types.join(', .')}`;\n\n    fileInput.onchange = evnt => {\n      const files = evnt.target.files;\n      const file = files[0];\n      let errType; // 校验类型\n\n      if (!isAllType) {\n        for (let fIndex = 0; fIndex < files.length; fIndex++) {\n          const _UtilTools$parseFile2 = UtilTools.parseFile(files[fIndex]),\n                type = _UtilTools$parseFile2.type;\n\n          if (!XEUtils.includes(types, type)) {\n            errType = type;\n            break;\n          }\n        }\n      }\n\n      if (!errType) {\n        resolve({\n          status: true,\n          files,\n          file\n        });\n      } else {\n        if (options.message !== false) {\n          VXETable.modal.message({\n            content: GlobalConfig.i18n('vxe.error.notType', [errType]),\n            status: 'error'\n          });\n        }\n\n        const params = {\n          status: false,\n          files,\n          file\n        };\n        reject(params);\n      }\n    };\n\n    fileForm.reset();\n    fileInput.click();\n  });\n}\n\nfunction removePrintFrame() {\n  if (printFrame) {\n    if (printFrame.parentNode) {\n      try {\n        printFrame.contentDocument.write('');\n        printFrame.contentDocument.clear();\n      } catch (e) {}\n\n      printFrame.parentNode.removeChild(printFrame);\n    }\n\n    printFrame = null;\n  }\n}\n\nfunction appendPrintFrame() {\n  if (!printFrame.parentNode) {\n    document.body.appendChild(printFrame);\n  }\n}\n\nfunction afterPrintEvent() {\n  removePrintFrame();\n}\n\nexport function handlePrint($xetable, opts, content) {\n  const beforePrintMethod = opts.beforePrintMethod;\n\n  if (beforePrintMethod) {\n    content = beforePrintMethod({\n      content,\n      options: opts,\n      $table: $xetable\n    }) || '';\n  }\n\n  content = createHtmlPage(opts, content);\n  const blob = getExportBlobByContent(content, opts);\n\n  if (browse.msie) {\n    removePrintFrame();\n    printFrame = createFrame();\n    appendPrintFrame();\n    printFrame.contentDocument.write(content);\n    printFrame.contentDocument.execCommand('print');\n  } else {\n    if (!printFrame) {\n      printFrame = createFrame();\n\n      printFrame.onload = evnt => {\n        if (evnt.target.src) {\n          evnt.target.contentWindow.onafterprint = afterPrintEvent;\n          evnt.target.contentWindow.print();\n        }\n      };\n    }\n\n    appendPrintFrame();\n    printFrame.src = URL.createObjectURL(blob);\n  }\n}\n\nfunction handleExportAndPrint($xetable, options, isPrint) {\n  const initStore = $xetable.initStore,\n        customOpts = $xetable.customOpts,\n        collectColumn = $xetable.collectColumn,\n        footerTableData = $xetable.footerTableData,\n        treeConfig = $xetable.treeConfig,\n        mergeList = $xetable.mergeList,\n        isGroup = $xetable.isGroup,\n        exportParams = $xetable.exportParams;\n  const selectRecords = $xetable.getCheckboxRecords();\n  const hasFooter = !!footerTableData.length;\n  const hasTree = treeConfig;\n  const hasMerge = !hasTree && mergeList.length;\n  const defOpts = Object.assign({\n    message: true,\n    isHeader: true\n  }, options);\n  const types = defOpts.types || VXETable.config.exportTypes;\n  const modes = defOpts.modes;\n  const checkMethod = customOpts.checkMethod;\n  const exportColumns = collectColumn.slice(0);\n  const columns = defOpts.columns; // 处理类型\n\n  const typeList = types.map(value => {\n    return {\n      value,\n      label: `vxe.export.types.${value}`\n    };\n  });\n  const modeList = modes.map(value => {\n    return {\n      value,\n      label: `vxe.export.modes.${value}`\n    };\n  }); // 默认选中\n\n  XEUtils.eachTree(exportColumns, (column, index, items, path, parent) => {\n    const isColGroup = column.children && column.children.length;\n\n    if (isColGroup || defaultFilterExportColumn(column)) {\n      column.checked = columns ? columns.some(item => {\n        if (UtilTools.isColumn(item)) {\n          return column === item;\n        } else if (XEUtils.isString(item)) {\n          return column.field === item;\n        } else {\n          const colid = item.id || item.colId;\n          const type = item.type;\n          const field = item.property || item.field;\n\n          if (colid) {\n            return column.id === colid;\n          } else if (field && type) {\n            return column.property === field && column.type === type;\n          } else if (field) {\n            return column.property === field;\n          } else if (type) {\n            return column.type === type;\n          }\n        }\n      }) : column.visible;\n      column.halfChecked = false;\n      column.disabled = parent && parent.disabled || (checkMethod ? !checkMethod({\n        column\n      }) : false);\n    }\n  }); // 更新条件\n\n  Object.assign($xetable.exportStore, {\n    columns: exportColumns,\n    typeList,\n    modeList,\n    hasFooter,\n    hasMerge,\n    hasTree,\n    isPrint,\n    hasColgroup: isGroup,\n    visible: true\n  }); // 默认参数\n\n  if (!initStore.export) {\n    Object.assign(exportParams, {\n      mode: selectRecords.length ? 'selected' : 'current'\n    }, defOpts);\n  }\n\n  if (modes.indexOf(exportParams.mode) === -1) {\n    exportParams.mode = modes[0];\n  }\n\n  if (types.indexOf(exportParams.type) === -1) {\n    exportParams.type = types[0];\n  }\n\n  initStore.export = true;\n  return $xetable.$nextTick();\n}\n\nconst getConvertColumns = columns => {\n  const result = [];\n  columns.forEach(column => {\n    if (column.childNodes && column.childNodes.length) {\n      result.push(column);\n      result.push(...getConvertColumns(column.childNodes));\n    } else {\n      result.push(column);\n    }\n  });\n  return result;\n};\n\nconst convertToRows = originColumns => {\n  let maxLevel = 1;\n\n  const traverse = (column, parent) => {\n    if (parent) {\n      column._level = parent._level + 1;\n\n      if (maxLevel < column._level) {\n        maxLevel = column._level;\n      }\n    }\n\n    if (column.childNodes && column.childNodes.length) {\n      let colSpan = 0;\n      column.childNodes.forEach(subColumn => {\n        traverse(subColumn, column);\n        colSpan += subColumn._colSpan;\n      });\n      column._colSpan = colSpan;\n    } else {\n      column._colSpan = 1;\n    }\n  };\n\n  originColumns.forEach(column => {\n    column._level = 1;\n    traverse(column);\n  });\n  const rows = [];\n\n  for (let i = 0; i < maxLevel; i++) {\n    rows.push([]);\n  }\n\n  const allColumns = getConvertColumns(originColumns);\n  allColumns.forEach(column => {\n    if (column.childNodes && column.childNodes.length) {\n      column._rowSpan = 1;\n    } else {\n      column._rowSpan = maxLevel - column._level + 1;\n    }\n\n    rows[column._level - 1].push(column);\n  });\n  return rows;\n};\n\nexport default {\n  methods: {\n    /**\r\n     * 导出文件，支持 csv/html/xml/txt\r\n     * 如果是树表格，则默认是导出所有节点\r\n     * 如果是启用了虚拟滚动，则只能导出数据源，可以配合 dataFilterMethod 函数自行转换数据\r\n     * @param {Object} options 参数\r\n     */\n    _exportData(options) {\n      const $xegrid = this.$xegrid,\n            isGroup = this.isGroup,\n            tableGroupColumn = this.tableGroupColumn,\n            tableFullColumn = this.tableFullColumn,\n            afterFullData = this.afterFullData,\n            treeConfig = this.treeConfig,\n            treeOpts = this.treeOpts,\n            exportOpts = this.exportOpts;\n      const opts = Object.assign({\n        // filename: '',\n        // sheetName: '',\n        // original: false,\n        // message: false,\n        isHeader: true,\n        isFooter: true,\n        isColgroup: true,\n        isMerge: false,\n        isAllExpand: false,\n        download: true,\n        type: 'csv',\n        mode: 'current' // data: null,\n        // remote: false,\n        // dataFilterMethod: null,\n        // footerFilterMethod: null,\n        // exportMethod: null,\n        // columnFilterMethod: null,\n        // beforeExportMethod: null,\n        // afterExportMethod: null\n\n      }, exportOpts, {\n        print: false\n      }, options);\n      const type = opts.type,\n            mode = opts.mode,\n            columns = opts.columns,\n            original = opts.original,\n            beforeExportMethod = opts.beforeExportMethod;\n      let groups = [];\n      const customCols = columns && columns.length ? columns : null; // 如果设置源数据，则默认导出设置了字段的列\n\n      let columnFilterMethod = opts.columnFilterMethod;\n\n      if (!customCols && !columnFilterMethod) {\n        columnFilterMethod = original ? _ref => {\n          let column = _ref.column;\n          return column.property;\n        } : _ref2 => {\n          let column = _ref2.column;\n          return defaultFilterExportColumn(column);\n        };\n      }\n\n      if (customCols) {\n        groups = XEUtils.searchTree(XEUtils.mapTree(customCols, item => {\n          let targetColumn;\n\n          if (item) {\n            if (UtilTools.isColumn(item)) {\n              targetColumn = item;\n            } else if (XEUtils.isString(item)) {\n              targetColumn = this.getColumnByField(item);\n            } else {\n              const colid = item.id || item.colId;\n              const type = item.type;\n              const field = item.property || item.field;\n\n              if (colid) {\n                targetColumn = this.getColumnById(colid);\n              } else if (field && type) {\n                targetColumn = tableFullColumn.find(column => column.property === field && column.type === type);\n              } else if (field) {\n                targetColumn = this.getColumnByField(field);\n              } else if (type) {\n                targetColumn = tableFullColumn.find(column => column.type === type);\n              }\n            }\n\n            return targetColumn || {};\n          }\n        }, {\n          children: 'childNodes',\n          mapChildren: '_children'\n        }), (column, index) => UtilTools.isColumn(column) && (!columnFilterMethod || columnFilterMethod({\n          column,\n          $columnIndex: index\n        })), {\n          children: '_children',\n          mapChildren: 'childNodes',\n          original: true\n        });\n      } else {\n        groups = XEUtils.searchTree(isGroup ? tableGroupColumn : tableFullColumn, (column, index) => column.visible && (!columnFilterMethod || columnFilterMethod({\n          column,\n          $columnIndex: index\n        })), {\n          children: 'children',\n          mapChildren: 'childNodes',\n          original: true\n        });\n      } // 获取所有列\n\n\n      const cols = [];\n      XEUtils.eachTree(groups, column => {\n        const isColGroup = column.children && column.children.length;\n\n        if (!isColGroup) {\n          cols.push(column);\n        }\n      }, {\n        children: 'childNodes'\n      }); // 构建分组层级\n\n      opts.columns = cols;\n      opts.colgroups = convertToRows(groups);\n\n      if (!opts.filename) {\n        opts.filename = GlobalConfig.i18n(opts.original ? 'vxe.table.expOriginFilename' : 'vxe.table.expFilename', [XEUtils.toDateString(Date.now(), 'yyyyMMddHHmmss')]);\n      }\n\n      if (!opts.sheetName) {\n        opts.sheetName = document.title;\n      } // 检查类型，如果为自定义导出，则不需要校验类型\n\n\n      if (!opts.exportMethod && !XEUtils.includes(VXETable.config.exportTypes, type)) {\n        if (process.env.VUE_APP_VXE_TABLE_ENV === 'development') {\n          UtilTools.error('vxe.error.notType', [type]);\n        }\n\n        const params = {\n          status: false\n        };\n        return Promise.reject(params);\n      }\n\n      if (!opts.print) {\n        if (beforeExportMethod) {\n          beforeExportMethod({\n            options: opts,\n            $table: this,\n            $grid: $xegrid\n          });\n        }\n      }\n\n      if (!opts.data) {\n        opts.data = afterFullData;\n\n        if (mode === 'selected') {\n          const selectRecords = this.getCheckboxRecords();\n\n          if (['html', 'pdf'].indexOf(type) > -1 && treeConfig) {\n            opts.data = XEUtils.searchTree(this.getTableData().fullData, item => selectRecords.indexOf(item) > -1, Object.assign({}, treeOpts, {\n              data: '_row'\n            }));\n          } else {\n            opts.data = selectRecords;\n          }\n        } else if (mode === 'all') {\n          if ($xegrid && !opts.remote) {\n            const _$xegrid$proxyOpts = $xegrid.proxyOpts,\n                  beforeQueryAll = _$xegrid$proxyOpts.beforeQueryAll,\n                  afterQueryAll = _$xegrid$proxyOpts.afterQueryAll,\n                  _$xegrid$proxyOpts$aj = _$xegrid$proxyOpts.ajax,\n                  ajax = _$xegrid$proxyOpts$aj === void 0 ? {} : _$xegrid$proxyOpts$aj,\n                  _$xegrid$proxyOpts$pr = _$xegrid$proxyOpts.props,\n                  props = _$xegrid$proxyOpts$pr === void 0 ? {} : _$xegrid$proxyOpts$pr;\n            const ajaxMethods = ajax.queryAll;\n\n            if (ajaxMethods) {\n              const params = {\n                $table: this,\n                $grid: $xegrid,\n                sort: $xegrid.sortData,\n                filters: $xegrid.filterData,\n                form: $xegrid.formData,\n                target: ajaxMethods,\n                options: opts\n              };\n              return Promise.resolve((beforeQueryAll || ajaxMethods)(params)).catch(e => e).then(rest => {\n                opts.data = (props.list ? XEUtils.get(rest, props.list) : rest) || [];\n\n                if (afterQueryAll) {\n                  afterQueryAll(params);\n                }\n\n                return handleExport(this, opts);\n              });\n            }\n          }\n        }\n      }\n\n      return handleExport(this, opts);\n    },\n\n    _importByFile(file, options) {\n      const opts = Object.assign({}, options);\n      const beforeImportMethod = opts.beforeImportMethod;\n\n      if (beforeImportMethod) {\n        beforeImportMethod({\n          options: opts,\n          $table: this\n        });\n      }\n\n      return handleFileImport(this, file, opts);\n    },\n\n    _importData(options) {\n      const opts = Object.assign({\n        types: VXETable.config.importTypes // beforeImportMethod: null,\n        // afterImportMethod: null\n\n      }, this.importOpts, options);\n      const beforeImportMethod = opts.beforeImportMethod,\n            afterImportMethod = opts.afterImportMethod;\n\n      if (beforeImportMethod) {\n        beforeImportMethod({\n          options: opts,\n          $table: this\n        });\n      }\n\n      return readLocalFile(opts).catch(e => {\n        if (afterImportMethod) {\n          afterImportMethod({\n            status: false,\n            options: opts,\n            $table: this\n          });\n        }\n\n        return Promise.reject(e);\n      }).then(params => {\n        const file = params.file;\n        return handleFileImport(this, file, opts);\n      });\n    },\n\n    _saveFile(options) {\n      return saveLocalFile(options);\n    },\n\n    _readFile(options) {\n      return readLocalFile(options);\n    },\n\n    _print(options) {\n      const opts = Object.assign({\n        original: false // beforePrintMethod\n\n      }, this.printOpts, options, {\n        type: 'html',\n        download: false,\n        remote: false,\n        print: true\n      });\n\n      if (!opts.sheetName) {\n        opts.sheetName = document.title;\n      }\n\n      return new Promise(resolve => {\n        if (opts.content) {\n          resolve(handlePrint(this, opts, opts.content));\n        } else {\n          resolve(this.exportData(opts).then(_ref3 => {\n            let content = _ref3.content;\n            return handlePrint(this, opts, content);\n          }));\n        }\n      });\n    },\n\n    _openImport(options) {\n      const defOpts = Object.assign({\n        mode: 'insert',\n        message: true,\n        types: VXETable.config.importTypes\n      }, options, this.importOpts);\n      const types = defOpts.types;\n      const isTree = !!this.getTreeStatus();\n\n      if (isTree) {\n        if (defOpts.message) {\n          VXETable.modal.message({\n            content: GlobalConfig.i18n('vxe.error.treeNotImp'),\n            status: 'error'\n          });\n        }\n\n        return;\n      }\n\n      if (!this.importConfig) {\n        UtilTools.error('vxe.error.reqProp', ['import-config']);\n      } // 处理类型\n\n\n      const typeList = types.map(value => {\n        return {\n          value,\n          label: `vxe.export.types.${value}`\n        };\n      });\n      const modeList = defOpts.modes.map(value => {\n        return {\n          value,\n          label: `vxe.import.modes.${value}`\n        };\n      });\n      Object.assign(this.importStore, {\n        file: null,\n        type: '',\n        filename: '',\n        modeList,\n        typeList,\n        visible: true\n      });\n      Object.assign(this.importParams, defOpts);\n      this.initStore.import = true;\n    },\n\n    _openExport(options) {\n      const exportOpts = this.exportOpts;\n\n      if (process.env.VUE_APP_VXE_TABLE_ENV === 'development') {\n        if (!this.exportConfig) {\n          UtilTools.error('vxe.error.reqProp', ['export-config']);\n        }\n      }\n\n      return handleExportAndPrint(this, Object.assign({}, exportOpts, options));\n    },\n\n    _openPrint(options) {\n      const printOpts = this.printOpts;\n\n      if (process.env.VUE_APP_VXE_TABLE_ENV === 'development') {\n        if (!this.printConfig) {\n          UtilTools.error('vxe.error.reqProp', ['print-config']);\n        }\n      }\n\n      return handleExportAndPrint(this, Object.assign({}, printOpts, options), true);\n    }\n\n  }\n};",null]}