{"remainingRequest":"D:\\cdRule\\node_modules\\thread-loader\\dist\\cjs.js!D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js!D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js!D:\\cdRule\\src\\components\\Table\\form\\src\\form.js","dependencies":[{"path":"D:\\cdRule\\src\\components\\Table\\form\\src\\form.js","mtime":1635230121847},{"path":"D:\\cdRule\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\thread-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.regexp.constructor\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/web.dom.iterable\";\nimport _defineProperty from \"D:\\\\cdRule\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport \"core-js/modules/es6.regexp.constructor\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport XEUtils from 'xe-utils';\nimport GlobalConfig from '../../v-x-e-table/src/conf';\nimport vSize from '../../mixins/size';\nimport VXETable from '../../v-x-e-table';\nimport { UtilTools, isEnableConf } from '../../tools';\nimport { createItem } from './util';\nimport { eqEmptyValue } from '../../tools/src/utils';\nimport { browse } from '../../tools/src/dom';\n\nclass Rule {\n  constructor(rule) {\n    Object.assign(this, {\n      $options: rule,\n      required: rule.required,\n      min: rule.min,\n      max: rule.min,\n      type: rule.type,\n      pattern: rule.pattern,\n      validator: rule.validator,\n      trigger: rule.trigger,\n      maxWidth: rule.maxWidth\n    });\n  }\n\n  get message() {\n    return UtilTools.getFuncText(this.$options.message);\n  }\n\n}\n\nfunction validErrorRuleValue(rule, val) {\n  const type = rule.type,\n        min = rule.min,\n        max = rule.max,\n        pattern = rule.pattern;\n  const isNumType = type === 'number';\n  const numVal = isNumType ? XEUtils.toNumber(val) : XEUtils.getSize(val); // 判断数值\n\n  if (isNumType && isNaN(val)) {\n    return true;\n  } // 如果存在 min，判断最小值\n\n\n  if (!XEUtils.eqNull(min) && numVal < XEUtils.toNumber(min)) {\n    return true;\n  } // 如果存在 max，判断最大值\n\n\n  if (!XEUtils.eqNull(max) && numVal > XEUtils.toNumber(max)) {\n    return true;\n  } // 如果存在 pattern，正则校验\n\n\n  if (pattern && !(XEUtils.isRegExp(pattern) ? pattern : new RegExp(pattern)).test(val)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction getResetValue(value, resetValue) {\n  if (XEUtils.isArray(value)) {\n    resetValue = [];\n  }\n\n  return resetValue;\n}\n\nfunction callSlot(_vm, slotFunc, params, h) {\n  if (slotFunc) {\n    const $scopedSlots = _vm.$scopedSlots;\n\n    if (XEUtils.isString(slotFunc)) {\n      slotFunc = $scopedSlots[slotFunc] || null;\n    }\n\n    if (XEUtils.isFunction(slotFunc)) {\n      return slotFunc.call(_vm, params, h);\n    }\n  }\n\n  return [];\n}\n\nfunction renderPrefixIcon(h, titlePrefix) {\n  return h('span', {\n    class: 'vxe-form--item-title-prefix'\n  }, [h('i', {\n    class: titlePrefix.icon || GlobalConfig.icon.FORM_PREFIX\n  })]);\n}\n\nfunction renderSuffixIcon(h, titleSuffix) {\n  return h('span', {\n    class: 'vxe-form--item-title-suffix'\n  }, [h('i', {\n    class: titleSuffix.icon || GlobalConfig.icon.FORM_SUFFIX\n  })]);\n}\n\nfunction renderTitle(h, _vm, item) {\n  const data = _vm.data;\n  const slots = item.slots,\n        field = item.field,\n        itemRender = item.itemRender,\n        titlePrefix = item.titlePrefix,\n        titleSuffix = item.titleSuffix;\n  const compConf = isEnableConf(itemRender) ? VXETable.renderer.get(itemRender.name) : null;\n  const params = {\n    data,\n    property: field,\n    item,\n    $form: _vm\n  };\n  const tss = [];\n\n  if (titlePrefix) {\n    tss.push(titlePrefix.message ? h('vxe-tooltip', {\n      props: {\n        content: UtilTools.getFuncText(titlePrefix.message),\n        enterable: titlePrefix.enterable,\n        skin: titlePrefix.skin\n      }\n    }, [renderPrefixIcon(h, titlePrefix)]) : renderPrefixIcon(h, titlePrefix));\n  }\n\n  tss.push(h('span', {\n    class: 'vxe-form--item-title-label'\n  }, compConf && compConf.renderItemTitle ? compConf.renderItemTitle(itemRender, params) : slots && slots.title ? callSlot(_vm, slots.title, params, h) : UtilTools.getFuncText(item.title)));\n\n  if (titleSuffix) {\n    tss.push(titleSuffix.message ? h('vxe-tooltip', {\n      props: {\n        content: UtilTools.getFuncText(titleSuffix.message),\n        enterable: titleSuffix.enterable,\n        skin: titleSuffix.skin\n      }\n    }, [renderSuffixIcon(h, titleSuffix)]) : renderSuffixIcon(h, titleSuffix));\n  }\n\n  return tss;\n}\n\nfunction renderItems(h, _vm, itemList) {\n  const _e = _vm._e,\n        rules = _vm.rules,\n        data = _vm.data,\n        collapseAll = _vm.collapseAll,\n        validOpts = _vm.validOpts,\n        allTitleOverflow = _vm.titleOverflow;\n  return itemList.map((item, index) => {\n    const slots = item.slots,\n          title = item.title,\n          folding = item.folding,\n          visible = item.visible,\n          visibleMethod = item.visibleMethod,\n          field = item.field,\n          collapseNode = item.collapseNode,\n          itemRender = item.itemRender,\n          showError = item.showError,\n          errRule = item.errRule,\n          className = item.className,\n          titleOverflow = item.titleOverflow,\n          children = item.children;\n    const compConf = isEnableConf(itemRender) ? VXETable.renderer.get(itemRender.name) : null;\n    const span = item.span || _vm.span;\n    const align = item.align || _vm.align;\n    const titleAlign = item.titleAlign || _vm.titleAlign;\n    const titleWidth = item.titleWidth || _vm.titleWidth;\n    let itemVisibleMethod = visibleMethod;\n    const itemOverflow = XEUtils.isUndefined(titleOverflow) || XEUtils.isNull(titleOverflow) ? allTitleOverflow : titleOverflow;\n    const showEllipsis = itemOverflow === 'ellipsis';\n    const showTitle = itemOverflow === 'title';\n    const showTooltip = itemOverflow === true || itemOverflow === 'tooltip';\n    const hasEllipsis = showTitle || showTooltip || showEllipsis;\n    const params = {\n      data,\n      property: field,\n      item,\n      $form: _vm\n    };\n    let isRequired;\n\n    if (visible === false) {\n      return _e();\n    } // 如果为项集合\n\n\n    const isGather = children && children.length > 0;\n\n    if (isGather) {\n      const childVNs = renderItems(h, _vm, item.children);\n      return childVNs.length ? h('div', {\n        class: ['vxe-form--gather vxe-row', item.id, span ? `vxe-col--${span} is--span` : '', className ? XEUtils.isFunction(className) ? className(params) : className : '']\n      }, childVNs) : _e();\n    }\n\n    if (!itemVisibleMethod && compConf && compConf.itemVisibleMethod) {\n      itemVisibleMethod = compConf.itemVisibleMethod;\n    }\n\n    if (rules) {\n      const itemRules = rules[field];\n\n      if (itemRules) {\n        isRequired = itemRules.some(rule => rule.required);\n      }\n    }\n\n    let contentVNs = [];\n\n    if (slots && slots.default) {\n      contentVNs = callSlot(_vm, slots.default, params, h);\n    } else if (compConf && compConf.renderItemContent) {\n      contentVNs = compConf.renderItemContent.call(_vm, h, itemRender, params);\n    } else if (compConf && compConf.renderItem) {\n      contentVNs = compConf.renderItem.call(_vm, h, itemRender, params);\n    } else if (field) {\n      contentVNs = [`${XEUtils.get(data, field)}`];\n    }\n\n    const ons = showTooltip ? {\n      mouseenter(evnt) {\n        _vm.triggerHeaderHelpEvent(evnt, params);\n      },\n\n      mouseleave: _vm.handleTargetLeaveEvent\n    } : {};\n    return h('div', {\n      class: ['vxe-form--item', item.id, span ? `vxe-col--${span} is--span` : null, className ? XEUtils.isFunction(className) ? className(params) : className : '', {\n        'is--title': title,\n        'is--required': isRequired,\n        'is--hidden': folding && collapseAll,\n        'is--active': !itemVisibleMethod || itemVisibleMethod(params),\n        'is--error': showError\n      }],\n      key: index\n    }, [h('div', {\n      class: 'vxe-form--item-inner'\n    }, [title || slots && slots.title ? h('div', {\n      class: ['vxe-form--item-title', titleAlign ? `align--${titleAlign}` : null, {\n        'is--ellipsis': hasEllipsis\n      }],\n      style: titleWidth ? {\n        width: isNaN(titleWidth) ? titleWidth : `${titleWidth}px`\n      } : null,\n      attrs: {\n        title: showTitle ? UtilTools.getFuncText(title) : null\n      },\n      on: ons\n    }, renderTitle(h, _vm, item)) : null, h('div', {\n      class: ['vxe-form--item-content', align ? `align--${align}` : null]\n    }, contentVNs.concat([collapseNode ? h('div', {\n      class: 'vxe-form--item-trigger-node',\n      on: {\n        click: _vm.toggleCollapseEvent\n      }\n    }, [h('span', {\n      class: 'vxe-form--item-trigger-text'\n    }, collapseAll ? GlobalConfig.i18n('vxe.form.unfolding') : GlobalConfig.i18n('vxe.form.folding')), h('i', {\n      class: ['vxe-form--item-trigger-icon', collapseAll ? GlobalConfig.icon.FORM_FOLDING : GlobalConfig.icon.FORM_UNFOLDING]\n    })]) : null, errRule && validOpts.showMessage ? h('div', {\n      class: 'vxe-form--item-valid',\n      style: errRule.maxWidth ? {\n        width: `${errRule.maxWidth}px`\n      } : null\n    }, errRule.message) : null]))])]);\n  });\n}\n\nexport default {\n  name: 'VxeForm',\n  mixins: [vSize],\n  props: {\n    loading: Boolean,\n    data: Object,\n    size: {\n      type: String,\n      default: () => GlobalConfig.form.size || GlobalConfig.size\n    },\n    span: [String, Number],\n    align: {\n      type: String,\n      default: () => GlobalConfig.form.align\n    },\n    titleAlign: {\n      type: String,\n      default: () => GlobalConfig.form.titleAlign\n    },\n    titleWidth: [String, Number],\n    titleColon: {\n      type: Boolean,\n      default: () => GlobalConfig.form.titleColon\n    },\n    titleAsterisk: {\n      type: Boolean,\n      default: () => GlobalConfig.form.titleAsterisk\n    },\n    titleOverflow: {\n      type: [Boolean, String],\n      default: null\n    },\n    className: [String, Function],\n    items: Array,\n    rules: Object,\n    preventSubmit: {\n      type: Boolean,\n      default: () => GlobalConfig.form.preventSubmit\n    },\n    validConfig: Object\n  },\n\n  data() {\n    return {\n      collapseAll: true,\n      staticItems: [],\n      formItems: [],\n      tooltipTimeout: null,\n      tooltipActive: false,\n      tooltipStore: {\n        item: null,\n        visible: false\n      }\n    };\n  },\n\n  provide() {\n    return {\n      $xeform: this\n    };\n  },\n\n  computed: {\n    validOpts() {\n      return Object.assign({}, GlobalConfig.form.validConfig, this.validConfig);\n    },\n\n    tooltipOpts() {\n      const opts = Object.assign({\n        leaveDelay: 300\n      }, GlobalConfig.form.tooltipConfig, this.tooltipConfig);\n\n      if (opts.enterable) {\n        opts.leaveMethod = this.handleTooltipLeaveMethod;\n      }\n\n      return opts;\n    }\n\n  },\n\n  created() {\n    this.$nextTick(() => {\n      const items = this.items;\n\n      if (items) {\n        this.loadItem(items);\n      }\n    });\n  },\n\n  watch: {\n    staticItems(value) {\n      this.formItems = value;\n    },\n\n    items(value) {\n      this.loadItem(value);\n    }\n\n  },\n\n  render(h) {\n    const _e = this._e,\n          loading = this.loading,\n          className = this.className,\n          data = this.data,\n          vSize = this.vSize,\n          tooltipOpts = this.tooltipOpts,\n          formItems = this.formItems;\n    const hasUseTooltip = VXETable._tooltip;\n    return h('form', {\n      class: ['vxe-form', className ? XEUtils.isFunction(className) ? className({\n        items: formItems,\n        data,\n        $form: this\n      }) : className : '', {\n        [`size--${vSize}`]: vSize,\n        'is--colon': this.titleColon,\n        'is--asterisk': this.titleAsterisk,\n        'is--loading': loading\n      }],\n      on: {\n        submit: this.submitEvent,\n        reset: this.resetEvent\n      }\n    }, [h('div', {\n      class: 'vxe-form--wrapper vxe-row'\n    }, renderItems(h, this, formItems)), h('div', {\n      class: 'vxe-form-slots',\n      ref: 'hideItem'\n    }, this.$slots.default), h('div', {\n      class: ['vxe-loading', {\n        'is--visible': loading\n      }]\n    }, [h('div', {\n      class: 'vxe-loading--spinner'\n    })]),\n    /**\r\n     * 工具提示\r\n     */\n    hasUseTooltip ? h('vxe-tooltip', _objectSpread({\n      ref: 'tooltip'\n    }, tooltipOpts)) : _e()]);\n  },\n\n  methods: {\n    loadItem(list) {\n      if (process.env.VUE_APP_VXE_TABLE_ENV === 'development') {\n        const $scopedSlots = this.$scopedSlots;\n        list.forEach(item => {\n          if (item.slots) {\n            XEUtils.each(item.slots, func => {\n              if (!XEUtils.isFunction(func)) {\n                if (!$scopedSlots[func]) {\n                  UtilTools.error('vxe.error.notSlot', [func]);\n                }\n              }\n            });\n          }\n        });\n      }\n\n      this.staticItems = XEUtils.mapTree(list, item => createItem(this, item), {\n        children: 'children'\n      });\n      return this.$nextTick();\n    },\n\n    getItems() {\n      const itemList = [];\n      XEUtils.eachTree(this.formItems, item => {\n        itemList.push(item);\n      }, {\n        children: 'children'\n      });\n      return itemList;\n    },\n\n    toggleCollapse() {\n      this.collapseAll = !this.collapseAll;\n      return this.$nextTick();\n    },\n\n    toggleCollapseEvent(evnt) {\n      this.toggleCollapse();\n      this.$emit('toggle-collapse', {\n        collapse: !this.collapseAll,\n        data: this.data,\n        $form: this,\n        $event: evnt\n      }, evnt);\n    },\n\n    submitEvent(evnt) {\n      evnt.preventDefault();\n\n      if (!this.preventSubmit) {\n        this.beginValidate().then(() => {\n          this.$emit('submit', {\n            data: this.data,\n            $form: this,\n            $event: evnt\n          });\n        }).catch(errMap => {\n          this.$emit('submit-invalid', {\n            data: this.data,\n            errMap,\n            $form: this,\n            $event: evnt\n          });\n        });\n      }\n    },\n\n    reset() {\n      const data = this.data;\n\n      if (data) {\n        const itemList = this.getItems();\n        itemList.forEach(item => {\n          const field = item.field,\n                resetValue = item.resetValue,\n                itemRender = item.itemRender;\n\n          if (isEnableConf(itemRender)) {\n            const compConf = VXETable.renderer.get(itemRender.name);\n\n            if (compConf && compConf.itemResetMethod) {\n              compConf.itemResetMethod({\n                data,\n                property: field,\n                item,\n                $form: this\n              });\n            } else if (field) {\n              XEUtils.set(data, field, resetValue === null ? getResetValue(XEUtils.get(data, field), undefined) : resetValue);\n            }\n          }\n        });\n      }\n\n      return this.clearValidate();\n    },\n\n    resetEvent(evnt) {\n      evnt.preventDefault();\n      this.reset();\n      this.$emit('reset', {\n        data: this.data,\n        $form: this,\n        $event: evnt\n      });\n    },\n\n    handleTooltipLeaveMethod() {\n      const tooltipOpts = this.tooltipOpts;\n      setTimeout(() => {\n        if (!this.tooltipActive) {\n          this.closeTooltip();\n        }\n      }, tooltipOpts.leaveDelay);\n      return false;\n    },\n\n    closeTooltip() {\n      const tooltipStore = this.tooltipStore;\n      const $tooltip = this.$refs.tooltip;\n\n      if (tooltipStore.visible) {\n        Object.assign(tooltipStore, {\n          item: null,\n          visible: false\n        });\n\n        if ($tooltip) {\n          $tooltip.close();\n        }\n      }\n\n      return this.$nextTick();\n    },\n\n    triggerHeaderHelpEvent(evnt, params) {\n      const item = params.item;\n      const tooltipStore = this.tooltipStore;\n      const $tooltip = this.$refs.tooltip;\n      const overflowElem = evnt.currentTarget;\n      const content = (overflowElem.textContent || '').trim();\n      const isCellOverflow = overflowElem.scrollWidth > overflowElem.clientWidth;\n      clearTimeout(this.tooltipTimeout);\n      this.tooltipActive = true;\n      this.closeTooltip();\n\n      if (content && isCellOverflow) {\n        Object.assign(tooltipStore, {\n          item,\n          visible: true\n        });\n\n        if ($tooltip) {\n          $tooltip.open(overflowElem, content);\n        }\n      }\n    },\n\n    handleTargetLeaveEvent() {\n      const tooltipOpts = this.tooltipOpts;\n      this.tooltipActive = false;\n\n      if (tooltipOpts.enterable) {\n        this.tooltipTimeout = setTimeout(() => {\n          const $tooltip = this.$refs.tooltip;\n\n          if ($tooltip && !$tooltip.isHover) {\n            this.closeTooltip();\n          }\n        }, tooltipOpts.leaveDelay);\n      } else {\n        this.closeTooltip();\n      }\n    },\n\n    clearValidate(field) {\n      const itemList = this.getItems();\n\n      if (field) {\n        const item = itemList.find(item => item.field === field);\n\n        if (item) {\n          item.showError = false;\n        }\n      } else {\n        itemList.forEach(item => {\n          item.showError = false;\n        });\n      }\n\n      return this.$nextTick();\n    },\n\n    validate(callback) {\n      return this.beginValidate('', callback);\n    },\n\n    beginValidate(type, callback) {\n      const data = this.data,\n            formRules = this.rules,\n            validOpts = this.validOpts;\n      const validRest = {};\n      const validFields = [];\n      const itemValids = [];\n      const itemList = this.getItems();\n      this.clearValidate();\n      clearTimeout(this.showErrTime);\n\n      if (data && formRules) {\n        itemList.forEach(item => {\n          const field = item.field;\n\n          if (field) {\n            itemValids.push(this.validItemRules(type || 'all', field).then(() => {\n              item.errRule = null;\n            }).catch(_ref => {\n              let rule = _ref.rule,\n                  rules = _ref.rules;\n              const rest = {\n                rule,\n                rules,\n                data,\n                property: field,\n                $form: this\n              };\n\n              if (!validRest[field]) {\n                validRest[field] = [];\n              }\n\n              validRest[field].push(rest);\n              validFields.push(field);\n              item.errRule = rule;\n              return Promise.reject(rest);\n            }));\n          }\n        });\n        return Promise.all(itemValids).then(() => {\n          if (callback) {\n            callback();\n          }\n        }).catch(() => {\n          return new Promise((resolve, reject) => {\n            this.showErrTime = setTimeout(() => {\n              itemList.forEach(item => {\n                if (item.errRule) {\n                  item.showError = true;\n                }\n              });\n            }, 20);\n\n            if (validOpts.autoPos) {\n              this.$nextTick(() => {\n                this.handleFocus(validFields);\n              });\n            }\n\n            if (callback) {\n              callback(validRest);\n              resolve();\n            } else {\n              reject(validRest);\n            }\n          });\n        });\n      }\n\n      if (callback) {\n        callback();\n      }\n\n      return Promise.resolve();\n    },\n\n    /**\r\n     * 校验数据\r\n     * 按表格行、列顺序依次校验（同步或异步）\r\n     * 校验规则根据索引顺序依次校验，如果是异步则会等待校验完成才会继续校验下一列\r\n     * 如果校验失败则，触发回调或者 Promise<(ErrMap 校验不通过列的信息)>\r\n     * 如果是传回调方式这返回一个 (ErrMap 校验不通过列的信息)\r\n     *\r\n     * rule 配置：\r\n     *  required=Boolean 是否必填\r\n     *  min=Number 最小长度\r\n     *  max=Number 最大长度\r\n     *  validator=Function({ itemValue, rule, rules, data, property }) 自定义校验，接收一个 Promise\r\n     *  trigger=change 触发方式\r\n     */\n    validItemRules(validType, property, val) {\n      const data = this.data,\n            formRules = this.rules;\n      const errorRules = [];\n      const syncVailds = [];\n\n      if (property && formRules) {\n        const rules = XEUtils.get(formRules, property);\n\n        if (rules) {\n          const itemValue = XEUtils.isUndefined(val) ? XEUtils.get(data, property) : val;\n          rules.forEach(rule => {\n            const type = rule.type,\n                  trigger = rule.trigger,\n                  required = rule.required;\n\n            if (validType === 'all' || !trigger || validType === rule.trigger) {\n              if (XEUtils.isFunction(rule.validator)) {\n                const customValid = rule.validator({\n                  itemValue,\n                  rule,\n                  rules,\n                  data,\n                  property,\n                  $form: this\n                });\n\n                if (customValid) {\n                  if (XEUtils.isError(customValid)) {\n                    errorRules.push(new Rule({\n                      type: 'custom',\n                      trigger,\n                      message: customValid.message,\n                      rule: new Rule(rule)\n                    }));\n                  } else if (customValid.catch) {\n                    // 如果为异步校验（注：异步校验是并发无序的）\n                    syncVailds.push(customValid.catch(e => {\n                      errorRules.push(new Rule({\n                        type: 'custom',\n                        trigger,\n                        message: e ? e.message : rule.message,\n                        rule: new Rule(rule)\n                      }));\n                    }));\n                  }\n                }\n              } else {\n                const isArrType = type === 'array';\n                const hasEmpty = isArrType ? !XEUtils.isArray(itemValue) || !itemValue.length : eqEmptyValue(itemValue);\n\n                if (required ? hasEmpty || validErrorRuleValue(rule, itemValue) : !hasEmpty && validErrorRuleValue(rule, itemValue)) {\n                  errorRules.push(new Rule(rule));\n                }\n              }\n            }\n          });\n        }\n      }\n\n      return Promise.all(syncVailds).then(() => {\n        if (errorRules.length) {\n          const rest = {\n            rules: errorRules,\n            rule: errorRules[0]\n          };\n          return Promise.reject(rest);\n        }\n      });\n    },\n\n    handleFocus(fields) {\n      const $el = this.$el;\n      const itemList = this.getItems();\n      fields.some(property => {\n        const item = itemList.find(item => item.field === property);\n\n        if (item && isEnableConf(item.itemRender)) {\n          const itemRender = item.itemRender;\n          const compConf = VXETable.renderer.get(itemRender.name);\n          let inputElem; // 如果指定了聚焦 class\n\n          if (itemRender.autofocus) {\n            inputElem = $el.querySelector(`.${item.id} ${itemRender.autofocus}`);\n          } // 渲染器的聚焦处理\n\n\n          if (!inputElem && compConf && compConf.autofocus) {\n            inputElem = $el.querySelector(`.${item.id} ${compConf.autofocus}`);\n          }\n\n          if (inputElem) {\n            inputElem.focus(); // 保持一致行为，光标移到末端\n\n            if (browse.msie) {\n              const textRange = inputElem.createTextRange();\n              textRange.collapse(false);\n              textRange.select();\n            }\n\n            return true;\n          }\n        }\n      });\n    },\n\n    /**\r\n     * 更新项状态\r\n     * 如果组件值 v-model 发生 change 时，调用改函数用于更新某一项编辑状态\r\n     * 如果单元格配置了校验规则，则会进行校验\r\n     */\n    updateStatus(scope, itemValue) {\n      const property = scope.property;\n\n      if (property) {\n        this.validItemRules('change', property, itemValue).then(() => {\n          this.clearValidate(property);\n        }).catch(_ref2 => {\n          let rule = _ref2.rule;\n          const itemList = this.getItems();\n          const item = itemList.find(item => item.field === property);\n\n          if (item) {\n            item.showError = true;\n            item.errRule = rule;\n          }\n        });\n      }\n    }\n\n  }\n};",null]}