{"remainingRequest":"D:\\cdRule\\node_modules\\thread-loader\\dist\\cjs.js!D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js!D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js!D:\\cdRule\\src\\components\\Table\\validator\\src\\mixin.js","dependencies":[{"path":"D:\\cdRule\\src\\components\\Table\\validator\\src\\mixin.js","mtime":1635230120982},{"path":"D:\\cdRule\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\thread-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.regexp.constructor\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.regexp.constructor\";\nimport XEUtils from 'xe-utils';\nimport { UtilTools, DomTools } from '../../tools';\nimport { eqEmptyValue } from '../../tools/src/utils';\n/**\r\n * 校验规则\r\n */\n\nclass Rule {\n  constructor(rule) {\n    Object.assign(this, {\n      $options: rule,\n      required: rule.required,\n      min: rule.min,\n      max: rule.max,\n      type: rule.type,\n      pattern: rule.pattern,\n      validator: rule.validator,\n      trigger: rule.trigger,\n      maxWidth: rule.maxWidth\n    });\n  }\n  /**\r\n   * 获取校验不通过的消息\r\n   * 支持国际化翻译\r\n   */\n\n\n  get message() {\n    return UtilTools.getFuncText(this.$options.message);\n  }\n\n}\n\nfunction validErrorRuleValue(rule, val) {\n  const type = rule.type,\n        min = rule.min,\n        max = rule.max,\n        pattern = rule.pattern;\n  const isNumType = type === 'number';\n  const numVal = isNumType ? XEUtils.toNumber(val) : XEUtils.getSize(val); // 判断数值\n\n  if (isNumType && isNaN(val)) {\n    return true;\n  } // 如果存在 min，判断最小值\n\n\n  if (!XEUtils.eqNull(min) && numVal < XEUtils.toNumber(min)) {\n    return true;\n  } // 如果存在 max，判断最大值\n\n\n  if (!XEUtils.eqNull(max) && numVal > XEUtils.toNumber(max)) {\n    return true;\n  } // 如果存在 pattern，正则校验\n\n\n  if (pattern && !(XEUtils.isRegExp(pattern) ? pattern : new RegExp(pattern)).test(val)) {\n    return true;\n  }\n\n  return false;\n}\n\nexport default {\n  methods: {\n    /**\r\n     * 完整校验，和 validate 的区别就是会给有效数据中的每一行进行校验\r\n     */\n    _fullValidate(rows, cb) {\n      return this.beginValidate(rows, cb, true);\n    },\n\n    /**\r\n     * 快速校验，如果存在记录不通过的记录，则返回不再继续校验（异步校验除外）\r\n     */\n    _validate(rows, cb) {\n      return this.beginValidate(rows, cb);\n    },\n\n    /**\r\n     * 聚焦到校验通过的单元格并弹出校验错误提示\r\n     */\n    handleValidError(params) {\n      return new Promise(resolve => {\n        if (this.validOpts.autoPos === false) {\n          this.emitEvent('valid-error', params);\n          resolve();\n        } else {\n          this.handleActived(params, {\n            type: 'valid-error',\n            trigger: 'call'\n          }).then(() => {\n            setTimeout(() => {\n              resolve(this.showValidTooltip(params));\n            }, 10);\n          });\n        }\n      });\n    },\n\n    /**\r\n     * 对表格数据进行校验\r\n     * 如果不指定数据，则默认只校验临时变动的数据，例如新增或修改\r\n     * 如果传 true 则校验当前表格数据\r\n     * 如果传 row 指定行记录，则只验证传入的行\r\n     * 如果传 rows 为多行记录，则只验证传入的行\r\n     * 如果只传 callback 否则默认验证整个表格数据\r\n     * 返回 Promise 对象，或者使用回调方式\r\n     */\n    beginValidate(rows, cb, isFull) {\n      const validRest = {};\n      const editRules = this.editRules,\n            afterFullData = this.afterFullData,\n            treeConfig = this.treeConfig,\n            treeOpts = this.treeOpts;\n      let vaildDatas;\n\n      if (rows === true) {\n        vaildDatas = afterFullData;\n      } else if (rows) {\n        if (XEUtils.isFunction(rows)) {\n          cb = rows;\n        } else {\n          vaildDatas = XEUtils.isArray(rows) ? rows : [rows];\n        }\n      }\n\n      if (!vaildDatas) {\n        vaildDatas = this.getInsertRecords().concat(this.getUpdateRecords());\n      }\n\n      const rowValids = [];\n      this.lastCallTime = Date.now();\n      this.validRuleErr = false; // 如果为快速校验，当存在某列校验不通过时将终止执行\n\n      this.clearValidate();\n\n      if (editRules) {\n        const columns = this.getColumns();\n\n        const handleVaild = row => {\n          if (isFull || !this.validRuleErr) {\n            const colVailds = [];\n            columns.forEach(column => {\n              if ((isFull || !this.validRuleErr) && XEUtils.has(editRules, column.property)) {\n                colVailds.push(this.validCellRules('all', row, column).catch(_ref => {\n                  let rule = _ref.rule,\n                      rules = _ref.rules;\n                  const rest = {\n                    rule,\n                    rules,\n                    rowIndex: this.getRowIndex(row),\n                    row,\n                    columnIndex: this.getColumnIndex(column),\n                    column,\n                    $table: this\n                  };\n\n                  if (!validRest[column.property]) {\n                    validRest[column.property] = [];\n                  }\n\n                  validRest[column.property].push(rest);\n\n                  if (!isFull) {\n                    this.validRuleErr = true;\n                    return Promise.reject(rest);\n                  }\n                }));\n              }\n            });\n            rowValids.push(Promise.all(colVailds));\n          }\n        };\n\n        if (treeConfig) {\n          XEUtils.eachTree(vaildDatas, handleVaild, treeOpts);\n        } else {\n          vaildDatas.forEach(handleVaild);\n        }\n\n        return Promise.all(rowValids).then(() => {\n          const ruleProps = Object.keys(validRest);\n          return this.$nextTick().then(() => {\n            if (ruleProps.length) {\n              return Promise.reject(validRest[ruleProps[0]][0]);\n            }\n\n            if (cb) {\n              cb();\n            }\n          });\n        }).catch(firstErrParams => {\n          return new Promise((resolve, reject) => {\n            const finish = () => {\n              this.$nextTick(() => {\n                if (cb) {\n                  cb(validRest);\n                  resolve();\n                } else {\n                  reject(validRest);\n                }\n              });\n            };\n\n            const posAndFinish = () => {\n              firstErrParams.cell = this.getCell(firstErrParams.row, firstErrParams.column);\n              DomTools.scrollToView(firstErrParams.cell);\n              this.handleValidError(firstErrParams).then(finish);\n            };\n            /**\r\n             * 当校验不通过时\r\n             * 将表格滚动到可视区\r\n             * 由于提示信息至少需要占一行，定位向上偏移一行\r\n             */\n\n\n            const row = firstErrParams.row;\n            const rowIndex = afterFullData.indexOf(row);\n            const locatRow = rowIndex > 0 ? afterFullData[rowIndex - 1] : row;\n\n            if (this.validOpts.autoPos === false) {\n              finish();\n            } else {\n              if (treeConfig) {\n                this.scrollToTreeRow(locatRow).then(posAndFinish);\n              } else {\n                this.scrollToRow(locatRow).then(posAndFinish);\n              }\n            }\n          });\n        });\n      }\n\n      return this.$nextTick().then(() => {\n        if (cb) {\n          cb();\n        }\n      });\n    },\n\n    hasCellRules(type, row, column) {\n      const editRules = this.editRules;\n      const property = column.property;\n\n      if (property && editRules) {\n        const rules = XEUtils.get(editRules, property);\n        return rules && XEUtils.find(rules, rule => type === 'all' || !rule.trigger || type === rule.trigger);\n      }\n\n      return false;\n    },\n\n    /**\r\n     * 校验数据\r\n     * 按表格行、列顺序依次校验（同步或异步）\r\n     * 校验规则根据索引顺序依次校验，如果是异步则会等待校验完成才会继续校验下一列\r\n     * 如果校验失败则，触发回调或者Promise<不通过列的错误消息>\r\n     * 如果是传回调方式这返回一个校验不通过列的错误消息\r\n     *\r\n     * rule 配置：\r\n     *  required=Boolean 是否必填\r\n     *  min=Number 最小长度\r\n     *  max=Number 最大长度\r\n     *  validator=Function({ cellValue, rule, rules, row, column, rowIndex, columnIndex }) 自定义校验，接收一个 Promise\r\n     *  trigger=blur|change 触发方式（除非特殊场景，否则默认为空就行）\r\n     */\n    validCellRules(validType, row, column, val) {\n      const editRules = this.editRules;\n      const property = column.property;\n      const errorRules = [];\n      const syncVailds = [];\n\n      if (property && editRules) {\n        const rules = XEUtils.get(editRules, property);\n\n        if (rules) {\n          const cellValue = XEUtils.isUndefined(val) ? XEUtils.get(row, property) : val;\n          rules.forEach(rule => {\n            const type = rule.type,\n                  trigger = rule.trigger,\n                  required = rule.required;\n\n            if (validType === 'all' || !trigger || validType === trigger) {\n              if (XEUtils.isFunction(rule.validator)) {\n                const customValid = rule.validator({\n                  cellValue,\n                  rule,\n                  rules,\n                  row,\n                  rowIndex: this.getRowIndex(row),\n                  column,\n                  columnIndex: this.getColumnIndex(column),\n                  $table: this\n                });\n\n                if (customValid) {\n                  if (XEUtils.isError(customValid)) {\n                    this.validRuleErr = true;\n                    errorRules.push(new Rule({\n                      type: 'custom',\n                      trigger,\n                      message: customValid.message,\n                      rule: new Rule(rule)\n                    }));\n                  } else if (customValid.catch) {\n                    // 如果为异步校验（注：异步校验是并发无序的）\n                    syncVailds.push(customValid.catch(e => {\n                      this.validRuleErr = true;\n                      errorRules.push(new Rule({\n                        type: 'custom',\n                        trigger,\n                        message: e && e.message ? e.message : rule.message,\n                        rule: new Rule(rule)\n                      }));\n                    }));\n                  }\n                }\n              } else {\n                const isArrType = type === 'array';\n                const hasEmpty = isArrType ? !XEUtils.isArray(cellValue) || !cellValue.length : eqEmptyValue(cellValue);\n\n                if (required ? hasEmpty || validErrorRuleValue(rule, cellValue) : !hasEmpty && validErrorRuleValue(rule, cellValue)) {\n                  this.validRuleErr = true;\n                  errorRules.push(new Rule(rule));\n                }\n              }\n            }\n          });\n        }\n      }\n\n      return Promise.all(syncVailds).then(() => {\n        if (errorRules.length) {\n          const rest = {\n            rules: errorRules,\n            rule: errorRules[0]\n          };\n          return Promise.reject(rest);\n        }\n      });\n    },\n\n    _clearValidate() {\n      const validTip = this.$refs.validTip;\n      Object.assign(this.validStore, {\n        visible: false,\n        row: null,\n        column: null,\n        content: '',\n        rule: null\n      });\n\n      if (validTip && validTip.visible) {\n        validTip.close();\n      }\n\n      return this.$nextTick();\n    },\n\n    /**\r\n     * 触发校验\r\n     */\n    triggerValidate(type) {\n      const editConfig = this.editConfig,\n            editStore = this.editStore,\n            editRules = this.editRules,\n            validStore = this.validStore;\n      const actived = editStore.actived;\n\n      if (actived.row && editRules) {\n        const _actived$args = actived.args,\n              row = _actived$args.row,\n              column = _actived$args.column,\n              cell = _actived$args.cell;\n\n        if (this.hasCellRules(type, row, column)) {\n          return this.validCellRules(type, row, column).then(() => {\n            if (editConfig.mode === 'row') {\n              if (validStore.visible && validStore.row === row && validStore.column === column) {\n                this.clearValidate();\n              }\n            }\n          }).catch(_ref2 => {\n            let rule = _ref2.rule; // 如果校验不通过与触发方式一致，则聚焦提示错误，否则跳过并不作任何处理\n\n            if (!rule.trigger || type === rule.trigger) {\n              const rest = {\n                rule,\n                row,\n                column,\n                cell\n              };\n              this.showValidTooltip(rest);\n              return Promise.reject(rest);\n            }\n\n            return Promise.resolve();\n          });\n        }\n      }\n\n      return Promise.resolve();\n    },\n\n    /**\r\n     * 弹出校验错误提示\r\n     */\n    showValidTooltip(params) {\n      const $refs = this.$refs,\n            height = this.height,\n            tableData = this.tableData,\n            validOpts = this.validOpts;\n      const rule = params.rule,\n            row = params.row,\n            column = params.column,\n            cell = params.cell;\n      const validTip = $refs.validTip;\n      const content = rule.message;\n      return this.$nextTick(() => {\n        Object.assign(this.validStore, {\n          row,\n          column,\n          rule,\n          content,\n          visible: true\n        });\n        this.emitEvent('valid-error', params);\n\n        if (validTip && (validOpts.message === 'tooltip' || validOpts.message === 'default' && !height && tableData.length < 2)) {\n          return validTip.open(cell, content);\n        }\n      });\n    }\n\n  }\n};",null]}