{"remainingRequest":"D:\\cdRule\\node_modules\\thread-loader\\dist\\cjs.js!D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js!D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js!D:\\cdRule\\src\\components\\Table\\edit\\src\\mixin.js","dependencies":[{"path":"D:\\cdRule\\src\\components\\Table\\edit\\src\\mixin.js","mtime":1635230121610},{"path":"D:\\cdRule\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\thread-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/web.dom.iterable\";\nimport XEUtils from 'xe-utils';\nimport VXETable from '../../v-x-e-table';\nimport { UtilTools, DomTools, isEnableConf } from '../../tools';\nimport { browse } from '../../tools/src/dom';\nexport default {\n  methods: {\n    /**\r\n     * 往表格中插入临时数据\r\n     *\r\n     * @param {*} records\r\n     */\n    _insert(records) {\n      return this.insertAt(records);\n    },\n\n    /**\r\n     * 往表格指定行中插入临时数据\r\n     * 如果 row 为空则从插入到顶部\r\n     * 如果 row 为 -1 则从插入到底部\r\n     * 如果 row 为有效行则插入到该行的位置\r\n     * @param {Object/Array} records 新的数据\r\n     * @param {Row} row 指定行\r\n     */\n    _insertAt(records, row) {\n      const mergeList = this.mergeList,\n            afterFullData = this.afterFullData,\n            editStore = this.editStore,\n            sYOpts = this.sYOpts,\n            scrollYLoad = this.scrollYLoad,\n            tableFullData = this.tableFullData,\n            treeConfig = this.treeConfig;\n\n      if (!XEUtils.isArray(records)) {\n        records = [records];\n      }\n\n      const newRecords = records.map(record => this.defineField(Object.assign({}, record)));\n\n      if (!row) {\n        afterFullData.unshift(...newRecords);\n        tableFullData.unshift(...newRecords); // 刷新单元格合并\n\n        mergeList.forEach(mergeItem => {\n          const mergeRowIndex = mergeItem.row;\n\n          if (mergeRowIndex > 0) {\n            mergeItem.row = mergeRowIndex + newRecords.length;\n          }\n        });\n      } else {\n        if (row === -1) {\n          afterFullData.push(...newRecords);\n          tableFullData.push(...newRecords); // 刷新单元格合并\n\n          mergeList.forEach(mergeItem => {\n            const mergeRowIndex = mergeItem.row,\n                  mergeRowspan = mergeItem.rowspan;\n\n            if (mergeRowIndex + mergeRowspan > afterFullData.length) {\n              mergeItem.rowspan = mergeRowspan + newRecords.length;\n            }\n          });\n        } else {\n          if (treeConfig) {\n            throw new Error(UtilTools.getLog('vxe.error.noTree', ['insert']));\n          }\n\n          const afIndex = afterFullData.indexOf(row);\n\n          if (afIndex === -1) {\n            throw new Error(UtilTools.error('vxe.error.unableInsert'));\n          }\n\n          afterFullData.splice(afIndex, 0, ...newRecords);\n          tableFullData.splice(tableFullData.indexOf(row), 0, ...newRecords); // 刷新单元格合并\n\n          mergeList.forEach(mergeItem => {\n            const mergeRowIndex = mergeItem.row,\n                  mergeRowspan = mergeItem.rowspan;\n\n            if (mergeRowIndex > afIndex) {\n              mergeItem.row = mergeRowIndex + newRecords.length;\n            } else if (mergeRowIndex + mergeRowspan > afIndex) {\n              mergeItem.rowspan = mergeRowspan + newRecords.length;\n            }\n          });\n        }\n      }\n\n      editStore.insertList.unshift(...newRecords);\n      this.scrollYLoad = !treeConfig && sYOpts.gt > -1 && sYOpts.gt < tableFullData.length;\n      this.handleTableData();\n      this.updateFooter();\n      this.updateCache();\n      this.checkSelectionStatus();\n\n      if (scrollYLoad) {\n        this.updateScrollYSpace();\n      }\n\n      return this.$nextTick().then(() => {\n        this.updateCellAreas();\n        return this.recalculate();\n      }).then(() => {\n        return {\n          row: newRecords.length ? newRecords[newRecords.length - 1] : null,\n          rows: newRecords\n        };\n      });\n    },\n\n    /**\r\n     * 删除指定行数据\r\n     * 如果传 row 则删除一行\r\n     * 如果传 rows 则删除多行\r\n     * 如果为空则删除所有\r\n     */\n    _remove(rows) {\n      const afterFullData = this.afterFullData,\n            tableFullData = this.tableFullData,\n            treeConfig = this.treeConfig,\n            mergeList = this.mergeList,\n            editStore = this.editStore,\n            checkboxOpts = this.checkboxOpts,\n            selection = this.selection,\n            isInsertByRow = this.isInsertByRow,\n            sYOpts = this.sYOpts,\n            scrollYLoad = this.scrollYLoad;\n      const actived = editStore.actived,\n            removeList = editStore.removeList,\n            insertList = editStore.insertList;\n      const property = checkboxOpts.checkField;\n      let rest = [];\n\n      if (!rows) {\n        rows = tableFullData;\n      } else if (!XEUtils.isArray(rows)) {\n        rows = [rows];\n      } // 如果是新增，则保存记录\n\n\n      rows.forEach(row => {\n        if (!isInsertByRow(row)) {\n          removeList.push(row);\n        }\n      }); // 如果绑定了多选属性，则更新状态\n\n      if (!property) {\n        rows.forEach(row => {\n          const sIndex = selection.indexOf(row);\n\n          if (sIndex > -1) {\n            selection.splice(sIndex, 1);\n          }\n        });\n      } // 从数据源中移除\n\n\n      if (tableFullData === rows) {\n        rows = rest = tableFullData.slice(0);\n        this.tableFullData = [];\n        this.afterFullData = [];\n        this.clearMergeCells();\n      } else {\n        rows.forEach(row => {\n          const tfIndex = tableFullData.indexOf(row);\n\n          if (tfIndex > -1) {\n            const rItems = tableFullData.splice(tfIndex, 1);\n            rest.push(rItems[0]);\n          }\n\n          const afIndex = afterFullData.indexOf(row);\n\n          if (afIndex > -1) {\n            // 刷新单元格合并\n            mergeList.forEach(mergeItem => {\n              const mergeRowIndex = mergeItem.row,\n                    mergeRowspan = mergeItem.rowspan;\n\n              if (mergeRowIndex > afIndex) {\n                mergeItem.row = mergeRowIndex - 1;\n              } else if (mergeRowIndex + mergeRowspan > afIndex) {\n                mergeItem.rowspan = mergeRowspan - 1;\n              }\n            });\n            afterFullData.splice(afIndex, 1);\n          }\n        });\n      } // 如果当前行被激活编辑，则清除激活状态\n\n\n      if (actived.row && rows.indexOf(actived.row) > -1) {\n        this.clearActived();\n      } // 从新增中移除已删除的数据\n\n\n      rows.forEach(row => {\n        const iIndex = insertList.indexOf(row);\n\n        if (iIndex > -1) {\n          insertList.splice(iIndex, 1);\n        }\n      });\n      this.scrollYLoad = !treeConfig && sYOpts.gt > -1 && sYOpts.gt < tableFullData.length;\n      this.handleTableData();\n      this.updateFooter();\n      this.updateCache();\n      this.checkSelectionStatus();\n\n      if (scrollYLoad) {\n        this.updateScrollYSpace();\n      }\n\n      return this.$nextTick().then(() => {\n        this.updateCellAreas();\n        return this.recalculate();\n      }).then(() => {\n        return {\n          row: rest.length ? rest[rest.length - 1] : null,\n          rows: rest\n        };\n      });\n    },\n\n    /**\r\n     * 删除复选框选中的数据\r\n     */\n    _removeCheckboxRow() {\n      return this.remove(this.getCheckboxRecords()).then(params => {\n        this.clearCheckboxRow();\n        return params;\n      });\n    },\n\n    /**\r\n     * 删除单选框选中的数据\r\n     */\n    _removeRadioRow() {\n      const radioRecord = this.getRadioRecord();\n      return this.remove(radioRecord || []).then(params => {\n        this.clearRadioRow();\n        return params;\n      });\n    },\n\n    /**\r\n     * 删除当前行选中的数据\r\n     */\n    _removeCurrentRow() {\n      const currentRecord = this.getCurrentRecord();\n      return this.remove(currentRecord || []).then(params => {\n        this.clearCurrentRow();\n        return params;\n      });\n    },\n\n    /**\r\n     * 获取表格数据集，包含新增、删除、修改\r\n     */\n    _getRecordset() {\n      return {\n        insertRecords: this.getInsertRecords(),\n        removeRecords: this.getRemoveRecords(),\n        updateRecords: this.getUpdateRecords()\n      };\n    },\n\n    /**\r\n     * 获取新增的临时数据\r\n     */\n    _getInsertRecords() {\n      const insertList = this.editStore.insertList;\n      const insertRecords = [];\n\n      if (insertList.length) {\n        this.tableFullData.forEach(row => {\n          if (insertList.indexOf(row) > -1) {\n            insertRecords.push(row);\n          }\n        });\n      }\n\n      return insertRecords;\n    },\n\n    /**\r\n     * 获取已删除的数据\r\n     */\n    _getRemoveRecords() {\n      return this.editStore.removeList;\n    },\n\n    /**\r\n     * 获取更新数据\r\n     * 只精准匹配 row 的更改\r\n     * 如果是树表格，子节点更改状态不会影响父节点的更新状态\r\n     */\n    _getUpdateRecords() {\n      const keepSource = this.keepSource,\n            tableFullData = this.tableFullData,\n            isUpdateByRow = this.isUpdateByRow,\n            treeConfig = this.treeConfig,\n            treeOpts = this.treeOpts,\n            editStore = this.editStore;\n\n      if (keepSource) {\n        const actived = editStore.actived;\n        const row = actived.row,\n              column = actived.column;\n\n        if (row || column) {\n          this._syncActivedCell();\n        }\n\n        if (treeConfig) {\n          return XEUtils.filterTree(tableFullData, row => isUpdateByRow(row), treeOpts);\n        }\n\n        return tableFullData.filter(row => isUpdateByRow(row));\n      }\n\n      return [];\n    },\n\n    /**\r\n     * 处理激活编辑\r\n     */\n    handleActived(params, evnt) {\n      const editStore = this.editStore,\n            editOpts = this.editOpts,\n            tableColumn = this.tableColumn,\n            mouseConfig = this.mouseConfig;\n      const mode = editOpts.mode,\n            activeMethod = editOpts.activeMethod;\n      const actived = editStore.actived;\n      const row = params.row,\n            column = params.column;\n      const editRender = column.editRender;\n      const cell = params.cell = params.cell || this.getCell(row, column);\n\n      if (isEnableConf(editRender) && cell) {\n        if (actived.row !== row || (mode === 'cell' ? actived.column !== column : false)) {\n          // 判断是否禁用编辑\n          let type = 'edit-disabled';\n\n          if (!activeMethod || activeMethod(params)) {\n            if (mouseConfig) {\n              this.clearSelected(evnt);\n              this.clearCellAreas(evnt);\n              this.clearCopyCellArea(evnt);\n            }\n\n            this.closeTooltip();\n            this.clearActived(evnt);\n            type = 'edit-actived';\n            column.renderHeight = cell.offsetHeight;\n            actived.args = params;\n            actived.row = row;\n            actived.column = column;\n\n            if (mode === 'row') {\n              tableColumn.forEach(column => this._getColumnModel(row, column));\n            } else {\n              this._getColumnModel(row, column);\n            }\n\n            this.$nextTick(() => {\n              this.handleFocus(params, evnt);\n            });\n          }\n\n          this.emitEvent(type, {\n            row,\n            rowIndex: this.getRowIndex(row),\n            $rowIndex: this.getVMRowIndex(row),\n            column,\n            columnIndex: this.getColumnIndex(column),\n            $columnIndex: this.getVMColumnIndex(column)\n          }, evnt);\n        } else {\n          const oldColumn = actived.column;\n\n          if (mouseConfig) {\n            this.clearSelected(evnt);\n            this.clearCellAreas(evnt);\n            this.clearCopyCellArea(evnt);\n          }\n\n          if (oldColumn !== column) {\n            const oldModel = oldColumn.model;\n\n            if (oldModel.update) {\n              UtilTools.setCellValue(row, oldColumn, oldModel.value);\n            }\n\n            this.clearValidate();\n          }\n\n          column.renderHeight = cell.offsetHeight;\n          actived.args = params;\n          actived.column = column;\n          setTimeout(() => {\n            this.handleFocus(params, evnt);\n          });\n        }\n\n        this.focus();\n      }\n\n      return this.$nextTick();\n    },\n\n    _getColumnModel(row, column) {\n      const model = column.model,\n            editRender = column.editRender;\n\n      if (editRender) {\n        model.value = UtilTools.getCellValue(row, column);\n        model.update = false;\n      }\n    },\n\n    _setColumnModel(row, column) {\n      const model = column.model,\n            editRender = column.editRender;\n\n      if (editRender && model.update) {\n        UtilTools.setCellValue(row, column, model.value);\n        model.update = false;\n        model.value = null;\n      }\n    },\n\n    _syncActivedCell() {\n      const tableColumn = this.tableColumn,\n            editStore = this.editStore,\n            editOpts = this.editOpts;\n      const actived = editStore.actived;\n      const row = actived.row,\n            column = actived.column;\n\n      if (row || column) {\n        if (editOpts.mode === 'row') {\n          tableColumn.forEach(column => this._setColumnModel(row, column));\n        } else {\n          this._setColumnModel(row, column);\n        }\n      }\n    },\n\n    /**\r\n     * 清除激活的编辑\r\n     */\n    _clearActived(evnt) {\n      const editStore = this.editStore;\n      const actived = editStore.actived;\n      const row = actived.row,\n            column = actived.column;\n\n      if (row || column) {\n        this._syncActivedCell();\n\n        actived.args = null;\n        actived.row = null;\n        actived.column = null;\n        this.updateFooter();\n        this.emitEvent('edit-closed', {\n          row,\n          rowIndex: this.getRowIndex(row),\n          $rowIndex: this.getVMRowIndex(row),\n          column,\n          columnIndex: this.getColumnIndex(column),\n          $columnIndex: this.getVMColumnIndex(column)\n        }, evnt);\n      }\n\n      return (VXETable._valid ? this.clearValidate() : this.$nextTick()).then(this.recalculate);\n    },\n\n    _getActiveRecord() {\n      const $el = this.$el,\n            editStore = this.editStore,\n            afterFullData = this.afterFullData;\n      const actived = editStore.actived;\n      const args = actived.args,\n            row = actived.row;\n\n      if (args && afterFullData.indexOf(row) > -1 && $el.querySelectorAll('.vxe-body--column.col--actived').length) {\n        return Object.assign({}, args);\n      }\n\n      return null;\n    },\n\n    /**\r\n     * 判断行是否为激活编辑状态\r\n     * @param {Row} row 行对象\r\n     */\n    _isActiveByRow(row) {\n      return this.editStore.actived.row === row;\n    },\n\n    /**\r\n     * 处理聚焦\r\n     */\n    handleFocus(params) {\n      const row = params.row,\n            column = params.column,\n            cell = params.cell;\n      const editRender = column.editRender;\n\n      if (isEnableConf(editRender)) {\n        const compRender = VXETable.renderer.get(editRender.name);\n        const autofocus = editRender.autofocus,\n              autoselect = editRender.autoselect;\n        let inputElem; // 如果指定了聚焦 class\n\n        if (autofocus) {\n          inputElem = cell.querySelector(autofocus);\n        } // 渲染器的聚焦处理\n\n\n        if (!inputElem && compRender && compRender.autofocus) {\n          inputElem = cell.querySelector(compRender.autofocus);\n        }\n\n        if (inputElem) {\n          inputElem.focus();\n\n          if (autoselect) {\n            inputElem.select();\n          } else {\n            // 保持一致行为，光标移到末端\n            if (browse.msie) {\n              const textRange = inputElem.createTextRange();\n              textRange.collapse(false);\n              textRange.select();\n            }\n          }\n        } else {\n          // 显示到可视区中\n          this.scrollToRow(row, column);\n        }\n      }\n    },\n\n    /**\r\n     * 激活行编辑\r\n     */\n    _setActiveRow(row) {\n      return this.setActiveCell(row, XEUtils.find(this.visibleColumn, column => isEnableConf(column.editRender)));\n    },\n\n    /**\r\n     * 激活单元格编辑\r\n     */\n    _setActiveCell(row, fieldOrColumn) {\n      const column = XEUtils.isString(fieldOrColumn) ? this.getColumnByField(fieldOrColumn) : fieldOrColumn;\n\n      if (row && column && isEnableConf(column.editRender)) {\n        return this.scrollToRow(row, true).then(() => {\n          const cell = this.getCell(row, column);\n\n          if (cell) {\n            this.handleActived({\n              row,\n              rowIndex: this.getRowIndex(row),\n              column,\n              columnIndex: this.getColumnIndex(column),\n              cell,\n              $table: this\n            });\n            this.lastCallTime = Date.now();\n          }\n        });\n      }\n\n      return this.$nextTick();\n    },\n\n    /**\r\n     * 只对 trigger=dblclick 有效，选中单元格\r\n     */\n    _setSelectCell(row, fieldOrColumn) {\n      const tableData = this.tableData,\n            editOpts = this.editOpts,\n            visibleColumn = this.visibleColumn;\n      const column = XEUtils.isString(fieldOrColumn) ? this.getColumnByField(fieldOrColumn) : fieldOrColumn;\n\n      if (row && column && editOpts.trigger !== 'manual') {\n        const rowIndex = tableData.indexOf(row);\n\n        if (rowIndex > -1) {\n          const cell = this.getCell(row, column);\n          const params = {\n            row,\n            rowIndex,\n            column,\n            columnIndex: visibleColumn.indexOf(column),\n            cell\n          };\n          this.handleSelected(params, {});\n        }\n      }\n\n      return this.$nextTick();\n    },\n\n    /**\r\n     * 处理选中源\r\n     */\n    handleSelected(params, evnt) {\n      const mouseConfig = this.mouseConfig,\n            mouseOpts = this.mouseOpts,\n            editOpts = this.editOpts,\n            editStore = this.editStore;\n      const actived = editStore.actived,\n            selected = editStore.selected;\n      const row = params.row,\n            column = params.column;\n      const isMouseSelected = mouseConfig && mouseOpts.selected;\n\n      const selectMethod = () => {\n        if (isMouseSelected && (selected.row !== row || selected.column !== column)) {\n          if (actived.row !== row || (editOpts.mode === 'cell' ? actived.column !== column : false)) {\n            this.clearActived(evnt);\n            this.clearSelected(evnt);\n            this.clearCellAreas(evnt);\n            this.clearCopyCellArea(evnt);\n            selected.args = params;\n            selected.row = row;\n            selected.column = column;\n\n            if (isMouseSelected) {\n              this.addColSdCls();\n            }\n\n            this.focus();\n\n            if (evnt) {\n              this.emitEvent('cell-selected', params, evnt);\n            }\n          }\n        }\n\n        return this.$nextTick();\n      };\n\n      return selectMethod();\n    },\n\n    /**\r\n     * 获取选中的单元格\r\n     */\n    _getSelectedCell() {\n      const _this$editStore$selec = this.editStore.selected,\n            args = _this$editStore$selec.args,\n            column = _this$editStore$selec.column;\n\n      if (args && column) {\n        return Object.assign({}, args);\n      }\n\n      return null;\n    },\n\n    /**\r\n     * 清除所选中源状态\r\n     */\n    _clearSelected() {\n      const selected = this.editStore.selected;\n      selected.row = null;\n      selected.column = null;\n      this.reColTitleSdCls();\n      this.reColSdCls();\n      return this.$nextTick();\n    },\n\n    reColTitleSdCls() {\n      const headerElem = this.elemStore['main-header-list'];\n\n      if (headerElem) {\n        XEUtils.arrayEach(headerElem.querySelectorAll('.col--title-selected'), elem => DomTools.removeClass(elem, 'col--title-selected'));\n      }\n    },\n\n    reColSdCls() {\n      const cell = this.$el.querySelector('.col--selected');\n\n      if (cell) {\n        DomTools.removeClass(cell, 'col--selected');\n      }\n    },\n\n    addColSdCls() {\n      const selected = this.editStore.selected;\n      const row = selected.row,\n            column = selected.column;\n      this.reColSdCls();\n\n      if (row && column) {\n        const cell = this.getCell(row, column);\n\n        if (cell) {\n          DomTools.addClass(cell, 'col--selected');\n        }\n      }\n    }\n\n  }\n};",null]}