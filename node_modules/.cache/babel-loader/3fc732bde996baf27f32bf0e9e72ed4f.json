{"remainingRequest":"D:\\cdRule\\node_modules\\thread-loader\\dist\\cjs.js!D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js!D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js!D:\\cdRule\\src\\components\\Table\\select\\src\\select.js","dependencies":[{"path":"D:\\cdRule\\src\\components\\Table\\select\\src\\select.js","mtime":1657011267820},{"path":"D:\\cdRule\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\thread-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.regexp.to-string\";\nimport XEUtils from 'xe-utils';\nimport VxeInput from '../../input/src/input';\nimport GlobalConfig from '../../v-x-e-table/src/conf';\nimport vSize from '../../mixins/size';\nimport { UtilTools, DomTools, GlobalEvent } from '../../tools';\n\nfunction isOptionVisible(option) {\n  return option.visible !== false;\n}\n\nfunction getOptUniqueId() {\n  return XEUtils.uniqueId('opt_');\n}\n\nfunction getOptkey(_vm) {\n  return _vm.optionId || '_XID';\n}\n\nfunction getOptid(_vm, option) {\n  const optid = option[getOptkey(_vm)];\n  return optid ? encodeURIComponent(optid) : '';\n}\n\nfunction findOffsetOption(_vm, optionValue, isUpArrow) {\n  const isGroup = _vm.isGroup,\n        visibleOptionList = _vm.visibleOptionList,\n        visibleGroupList = _vm.visibleGroupList,\n        valueField = _vm.valueField,\n        groupOptionsField = _vm.groupOptionsField;\n  let firstOption;\n  let prevOption;\n  let nextOption;\n  let currOption;\n\n  if (isGroup) {\n    for (let gIndex = 0; gIndex < visibleGroupList.length; gIndex++) {\n      const group = visibleGroupList[gIndex];\n      const groupOptionList = group[groupOptionsField];\n      const isGroupDisabled = group.disabled;\n\n      if (groupOptionList) {\n        for (let index = 0; index < groupOptionList.length; index++) {\n          const option = groupOptionList[index];\n          const isVisible = isOptionVisible(option);\n          const isDisabled = isGroupDisabled || option.disabled;\n\n          if (!firstOption && !isDisabled) {\n            firstOption = option;\n          }\n\n          if (currOption) {\n            if (isVisible && !isDisabled) {\n              nextOption = option;\n\n              if (!isUpArrow) {\n                return {\n                  offsetOption: nextOption\n                };\n              }\n            }\n          }\n\n          if (optionValue === option[valueField]) {\n            currOption = option;\n\n            if (isUpArrow) {\n              return {\n                offsetOption: prevOption\n              };\n            }\n          } else {\n            if (isVisible && !isDisabled) {\n              prevOption = option;\n            }\n          }\n        }\n      }\n    }\n  } else {\n    for (let index = 0; index < visibleOptionList.length; index++) {\n      const option = visibleOptionList[index];\n      const isDisabled = option.disabled;\n\n      if (!firstOption && !isDisabled) {\n        firstOption = option;\n      }\n\n      if (currOption) {\n        if (!isDisabled) {\n          nextOption = option;\n\n          if (!isUpArrow) {\n            return {\n              offsetOption: nextOption\n            };\n          }\n        }\n      }\n\n      if (optionValue === option[valueField]) {\n        currOption = option;\n\n        if (isUpArrow) {\n          return {\n            offsetOption: prevOption\n          };\n        }\n      } else {\n        if (!isDisabled) {\n          prevOption = option;\n        }\n      }\n    }\n  }\n\n  return {\n    firstOption\n  };\n}\n\nfunction findOption(_vm, optionValue) {\n  const isGroup = _vm.isGroup,\n        fullOptionList = _vm.fullOptionList,\n        fullGroupList = _vm.fullGroupList,\n        valueField = _vm.valueField;\n\n  if (isGroup) {\n    for (let gIndex = 0; gIndex < fullGroupList.length; gIndex++) {\n      const group = fullGroupList[gIndex];\n\n      if (group.options) {\n        for (let index = 0; index < group.options.length; index++) {\n          const option = group.options[index];\n\n          if (optionValue === option[valueField]) {\n            return option;\n          }\n        }\n      }\n    }\n  }\n\n  return fullOptionList.find(item => optionValue === item[valueField]);\n}\n\nfunction getSelectLabel(_vm, value) {\n  const item = findOption(_vm, value);\n  return XEUtils.toString(item ? item[_vm.labelField] : value);\n}\n\nexport function renderOption(h, _vm, list, group) {\n  const isGroup = _vm.isGroup,\n        labelField = _vm.labelField,\n        valueField = _vm.valueField,\n        optionKey = _vm.optionKey,\n        value = _vm.value,\n        multiple = _vm.multiple,\n        currentValue = _vm.currentValue;\n  return list.map((option, cIndex) => {\n    const isVisible = !isGroup || isOptionVisible(option);\n    const isDisabled = group && group.disabled || option.disabled;\n    const optionValue = option[valueField];\n    const optid = getOptid(_vm, option);\n    return isVisible ? h('div', {\n      key: optionKey ? optid : cIndex,\n      class: ['vxe-select-option', option.className, {\n        'is--disabled': isDisabled,\n        'is--selected': multiple ? value && value.indexOf(optionValue) > -1 : value === optionValue,\n        'is--hover': currentValue === optionValue\n      }],\n      attrs: {\n        optid: optid\n      },\n      on: {\n        mousedown: _vm.mousedownOptionEvent,\n        click: evnt => {\n          if (!isDisabled) {\n            _vm.changeOptionEvent(evnt, optionValue);\n          }\n        },\n        mouseenter: () => {\n          if (!isDisabled) {\n            _vm.setCurrentOption(option);\n          }\n        }\n      }\n    }, UtilTools.formatText(UtilTools.getFuncText(option[labelField]))) : null;\n  });\n}\nexport function renderOptgroup(h, _vm) {\n  const optionKey = _vm.optionKey,\n        visibleGroupList = _vm.visibleGroupList,\n        groupLabelField = _vm.groupLabelField,\n        groupOptionsField = _vm.groupOptionsField;\n  return visibleGroupList.map((group, gIndex) => {\n    const optid = getOptid(_vm, group);\n    const isGroupDisabled = group.disabled;\n    return h('div', {\n      key: optionKey ? optid : gIndex,\n      class: ['vxe-optgroup', group.className, {\n        'is--disabled': isGroupDisabled\n      }],\n      attrs: {\n        optid: optid\n      }\n    }, [h('div', {\n      class: 'vxe-optgroup--title'\n    }, UtilTools.getFuncText(group[groupLabelField])), h('div', {\n      class: 'vxe-optgroup--wrapper'\n    }, renderOption(h, _vm, group[groupOptionsField], group))]);\n  });\n}\n\nfunction renderOpts(h, _vm) {\n  const isGroup = _vm.isGroup,\n        visibleGroupList = _vm.visibleGroupList,\n        visibleOptionList = _vm.visibleOptionList;\n\n  if (isGroup) {\n    if (visibleGroupList.length) {\n      return renderOptgroup(h, _vm);\n    }\n  } else {\n    if (visibleOptionList.length) {\n      return renderOption(h, _vm, visibleOptionList);\n    }\n  }\n\n  return [h('div', {\n    class: 'vxe-select--empty-placeholder'\n  }, _vm.emptyText || GlobalConfig.i18n('vxe.select.emptyText'))];\n}\n\nexport default {\n  name: 'VxeSelect',\n  mixins: [vSize],\n  props: {\n    value: null,\n    clearable: Boolean,\n    placeholder: String,\n    loading: Boolean,\n    disabled: Boolean,\n    multiple: Boolean,\n    multiCharOverflow: {\n      type: [Number, String],\n      default: () => GlobalConfig.select.multiCharOverflow\n    },\n    prefixIcon: String,\n    placement: String,\n    options: Array,\n    optionProps: Object,\n    optionGroups: Array,\n    optionGroupProps: Object,\n    className: [String, Function],\n    size: {\n      type: String,\n      default: () => GlobalConfig.select.size || GlobalConfig.size\n    },\n    emptyText: String,\n    optionId: {\n      type: String,\n      default: () => GlobalConfig.select.optionId\n    },\n    optionKey: Boolean,\n    transfer: {\n      type: Boolean,\n      default: () => GlobalConfig.select.transfer\n    }\n  },\n  components: {\n    VxeInput\n  },\n\n  provide() {\n    return {\n      $xeselect: this\n    };\n  },\n\n  data() {\n    return {\n      inited: false,\n      collectOption: [],\n      fullGroupList: [],\n      fullOptionList: [],\n      visibleGroupList: [],\n      visibleOptionList: [],\n      panelIndex: 0,\n      panelStyle: null,\n      panelPlacement: null,\n      currentValue: null,\n      visiblePanel: false,\n      animatVisible: false,\n      isActivated: false\n    };\n  },\n\n  computed: {\n    propsOpts() {\n      return this.optionProps || {};\n    },\n\n    groupPropsOpts() {\n      return this.optionGroupProps || {};\n    },\n\n    labelField() {\n      return this.propsOpts.label || 'label';\n    },\n\n    valueField() {\n      return this.propsOpts.value || 'value';\n    },\n\n    groupLabelField() {\n      return this.groupPropsOpts.label || 'label';\n    },\n\n    groupOptionsField() {\n      return this.groupPropsOpts.options || 'options';\n    },\n\n    isGroup() {\n      return this.fullGroupList.some(item => item.options && item.options.length);\n    },\n\n    multiMaxCharNum() {\n      return XEUtils.toNumber(this.multiCharOverflow);\n    },\n\n    selectLabel() {\n      const value = this.value,\n            multiple = this.multiple,\n            multiMaxCharNum = this.multiMaxCharNum;\n\n      if (value && multiple) {\n        return value.map(val => {\n          const label = getSelectLabel(this, val);\n\n          if (multiMaxCharNum > 0 && label.length > multiMaxCharNum) {\n            return `${label.substring(0, multiMaxCharNum)}...`;\n          }\n\n          return label;\n        }).join(', ');\n      }\n\n      return getSelectLabel(this, value);\n    }\n\n  },\n  watch: {\n    collectOption(value) {\n      if (value.some(item => item.options && item.options.length)) {\n        this.fullOptionList = [];\n        this.fullGroupList = value;\n      } else {\n        this.fullGroupList = [];\n        this.fullOptionList = value;\n      }\n\n      this.updateCache();\n    },\n\n    options(value) {\n      this.fullGroupList = [];\n      this.fullOptionList = value;\n      this.updateCache();\n    },\n\n    optionGroups(value) {\n      this.fullOptionList = [];\n      this.fullGroupList = value;\n      this.updateCache();\n    }\n\n  },\n\n  created() {\n    const options = this.options,\n          optionGroups = this.optionGroups;\n\n    if (optionGroups) {\n      this.fullGroupList = optionGroups;\n    } else if (options) {\n      this.fullOptionList = options;\n    }\n\n    this.updateCache();\n    GlobalEvent.on(this, 'mousewheel', this.handleGlobalMousewheelEvent);\n    GlobalEvent.on(this, 'mousedown', this.handleGlobalMousedownEvent);\n    GlobalEvent.on(this, 'keydown', this.handleGlobalKeydownEvent);\n    GlobalEvent.on(this, 'blur', this.handleGlobalBlurEvent);\n  },\n\n  beforeDestroy() {\n    const panelElem = this.$refs.panel;\n\n    if (panelElem && panelElem.parentNode) {\n      panelElem.parentNode.removeChild(panelElem);\n    }\n  },\n\n  destroyed() {\n    GlobalEvent.off(this, 'mousewheel');\n    GlobalEvent.off(this, 'mousedown');\n    GlobalEvent.off(this, 'keydown');\n    GlobalEvent.off(this, 'blur');\n  },\n\n  render(h) {\n    const $scopedSlots = this.$scopedSlots,\n          vSize = this.vSize,\n          className = this.className,\n          inited = this.inited,\n          isActivated = this.isActivated,\n          loading = this.loading,\n          disabled = this.disabled,\n          visiblePanel = this.visiblePanel;\n    const prefixSlot = $scopedSlots.prefix;\n    return h('div', {\n      class: ['vxe-select', className ? XEUtils.isFunction(className) ? className({\n        $select: this\n      }) : className : '', {\n        [`size--${vSize}`]: vSize,\n        'is--visivle': visiblePanel,\n        'is--disabled': disabled,\n        'is--active': isActivated\n      }]\n    }, [h('div', {\n      class: 'vxe-select-slots',\n      ref: 'hideOption'\n    }, this.$slots.default), h('vxe-input', {\n      ref: 'input',\n      props: {\n        clearable: this.clearable,\n        placeholder: this.placeholder,\n        readonly: true,\n        disabled: disabled,\n        type: 'text',\n        prefixIcon: this.prefixIcon,\n        suffixIcon: loading ? GlobalConfig.icon.SELECT_LOADED : visiblePanel ? GlobalConfig.icon.SELECT_OPEN : GlobalConfig.icon.SELECT_CLOSE,\n        value: this.selectLabel\n      },\n      on: {\n        clear: this.clearEvent,\n        click: this.togglePanelEvent,\n        focus: this.focusEvent,\n        blur: this.blurEvent,\n        'suffix-click': this.togglePanelEvent\n      },\n      scopedSlots: prefixSlot ? {\n        prefix: () => prefixSlot({})\n      } : {}\n    }), h('div', {\n      ref: 'panel',\n      class: ['vxe-table--ignore-clear vxe-select--panel', {\n        [`size--${vSize}`]: vSize,\n        'is--transfer': this.transfer,\n        'animat--leave': !loading && this.animatVisible,\n        'animat--enter': !loading && visiblePanel\n      }],\n      attrs: {\n        placement: this.panelPlacement\n      },\n      style: this.panelStyle\n    }, inited ? [h('div', {\n      ref: 'optWrapper',\n      class: 'vxe-select-option--wrapper'\n    }, renderOpts(h, this))] : null)]);\n  },\n\n  methods: {\n    updateCache() {\n      const fullOptionList = this.fullOptionList,\n            fullGroupList = this.fullGroupList,\n            groupOptionsField = this.groupOptionsField;\n      const optkey = getOptkey(this);\n\n      const handleOptis = item => {\n        if (!getOptid(this, item)) {\n          item[optkey] = getOptUniqueId();\n        }\n      };\n\n      if (fullGroupList.length) {\n        fullGroupList.forEach(group => {\n          handleOptis(group);\n\n          if (group[groupOptionsField]) {\n            group[groupOptionsField].forEach(handleOptis);\n          }\n        });\n      } else if (fullOptionList.length) {\n        fullOptionList.forEach(handleOptis);\n      }\n\n      this.refreshOption();\n    },\n\n    /**\r\n     * 刷新选项，当选项被动态显示/隐藏时可能会用到\r\n     */\n    refreshOption() {\n      const isGroup = this.isGroup,\n            fullOptionList = this.fullOptionList,\n            fullGroupList = this.fullGroupList;\n\n      if (isGroup) {\n        this.visibleGroupList = fullGroupList.filter(isOptionVisible);\n      } else {\n        this.visibleOptionList = fullOptionList.filter(isOptionVisible);\n      }\n\n      return this.$nextTick();\n    },\n\n    setCurrentOption(option) {\n      if (option) {\n        this.currentValue = option[this.valueField];\n      }\n    },\n\n    scrollToOption(option, isAlignBottom) {\n      return this.$nextTick().then(() => {\n        if (option) {\n          const $refs = this.$refs;\n          const optWrapperElem = $refs.optWrapper;\n          const optElem = $refs.panel.querySelector(`[optid='${getOptid(this, option)}']`);\n\n          if (optWrapperElem && optElem) {\n            const wrapperHeight = optWrapperElem.offsetHeight;\n            const offsetPadding = 5;\n\n            if (isAlignBottom) {\n              if (optElem.offsetTop + optElem.offsetHeight - optWrapperElem.scrollTop > wrapperHeight) {\n                optWrapperElem.scrollTop = optElem.offsetTop + optElem.offsetHeight - wrapperHeight;\n              }\n            } else {\n              if (optElem.offsetTop + offsetPadding < optWrapperElem.scrollTop || optElem.offsetTop + offsetPadding > optWrapperElem.scrollTop + optWrapperElem.clientHeight) {\n                optWrapperElem.scrollTop = optElem.offsetTop - offsetPadding;\n              }\n            }\n          }\n        }\n      });\n    },\n\n    clearEvent(params, evnt) {\n      this.clearValueEvent(evnt, null);\n      this.hideOptionPanel();\n    },\n\n    clearValueEvent(evnt, selectValue) {\n      this.changeEvent(evnt, selectValue);\n      this.$emit('clear', {\n        value: selectValue,\n        $event: evnt\n      });\n    },\n\n    changeEvent(evnt, selectValue) {\n      if (selectValue !== this.value) {\n        this.$emit('input', selectValue);\n        this.$emit('change', {\n          value: selectValue,\n          $event: evnt\n        });\n      }\n    },\n\n    mousedownOptionEvent(evnt) {\n      const isLeftBtn = evnt.button === 0;\n\n      if (isLeftBtn) {\n        evnt.stopPropagation();\n      }\n    },\n\n    changeOptionEvent(evnt, selectValue) {\n      const value = this.value,\n            multiple = this.multiple;\n\n      if (multiple) {\n        let multipleValue;\n\n        if (value) {\n          if (value.indexOf(selectValue) === -1) {\n            multipleValue = value.concat([selectValue]);\n          } else {\n            multipleValue = value.filter(val => val !== selectValue);\n          }\n        } else {\n          multipleValue = [selectValue];\n        }\n\n        this.changeEvent(evnt, multipleValue);\n      } else {\n        this.changeEvent(evnt, selectValue);\n        this.hideOptionPanel();\n      }\n    },\n\n    handleGlobalMousewheelEvent(evnt) {\n      const $refs = this.$refs,\n            disabled = this.disabled,\n            visiblePanel = this.visiblePanel;\n\n      if (!disabled) {\n        if (visiblePanel) {\n          if (DomTools.getEventTargetNode(evnt, $refs.panel).flag) {\n            this.updatePlacement();\n          } else {\n            this.hideOptionPanel();\n          }\n        }\n      }\n    },\n\n    handleGlobalMousedownEvent(evnt) {\n      const $refs = this.$refs,\n            $el = this.$el,\n            disabled = this.disabled,\n            visiblePanel = this.visiblePanel;\n\n      if (!disabled) {\n        this.isActivated = DomTools.getEventTargetNode(evnt, $el).flag || DomTools.getEventTargetNode(evnt, $refs.panel).flag;\n\n        if (visiblePanel && !this.isActivated) {\n          this.hideOptionPanel();\n        }\n      }\n    },\n\n    handleGlobalKeydownEvent(evnt) {\n      const visiblePanel = this.visiblePanel,\n            currentValue = this.currentValue,\n            clearable = this.clearable,\n            disabled = this.disabled;\n\n      if (!disabled) {\n        const keyCode = evnt.keyCode;\n        const isTab = keyCode === 9;\n        const isEnter = keyCode === 13;\n        const isEsc = keyCode === 27;\n        const isUpArrow = keyCode === 38;\n        const isDwArrow = keyCode === 40;\n        const isDel = keyCode === 46;\n        const isSpacebar = keyCode === 32;\n\n        if (isTab) {\n          this.isActivated = false;\n        }\n\n        if (visiblePanel) {\n          if (isEsc || isTab) {\n            this.hideOptionPanel();\n          } else if (isEnter) {\n            evnt.preventDefault();\n            evnt.stopPropagation();\n            this.changeOptionEvent(evnt, currentValue);\n          } else if (isUpArrow || isDwArrow) {\n            evnt.preventDefault();\n\n            let _findOffsetOption = findOffsetOption(this, currentValue, isUpArrow),\n                firstOption = _findOffsetOption.firstOption,\n                offsetOption = _findOffsetOption.offsetOption;\n\n            if (!offsetOption && !findOption(this, currentValue)) {\n              offsetOption = firstOption;\n            }\n\n            this.setCurrentOption(offsetOption);\n            this.scrollToOption(offsetOption, isDwArrow);\n          } else if (isSpacebar) {\n            evnt.preventDefault();\n          }\n        } else if ((isUpArrow || isDwArrow || isEnter || isSpacebar) && this.isActivated) {\n          evnt.preventDefault();\n          this.showOptionPanel();\n        }\n\n        if (this.isActivated) {\n          if (isDel && clearable) {\n            this.clearValueEvent(evnt, null);\n          }\n        }\n      }\n    },\n\n    handleGlobalBlurEvent() {\n      this.hideOptionPanel();\n    },\n\n    updateZindex() {\n      if (this.panelIndex < UtilTools.getLastZIndex()) {\n        this.panelIndex = UtilTools.nextZIndex();\n      }\n    },\n\n    focusEvent() {\n      if (!this.disabled) {\n        this.isActivated = true;\n      }\n    },\n\n    blurEvent() {\n      this.isActivated = false;\n    },\n\n    isPanelVisible() {\n      return this.visiblePanel;\n    },\n\n    togglePanel() {\n      if (this.visiblePanel) {\n        this.hideOptionPanel();\n      } else {\n        this.showOptionPanel();\n      }\n\n      this.$nextTick();\n    },\n\n    hidePanel() {\n      if (this.visiblePanel) {\n        this.hideOptionPanel();\n      }\n\n      this.$nextTick();\n    },\n\n    showPanel() {\n      if (!this.visiblePanel) {\n        this.showOptionPanel();\n      }\n\n      this.$nextTick();\n    },\n\n    togglePanelEvent(params) {\n      const $event = params.$event;\n      $event.preventDefault();\n\n      if (this.visiblePanel) {\n        this.hideOptionPanel();\n      } else {\n        this.showOptionPanel();\n      }\n    },\n\n    showOptionPanel() {\n      const loading = this.loading,\n            disabled = this.disabled;\n\n      if (!loading && !disabled) {\n        clearTimeout(this.hidePanelTimeout);\n\n        if (!this.inited) {\n          this.inited = true;\n\n          if (this.transfer) {\n            document.body.appendChild(this.$refs.panel);\n          }\n        }\n\n        this.isActivated = true;\n        this.animatVisible = true;\n        setTimeout(() => {\n          const value = this.value,\n                multiple = this.multiple;\n          const currOption = findOption(this, multiple && value ? value[0] : value);\n          this.visiblePanel = true;\n\n          if (currOption) {\n            this.setCurrentOption(currOption);\n            this.scrollToOption(currOption);\n          }\n        }, 10);\n        this.updateZindex();\n        this.updatePlacement();\n      }\n    },\n\n    hideOptionPanel() {\n      this.visiblePanel = false;\n      this.hidePanelTimeout = setTimeout(() => {\n        this.animatVisible = false;\n      }, 350);\n    },\n\n    updatePlacement() {\n      return this.$nextTick().then(() => {\n        const $refs = this.$refs,\n              transfer = this.transfer,\n              placement = this.placement,\n              panelIndex = this.panelIndex;\n        const targetElem = $refs.input.$el;\n        const panelElem = $refs.panel;\n\n        if (panelElem && targetElem) {\n          const targetHeight = targetElem.offsetHeight;\n          const targetWidth = targetElem.offsetWidth;\n          const panelHeight = panelElem.offsetHeight;\n          const panelWidth = panelElem.offsetWidth;\n          const marginSize = 5;\n          const panelStyle = {\n            zIndex: panelIndex\n          };\n\n          const _DomTools$getAbsolute = DomTools.getAbsolutePos(targetElem),\n                boundingTop = _DomTools$getAbsolute.boundingTop,\n                boundingLeft = _DomTools$getAbsolute.boundingLeft,\n                visibleHeight = _DomTools$getAbsolute.visibleHeight,\n                visibleWidth = _DomTools$getAbsolute.visibleWidth;\n\n          let panelPlacement = 'bottom';\n\n          if (transfer) {\n            let left = boundingLeft;\n            let top = boundingTop + targetHeight;\n\n            if (placement === 'top') {\n              panelPlacement = 'top';\n              top = boundingTop - panelHeight;\n            } else if (!placement) {\n              // 如果下面不够放，则向上\n              if (top + panelHeight + marginSize > visibleHeight) {\n                panelPlacement = 'top';\n                top = boundingTop - panelHeight;\n              } // 如果上面不够放，则向下（优先）\n\n\n              if (top < marginSize) {\n                panelPlacement = 'bottom';\n                top = boundingTop + targetHeight;\n              }\n            } // 如果溢出右边\n\n\n            if (left + panelWidth + marginSize > visibleWidth) {\n              left -= left + panelWidth + marginSize - visibleWidth;\n            } // 如果溢出左边\n\n\n            if (left < marginSize) {\n              left = marginSize;\n            }\n\n            Object.assign(panelStyle, {\n              left: `${left}px`,\n              top: `${top}px`,\n              minWidth: `${targetWidth}px`\n            });\n          } else {\n            if (placement === 'top') {\n              panelPlacement = 'top';\n              panelStyle.bottom = `${targetHeight}px`;\n            } else if (!placement) {\n              // 如果下面不够放，则向上\n              if (boundingTop + targetHeight + panelHeight > visibleHeight) {\n                // 如果上面不够放，则向下（优先）\n                if (boundingTop - targetHeight - panelHeight > marginSize) {\n                  panelPlacement = 'top';\n                  panelStyle.bottom = `${targetHeight}px`;\n                }\n              }\n            }\n          }\n\n          this.panelStyle = panelStyle;\n          this.panelPlacement = panelPlacement;\n          return this.$nextTick();\n        }\n      });\n    },\n\n    focus() {\n      this.isActivated = true;\n      this.$refs.input.focus();\n      return this.$nextTick();\n    },\n\n    blur() {\n      this.hideOptionPanel();\n      this.$refs.input.blur();\n      return this.$nextTick();\n    }\n\n  }\n};",null]}