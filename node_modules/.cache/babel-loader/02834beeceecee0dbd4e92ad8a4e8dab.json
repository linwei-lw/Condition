{"remainingRequest":"D:\\cdRule\\node_modules\\thread-loader\\dist\\cjs.js!D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js!D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js!D:\\cdRule\\src\\components\\Table\\header\\src\\header.js","dependencies":[{"path":"D:\\cdRule\\src\\components\\Table\\header\\src\\header.js","mtime":1647229117814},{"path":"D:\\cdRule\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\thread-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.string.fixed\";\nimport \"core-js/modules/es6.string.fixed\";\nimport XEUtils from 'xe-utils';\nimport { UtilTools, DomTools } from '../../tools';\nimport { convertToRows } from './util';\nimport { getColMinWidth } from '../../table/src/util';\nconst cellType = 'header';\nexport default {\n  name: 'VxeTableHeader',\n  props: {\n    tableData: Array,\n    tableColumn: Array,\n    tableGroupColumn: Array,\n    fixedColumn: Array,\n    size: String,\n    fixedType: String\n  },\n\n  data() {\n    return {\n      headerColumn: []\n    };\n  },\n\n  watch: {\n    tableColumn() {\n      this.uploadColumn();\n    }\n\n  },\n\n  created() {\n    this.uploadColumn();\n  },\n\n  mounted() {\n    const $xetable = this.$parent,\n          $el = this.$el,\n          $refs = this.$refs,\n          fixedType = this.fixedType;\n    const elemStore = $xetable.elemStore;\n    const prefix = `${fixedType || 'main'}-header-`;\n    elemStore[`${prefix}wrapper`] = $el;\n    elemStore[`${prefix}table`] = $refs.table;\n    elemStore[`${prefix}colgroup`] = $refs.colgroup;\n    elemStore[`${prefix}list`] = $refs.thead;\n    elemStore[`${prefix}xSpace`] = $refs.xSpace;\n    elemStore[`${prefix}repair`] = $refs.repair;\n  },\n\n  render(h) {\n    const _e = this._e,\n          $xetable = this.$parent,\n          fixedType = this.fixedType,\n          headerColumn = this.headerColumn,\n          fixedColumn = this.fixedColumn;\n    const tableListeners = $xetable.$listeners,\n          tId = $xetable.tId,\n          isGroup = $xetable.isGroup,\n          resizable = $xetable.resizable,\n          border = $xetable.border,\n          columnKey = $xetable.columnKey,\n          headerRowClassName = $xetable.headerRowClassName,\n          headerCellClassName = $xetable.headerCellClassName,\n          headerRowStyle = $xetable.headerRowStyle,\n          headerCellStyle = $xetable.headerCellStyle,\n          allColumnHeaderOverflow = $xetable.showHeaderOverflow,\n          allHeaderAlign = $xetable.headerAlign,\n          allAlign = $xetable.align,\n          highlightCurrentColumn = $xetable.highlightCurrentColumn,\n          currentColumn = $xetable.currentColumn,\n          scrollXLoad = $xetable.scrollXLoad,\n          overflowX = $xetable.overflowX,\n          scrollbarWidth = $xetable.scrollbarWidth,\n          sortOpts = $xetable.sortOpts,\n          mouseConfig = $xetable.mouseConfig;\n    let tableColumn = this.tableColumn;\n    let headerGroups = headerColumn; // 如果是使用优化模式\n\n    if (!isGroup) {\n      if (fixedType) {\n        if (scrollXLoad || allColumnHeaderOverflow) {\n          tableColumn = fixedColumn;\n        }\n      }\n\n      headerGroups = [tableColumn];\n    }\n\n    return h('div', {\n      class: ['vxe-table--header-wrapper', fixedType ? `fixed-${fixedType}--wrapper` : 'body--wrapper'],\n      attrs: {\n        xid: tId\n      }\n    }, [fixedType ? _e() : h('div', {\n      class: 'vxe-body--x-space',\n      ref: 'xSpace'\n    }), h('table', {\n      class: 'vxe-table--header',\n      attrs: {\n        xid: tId,\n        cellspacing: 0,\n        cellpadding: 0,\n        border: 0\n      },\n      ref: 'table'\n    }, [\n    /**\r\n     * 列宽\r\n     */\n    h('colgroup', {\n      ref: 'colgroup'\n    }, tableColumn.map((column, $columnIndex) => {\n      return h('col', {\n        attrs: {\n          name: column.id\n        },\n        key: $columnIndex\n      });\n    }).concat(scrollbarWidth ? [h('col', {\n      attrs: {\n        name: 'col_gutter'\n      }\n    })] : [])),\n    /**\r\n     * 头部\r\n     */\n    h('thead', {\n      ref: 'thead'\n    }, headerGroups.map((cols, $rowIndex) => {\n      return h('tr', {\n        class: ['vxe-header--row', headerRowClassName ? XEUtils.isFunction(headerRowClassName) ? headerRowClassName({\n          $table: $xetable,\n          $rowIndex,\n          fixed: fixedType,\n          type: cellType\n        }) : headerRowClassName : ''],\n        style: headerRowStyle ? XEUtils.isFunction(headerRowStyle) ? headerRowStyle({\n          $table: $xetable,\n          $rowIndex,\n          fixed: fixedType,\n          type: cellType\n        }) : headerRowStyle : null\n      }, cols.map((column, $columnIndex) => {\n        const type = column.type,\n              showHeaderOverflow = column.showHeaderOverflow,\n              headerAlign = column.headerAlign,\n              align = column.align,\n              headerClassName = column.headerClassName; // const { enabled } = tooltipOpts\n\n        const isColGroup = column.children && column.children.length;\n        const fixedHiddenColumn = fixedType ? column.fixed !== fixedType && !isColGroup : column.fixed && overflowX;\n        const headOverflow = XEUtils.isUndefined(showHeaderOverflow) || XEUtils.isNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;\n        const headAlign = headerAlign || align || allHeaderAlign || allAlign;\n        let showEllipsis = headOverflow === 'ellipsis';\n        const showTitle = headOverflow === 'title';\n        const showTooltip = headOverflow === true || headOverflow === 'tooltip';\n        let hasEllipsis = showTitle || showTooltip || showEllipsis;\n        const thOns = {};\n        const hasFilter = column.filters && column.filters.some(item => item.checked);\n        const columnIndex = $xetable.getColumnIndex(column);\n\n        const _columnIndex = $xetable.getVTColumnIndex(column);\n\n        const params = {\n          $table: $xetable,\n          $rowIndex,\n          column,\n          columnIndex,\n          $columnIndex,\n          _columnIndex,\n          fixed: fixedType,\n          type: cellType,\n          isHidden: fixedHiddenColumn,\n          hasFilter // 虚拟滚动不支持动态高度\n\n        };\n\n        if (scrollXLoad && !hasEllipsis) {\n          showEllipsis = hasEllipsis = true;\n        }\n\n        if (highlightCurrentColumn || tableListeners['header-cell-click'] || sortOpts.trigger === 'cell') {\n          thOns.click = evnt => $xetable.triggerHeaderCellClickEvent(evnt, params);\n        }\n\n        if (tableListeners['header-cell-dblclick']) {\n          thOns.dblclick = evnt => $xetable.triggerHeaderCellDblclickEvent(evnt, params);\n        } // 按下事件处理\n\n\n        if (mouseConfig) {\n          thOns.mousedown = evnt => $xetable.triggerHeaderCellMousedownEvent(evnt, params);\n        }\n\n        return h('th', {\n          class: ['vxe-header--column', column.id, {\n            [`col--${headAlign}`]: headAlign,\n            [`col--${type}`]: type,\n            'col--last': $columnIndex === cols.length - 1,\n            'col--fixed': column.fixed,\n            'col--group': isColGroup,\n            'col--ellipsis': hasEllipsis,\n            'fixed--hidden': fixedHiddenColumn,\n            'is--sortable': column.sortable,\n            'is--filter': !!column.filters,\n            'filter--active': hasFilter,\n            'col--current': currentColumn === column\n          }, UtilTools.getClass(headerClassName, params), UtilTools.getClass(headerCellClassName, params)],\n          attrs: {\n            colid: column.id,\n            colspan: column.colSpan > 1 ? column.colSpan : null,\n            rowspan: column.rowSpan > 1 ? column.rowSpan : null\n          },\n          style: headerCellStyle ? XEUtils.isFunction(headerCellStyle) ? headerCellStyle(params) : headerCellStyle : null,\n          on: thOns,\n          key: columnKey || isColGroup ? column.id : $columnIndex\n        }, [h('div', {\n          class: ['vxe-cell', {\n            'c--title': showTitle,\n            'c--tooltip': showTooltip,\n            'c--ellipsis': showEllipsis\n          }]\n        }, column.renderHeader(h, params)),\n        /**\r\n         * 列宽拖动\r\n         */\n        !fixedHiddenColumn && !isColGroup && (XEUtils.isBoolean(column.resizable) ? column.resizable : resizable) ? h('div', {\n          class: ['vxe-resizable', {\n            'is--line': !border || border === 'none'\n          }],\n          on: {\n            mousedown: evnt => this.resizeMousedown(evnt, params)\n          }\n        }) : null]);\n      }).concat(scrollbarWidth ? [h('th', {\n        class: 'vxe-header--gutter col--gutter'\n      })] : []));\n    }))]),\n    /**\r\n     * 其他\r\n     */\n    h('div', {\n      class: 'vxe-table--header-border-line',\n      ref: 'repair'\n    })]);\n  },\n\n  methods: {\n    uploadColumn() {\n      const $xetable = this.$parent;\n      this.headerColumn = $xetable.isGroup ? convertToRows(this.tableGroupColumn) : [];\n    },\n\n    resizeMousedown(evnt, params) {\n      const column = params.column;\n      const $xetable = this.$parent,\n            $el = this.$el,\n            fixedType = this.fixedType;\n      const _$xetable$$refs = $xetable.$refs,\n            tableBody = _$xetable$$refs.tableBody,\n            leftContainer = _$xetable$$refs.leftContainer,\n            rightContainer = _$xetable$$refs.rightContainer,\n            resizeBarElem = _$xetable$$refs.resizeBar;\n      const dragBtnElem = evnt.target,\n            dragClientX = evnt.clientX;\n      const cell = params.cell = dragBtnElem.parentNode;\n      let dragLeft = 0;\n      const tableBodyElem = tableBody.$el;\n      const pos = DomTools.getOffsetPos(dragBtnElem, $el);\n      const dragBtnWidth = dragBtnElem.clientWidth;\n      const dragBtnOffsetWidth = Math.floor(dragBtnWidth / 2);\n      const minInterval = getColMinWidth(params) - dragBtnOffsetWidth; // 列之间的最小间距\n\n      let dragMinLeft = pos.left - cell.clientWidth + dragBtnWidth + minInterval;\n      let dragPosLeft = pos.left + dragBtnOffsetWidth;\n      const domMousemove = document.onmousemove;\n      const domMouseup = document.onmouseup;\n      const isLeftFixed = fixedType === 'left';\n      const isRightFixed = fixedType === 'right'; // 计算左右侧固定列偏移量\n\n      let fixedOffsetWidth = 0;\n\n      if (isLeftFixed || isRightFixed) {\n        const siblingProp = isLeftFixed ? 'nextElementSibling' : 'previousElementSibling';\n        let tempCellElem = cell[siblingProp];\n\n        while (tempCellElem) {\n          if (DomTools.hasClass(tempCellElem, 'fixed--hidden')) {\n            break;\n          } else if (!DomTools.hasClass(tempCellElem, 'col--group')) {\n            fixedOffsetWidth += tempCellElem.offsetWidth;\n          }\n\n          tempCellElem = tempCellElem[siblingProp];\n        }\n\n        if (isRightFixed && rightContainer) {\n          dragPosLeft = rightContainer.offsetLeft + fixedOffsetWidth;\n        }\n      } // 处理拖动事件\n\n\n      const updateEvent = function updateEvent(evnt) {\n        evnt.stopPropagation();\n        evnt.preventDefault();\n        const offsetX = evnt.clientX - dragClientX;\n        let left = dragPosLeft + offsetX;\n        const scrollLeft = fixedType ? 0 : tableBodyElem.scrollLeft;\n\n        if (isLeftFixed) {\n          // 左固定列（不允许超过右侧固定列、不允许超过右边距）\n          left = Math.min(left, (rightContainer ? rightContainer.offsetLeft : tableBodyElem.clientWidth) - fixedOffsetWidth - minInterval);\n        } else if (isRightFixed) {\n          // 右侧固定列（不允许超过左侧固定列、不允许超过左边距）\n          dragMinLeft = (leftContainer ? leftContainer.clientWidth : 0) + fixedOffsetWidth + minInterval;\n          left = Math.min(left, dragPosLeft + cell.clientWidth - minInterval);\n        } else {\n          dragMinLeft = Math.max(tableBodyElem.scrollLeft, dragMinLeft); // left = Math.min(left, tableBodyElem.clientWidth + tableBodyElem.scrollLeft - 40)\n        }\n\n        dragLeft = Math.max(left, dragMinLeft);\n        resizeBarElem.style.left = `${dragLeft - scrollLeft}px`;\n      };\n\n      $xetable._isResize = true;\n      DomTools.addClass($xetable.$el, 'drag--resize');\n      resizeBarElem.style.display = 'block';\n      document.onmousemove = updateEvent;\n\n      document.onmouseup = function (evnt) {\n        document.onmousemove = domMousemove;\n        document.onmouseup = domMouseup;\n        column.resizeWidth = column.renderWidth + (isRightFixed ? dragPosLeft - dragLeft : dragLeft - dragPosLeft);\n        resizeBarElem.style.display = 'none';\n        $xetable._isResize = false;\n        $xetable._lastResizeTime = Date.now();\n        $xetable.analyColumnWidth();\n        $xetable.recalculate(true).then(() => {\n          $xetable.saveCustomResizable();\n          $xetable.updateCellAreas();\n          $xetable.emitEvent('resizable-change', params, evnt);\n        });\n        DomTools.removeClass($xetable.$el, 'drag--resize');\n      };\n\n      updateEvent(evnt);\n      $xetable.closeMenu();\n    }\n\n  }\n};",null]}