{"remainingRequest":"D:\\cdRule\\node_modules\\thread-loader\\dist\\cjs.js!D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js!D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js!D:\\cdRule\\src\\components\\Table\\tooltip\\src\\tooltip.js","dependencies":[{"path":"D:\\cdRule\\src\\components\\Table\\tooltip\\src\\tooltip.js","mtime":1635230121026},{"path":"D:\\cdRule\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\thread-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import XEUtils from 'xe-utils';\nimport GlobalConfig from '../../v-x-e-table/src/conf';\nimport vSize from '../../mixins/size';\nimport { UtilTools, DomTools } from '../../tools';\n\nfunction updateTipStyle(_vm) {\n  const wrapperElem = _vm.$el,\n        tipTarget = _vm.tipTarget,\n        tipStore = _vm.tipStore;\n\n  if (tipTarget) {\n    const _DomTools$getDomNode = DomTools.getDomNode(),\n          scrollTop = _DomTools$getDomNode.scrollTop,\n          scrollLeft = _DomTools$getDomNode.scrollLeft,\n          visibleWidth = _DomTools$getDomNode.visibleWidth;\n\n    const _DomTools$getAbsolute = DomTools.getAbsolutePos(tipTarget),\n          top = _DomTools$getAbsolute.top,\n          left = _DomTools$getAbsolute.left;\n\n    const marginSize = 6;\n    const offsetHeight = wrapperElem.offsetHeight;\n    const offsetWidth = wrapperElem.offsetWidth;\n    let tipTop = top - offsetHeight - marginSize;\n    let tipLeft = Math.max(marginSize, left + Math.floor((tipTarget.offsetWidth - offsetWidth) / 2));\n\n    if (tipLeft + offsetWidth + marginSize > scrollLeft + visibleWidth) {\n      tipLeft = scrollLeft + visibleWidth - offsetWidth - marginSize;\n    }\n\n    if (top - offsetHeight < scrollTop + marginSize) {\n      tipStore.placement = 'bottom';\n      tipTop = top + tipTarget.offsetHeight + marginSize;\n    }\n\n    tipStore.style.top = `${tipTop}px`;\n    tipStore.style.left = `${tipLeft}px`;\n    tipStore.arrowStyle.left = `${left - tipLeft + tipTarget.offsetWidth / 2}px`;\n  }\n}\n\nexport default {\n  name: 'VxeTooltip',\n  mixins: [vSize],\n  props: {\n    value: Boolean,\n    size: {\n      type: String,\n      default: () => GlobalConfig.tooltip.size || GlobalConfig.size\n    },\n    trigger: {\n      type: String,\n      default: () => GlobalConfig.tooltip.trigger\n    },\n    skin: {\n      type: String,\n      default: () => GlobalConfig.tooltip.skin\n    },\n    content: [String, Number],\n    zIndex: [String, Number],\n    isArrow: {\n      type: Boolean,\n      default: true\n    },\n    enterable: Boolean,\n    leaveDelay: {\n      type: Number,\n      default: GlobalConfig.tooltip.leaveDelay\n    },\n    leaveMethod: Function\n  },\n\n  data() {\n    return {\n      isUpdate: false,\n      isHover: false,\n      visible: false,\n      message: '',\n      tipTarget: null,\n      tipZindex: 0,\n      tipStore: {\n        style: {},\n        placement: '',\n        arrowStyle: null\n      }\n    };\n  },\n\n  watch: {\n    content(value) {\n      this.message = value;\n    },\n\n    value(value) {\n      if (!this.isUpdate) {\n        this[value ? 'open' : 'close']();\n      }\n\n      this.isUpdate = false;\n    }\n\n  },\n\n  mounted() {\n    const $el = this.$el,\n          trigger = this.trigger,\n          content = this.content,\n          value = this.value;\n    const parentNode = $el.parentNode;\n    let target;\n    this.message = content;\n    this.tipZindex = UtilTools.nextZIndex();\n    XEUtils.arrayEach($el.children, (elem, index) => {\n      if (index > 1) {\n        parentNode.insertBefore(elem, $el);\n\n        if (!target) {\n          target = elem;\n        }\n      }\n    });\n    parentNode.removeChild($el);\n    this.target = target;\n\n    if (target) {\n      if (trigger === 'hover') {\n        target.onmouseleave = this.targetMouseleaveEvent;\n        target.onmouseenter = this.targetMouseenterEvent;\n      } else if (trigger === 'click') {\n        target.onclick = this.clickEvent;\n      }\n    }\n\n    if (value) {\n      this.open();\n    }\n  },\n\n  beforeDestroy() {\n    const $el = this.$el,\n          target = this.target,\n          trigger = this.trigger;\n    const parentNode = $el.parentNode;\n\n    if (parentNode) {\n      parentNode.removeChild($el);\n    }\n\n    if (target) {\n      if (trigger === 'hover') {\n        target.onmouseenter = null;\n        target.onmouseleave = null;\n      } else if (trigger === 'click') {\n        target.onclick = null;\n      }\n    }\n  },\n\n  render(h) {\n    const $scopedSlots = this.$scopedSlots,\n          vSize = this.vSize,\n          skin = this.skin,\n          message = this.message,\n          isHover = this.isHover,\n          isArrow = this.isArrow,\n          visible = this.visible,\n          tipStore = this.tipStore,\n          enterable = this.enterable;\n    let on;\n\n    if (enterable) {\n      on = {\n        mouseenter: this.wrapperMouseenterEvent,\n        mouseleave: this.wrapperMouseleaveEvent\n      };\n    }\n\n    return h('div', {\n      class: ['vxe-table--tooltip-wrapper', `skin--${skin}`, {\n        [`size--${vSize}`]: vSize,\n        [`placement--${tipStore.placement}`]: tipStore.placement,\n        'is--enterable': enterable,\n        'is--visible': visible,\n        'is--arrow': isArrow,\n        'is--hover': isHover\n      }],\n      style: tipStore.style,\n      ref: 'tipWrapper',\n      on\n    }, [h('div', {\n      class: 'vxe-table--tooltip-content'\n    }, $scopedSlots.content ? $scopedSlots.content.call(this, {}) : message), h('div', {\n      class: 'vxe-table--tooltip-arrow',\n      style: tipStore.arrowStyle\n    })].concat($scopedSlots.default ? $scopedSlots.default.call(this, {}) : []));\n  },\n\n  methods: {\n    open(target, message) {\n      return this.toVisible(target || this.target, message);\n    },\n\n    close() {\n      this.tipTarget = null;\n      Object.assign(this.tipStore, {\n        style: {},\n        placement: '',\n        arrowStyle: null\n      });\n      this.update(false);\n      return this.$nextTick();\n    },\n\n    update(value) {\n      if (value !== this.visible) {\n        this.visible = value;\n        this.isUpdate = true;\n\n        if (this.$listeners.input) {\n          this.$emit('input', this.visible);\n        }\n      }\n    },\n\n    updateZindex() {\n      this.tipZindex = window.$_theme.zindex(); //加\n      //      if (this.tipZindex < UtilTools.getLastZIndex()) {//删\n      //        this.tipZindex = UtilTools.nextZIndex()\n      //      }\n    },\n\n    toVisible(target, message) {\n      this.targetActive = true;\n\n      if (target) {\n        const $el = this.$el,\n              tipStore = this.tipStore,\n              zIndex = this.zIndex;\n        const parentNode = $el.parentNode;\n\n        if (!parentNode) {\n          document.body.appendChild($el);\n        }\n\n        if (message) {\n          this.message = message;\n        }\n\n        this.tipTarget = target;\n        this.update(true);\n        this.updateZindex();\n        tipStore.placement = 'top';\n        tipStore.style = {\n          width: 'auto',\n          left: 0,\n          top: 0,\n          zIndex: zIndex || this.tipZindex\n        };\n        tipStore.arrowStyle = {\n          left: '50%'\n        };\n        return this.updatePlacement();\n      }\n\n      return this.$nextTick();\n    },\n\n    updatePlacement() {\n      return this.$nextTick().then(() => {\n        const wrapperElem = this.$el,\n              tipTarget = this.tipTarget;\n\n        if (tipTarget && wrapperElem) {\n          updateTipStyle(this);\n          return this.$nextTick().then(() => updateTipStyle(this));\n        }\n      });\n    },\n\n    clickEvent() {\n      this[this.visible ? 'close' : 'open']();\n    },\n\n    targetMouseenterEvent() {\n      this.open();\n    },\n\n    targetMouseleaveEvent() {\n      const trigger = this.trigger,\n            enterable = this.enterable,\n            leaveDelay = this.leaveDelay;\n      this.targetActive = false;\n\n      if (enterable && trigger === 'hover') {\n        setTimeout(() => {\n          if (!this.isHover) {\n            this.close();\n          }\n        }, leaveDelay);\n      } else {\n        this.close();\n      }\n    },\n\n    wrapperMouseenterEvent() {\n      this.isHover = true;\n    },\n\n    wrapperMouseleaveEvent(evnt) {\n      const leaveMethod = this.leaveMethod,\n            trigger = this.trigger,\n            enterable = this.enterable,\n            leaveDelay = this.leaveDelay;\n      this.isHover = false;\n\n      if (!leaveMethod || leaveMethod({\n        $event: evnt\n      }) !== false) {\n        if (enterable && trigger === 'hover') {\n          setTimeout(() => {\n            if (!this.targetActive) {\n              this.close();\n            }\n          }, leaveDelay);\n        }\n      }\n    }\n\n  }\n};",null]}