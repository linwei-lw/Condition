{"remainingRequest":"D:\\cdRule\\node_modules\\thread-loader\\dist\\cjs.js!D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js!D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js!D:\\cdRule\\src\\components\\Table\\table\\src\\methods.js","dependencies":[{"path":"D:\\cdRule\\src\\components\\Table\\table\\src\\methods.js","mtime":1657012587403},{"path":"D:\\cdRule\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\thread-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.regexp.split\";\nimport \"core-js/modules/es6.array.sort\";\nimport \"core-js/modules/es6.string.fixed\";\nimport \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.regexp.split\";\nimport \"core-js/modules/es6.array.sort\";\nimport \"core-js/modules/es6.string.fixed\";\nimport \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/web.dom.iterable\";\nimport XEUtils from 'xe-utils';\nimport GlobalConfig from '../../v-x-e-table/src/conf';\nimport Cell from './cell';\nimport VXETable from '../../v-x-e-table';\nimport { UtilTools, DomTools } from '../../tools';\nimport { clearTableAllStatus, handleFieldOrColumn } from './util';\nimport { eqEmptyValue, isEnableConf } from '../../tools/src/utils';\nimport { browse, getPaddingTopBottomSize, setScrollTop, setScrollLeft } from '../../tools/src/dom';\nimport { formats } from '../../v-x-e-table/src/formats';\nimport { arraySort, compare } from '@/common/util/Arrays.js'; //加\n\nconst getRowid = UtilTools.getRowid,\n      getRowkey = UtilTools.getRowkey,\n      setCellValue = UtilTools.setCellValue,\n      hasChildrenList = UtilTools.hasChildrenList,\n      getColumnList = UtilTools.getColumnList;\nconst calcHeight = DomTools.calcHeight,\n      hasClass = DomTools.hasClass,\n      addClass = DomTools.addClass,\n      removeClass = DomTools.removeClass,\n      getEventTargetNode = DomTools.getEventTargetNode;\nconst isWebkit = browse['-webkit'] && !browse.edge;\nconst debounceScrollYDuration = browse.msie ? 80 : 20;\nconst resizableStorageKey = 'VXE_TABLE_CUSTOM_COLUMN_WIDTH';\nconst visibleStorageKey = 'VXE_TABLE_CUSTOM_COLUMN_VISIBLE';\n/**\r\n * 生成行的唯一主键\r\n */\n\nfunction getRowUniqueId() {\n  return XEUtils.uniqueId('row_');\n}\n\nfunction eqCellValue(row1, row2, field) {\n  const val1 = XEUtils.get(row1, field);\n  const val2 = XEUtils.get(row2, field);\n\n  if (eqEmptyValue(val1) && eqEmptyValue(val2)) {\n    return true;\n  }\n\n  if (XEUtils.isString(val1) || XEUtils.isNumber(val1)) {\n    /* eslint-disable eqeqeq */\n    return val1 == val2;\n  }\n\n  return XEUtils.isEqual(val1, val2);\n}\n\nfunction getNextSortOrder(_vm, column) {\n  const orders = _vm.sortOpts.orders;\n  const currOrder = column.order || null;\n  const oIndex = orders.indexOf(currOrder) + 1;\n  return orders[oIndex < orders.length ? oIndex : 0];\n}\n\nfunction getCustomStorageMap(key) {\n  const version = GlobalConfig.version;\n  const rest = XEUtils.toStringJSON(localStorage.getItem(key));\n  return rest && rest._v === version ? rest : {\n    _v: version\n  };\n}\n\nfunction getRecoverRow(_vm, list) {\n  const fullAllDataRowMap = _vm.fullAllDataRowMap;\n  return list.filter(row => fullAllDataRowMap.has(row));\n}\n\nfunction handleReserveRow(_vm, reserveRowMap) {\n  const fullDataRowIdData = _vm.fullDataRowIdData;\n  const reserveList = [];\n  XEUtils.each(reserveRowMap, (item, rowid) => {\n    if (fullDataRowIdData[rowid] && reserveList.indexOf(fullDataRowIdData[rowid].row) === -1) {\n      reserveList.push(fullDataRowIdData[rowid].row);\n    }\n  });\n  return reserveList;\n}\n\nfunction restoreScroll(_vm, scrollLeft, scrollTop) {\n  return _vm.clearScroll().then(() => {\n    if (scrollLeft || scrollTop) {\n      // 重置最后滚动状态\n      _vm.lastScrollLeft = 0;\n      _vm.lastScrollTop = 0; // 还原滚动状态\n\n      return _vm.scrollTo(scrollLeft, scrollTop);\n    }\n  });\n}\n\nfunction computeVirtualX(_vm) {\n  const $refs = _vm.$refs,\n        visibleColumn = _vm.visibleColumn;\n  const tableBody = $refs.tableBody;\n  const tableBodyElem = tableBody ? tableBody.$el : null;\n\n  if (tableBodyElem) {\n    const scrollLeft = tableBodyElem.scrollLeft,\n          clientWidth = tableBodyElem.clientWidth;\n    const endWidth = scrollLeft + clientWidth;\n    let toVisibleIndex = -1;\n    let cWidth = 0;\n    let visibleSize = 0;\n\n    for (let colIndex = 0, colLen = visibleColumn.length; colIndex < colLen; colIndex++) {\n      cWidth += visibleColumn[colIndex].renderWidth;\n\n      if (toVisibleIndex === -1 && scrollLeft < cWidth) {\n        toVisibleIndex = colIndex;\n      }\n\n      if (toVisibleIndex >= 0) {\n        visibleSize++;\n\n        if (cWidth > endWidth) {\n          break;\n        }\n      }\n    }\n\n    return {\n      toVisibleIndex: Math.max(0, toVisibleIndex),\n      visibleSize: Math.max(8, visibleSize)\n    };\n  }\n\n  return {\n    toVisibleIndex: 0,\n    visibleSize: 8\n  };\n}\n\nfunction computeVirtualY(_vm) {\n  const $refs = _vm.$refs,\n        vSize = _vm.vSize,\n        rowHeightMaps = _vm.rowHeightMaps,\n        params = _vm.params;\n  const tableHeader = $refs.tableHeader,\n        tableBody = $refs.tableBody;\n  const tableBodyElem = tableBody ? tableBody.$el : null;\n\n  if (tableBodyElem) {\n    const tableHeaderElem = tableHeader ? tableHeader.$el : null;\n    let rowHeight = params ? params.rowHeight : 0;\n\n    if (!rowHeight) {\n      let firstTrElem;\n      firstTrElem = tableBodyElem.querySelector('tr');\n\n      if (!firstTrElem && tableHeaderElem) {\n        firstTrElem = tableHeaderElem.querySelector('tr');\n      }\n\n      if (firstTrElem) {\n        rowHeight = firstTrElem.clientHeight;\n      }\n    }\n\n    if (!rowHeight) {\n      rowHeight = rowHeightMaps[vSize || 'default'];\n    }\n\n    const visibleSize = Math.max(8, Math.ceil(tableBodyElem.clientHeight / rowHeight) + 2);\n    return {\n      rowHeight,\n      visibleSize\n    };\n  }\n\n  return {\n    rowHeight: 0,\n    visibleSize: 8\n  };\n}\n\nfunction calculateMergerOffserIndex(list, offsetItem, type) {\n  for (let mcIndex = 0, len = list.length; mcIndex < len; mcIndex++) {\n    const mergeItem = list[mcIndex];\n    const startIndex = offsetItem.startIndex,\n          endIndex = offsetItem.endIndex;\n    const mergeStartIndex = mergeItem[type];\n    const mergeSpanNumber = mergeItem[type + 'span'];\n    const mergeEndIndex = mergeStartIndex + mergeSpanNumber;\n\n    if (mergeStartIndex < startIndex && startIndex < mergeEndIndex) {\n      offsetItem.startIndex = mergeStartIndex;\n    }\n\n    if (mergeStartIndex < endIndex && endIndex < mergeEndIndex) {\n      offsetItem.endIndex = mergeEndIndex;\n    }\n\n    if (offsetItem.startIndex !== startIndex || offsetItem.endIndex !== endIndex) {\n      mcIndex = -1;\n    }\n  }\n}\n\nfunction setMerges(_vm, merges, mList, rowList) {\n  if (merges) {\n    const treeConfig = _vm.treeConfig,\n          visibleColumn = _vm.visibleColumn;\n\n    if (treeConfig) {\n      throw new Error(UtilTools.getLog('vxe.error.noTree', ['merge-footer-items']));\n    }\n\n    if (!XEUtils.isArray(merges)) {\n      merges = [merges];\n    }\n\n    merges.forEach(item => {\n      let row = item.row,\n          col = item.col,\n          rowspan = item.rowspan,\n          colspan = item.colspan;\n\n      if (rowList && XEUtils.isNumber(row)) {\n        row = rowList[row];\n      }\n\n      if (XEUtils.isNumber(col)) {\n        col = visibleColumn[col];\n      }\n\n      if ((rowList ? row : XEUtils.isNumber(row)) && col && (rowspan || colspan)) {\n        rowspan = XEUtils.toNumber(rowspan) || 1;\n        colspan = XEUtils.toNumber(colspan) || 1;\n\n        if (rowspan > 1 || colspan > 1) {\n          const mcIndex = XEUtils.findIndexOf(mList, item => item._row === row && item._col === col);\n          const mergeItem = mList[mcIndex];\n\n          if (mergeItem) {\n            mergeItem.rowspan = rowspan;\n            mergeItem.colspan = colspan;\n            mergeItem._rowspan = rowspan;\n            mergeItem._colspan = colspan;\n          } else {\n            const mergeRowIndex = rowList ? rowList.indexOf(row) : row;\n            const mergeColIndex = visibleColumn.indexOf(col);\n            mList.push({\n              row: mergeRowIndex,\n              col: mergeColIndex,\n              rowspan,\n              colspan,\n              _row: row,\n              _col: col,\n              _rowspan: rowspan,\n              _colspan: colspan\n            });\n          }\n        }\n      }\n    });\n  }\n}\n\nfunction removeMerges(_vm, merges, mList, rowList) {\n  const rest = [];\n\n  if (merges) {\n    const treeConfig = _vm.treeConfig,\n          visibleColumn = _vm.visibleColumn;\n\n    if (treeConfig) {\n      throw new Error(UtilTools.getLog('vxe.error.noTree', ['merge-cells']));\n    }\n\n    if (!XEUtils.isArray(merges)) {\n      merges = [merges];\n    }\n\n    merges.forEach(item => {\n      let row = item.row,\n          col = item.col;\n\n      if (rowList && XEUtils.isNumber(row)) {\n        row = rowList[row];\n      }\n\n      if (XEUtils.isNumber(col)) {\n        col = visibleColumn[col];\n      }\n\n      const mcIndex = XEUtils.findIndexOf(mList, item => item._row === row && item._col === col);\n\n      if (mcIndex > -1) {\n        const rItems = mList.splice(mcIndex, 1);\n        rest.push(rItems[0]);\n      }\n    });\n  }\n\n  return rest;\n}\n\nfunction clearAllSort(_vm) {\n  _vm.tableFullColumn.forEach(column => {\n    column.order = null;\n  });\n}\n\nfunction getOrderField(_vm, column) {\n  const sortBy = column.sortBy,\n        sortType = column.sortType;\n  return row => {\n    let cellValue;\n\n    if (sortBy) {\n      cellValue = XEUtils.isFunction(sortBy) ? sortBy({\n        row,\n        column\n      }) : XEUtils.get(row, sortBy);\n    } else {\n      cellValue = _vm.getCellLabel(row, column);\n    }\n\n    if (!sortType || sortType === 'auto') {\n      return isNaN(cellValue) ? cellValue : XEUtils.toNumber(cellValue);\n    } else if (sortType === 'number') {\n      return XEUtils.toNumber(cellValue);\n    } else if (sortType === 'string') {\n      return XEUtils.toString(cellValue);\n    }\n\n    return cellValue;\n  };\n}\n\nconst Methods = {\n  callSlot(slotFunc, params, h, vNodes) {\n    if (slotFunc) {\n      const $xegrid = this.$xegrid;\n\n      if ($xegrid) {\n        return $xegrid.callSlot(slotFunc, params, h, vNodes);\n      }\n\n      if (XEUtils.isFunction(slotFunc)) {\n        return slotFunc.call(this, params, h, vNodes);\n      }\n    }\n\n    return [];\n  },\n\n  /**\r\n   * 获取父容器元素\r\n   */\n  getParentElem() {\n    const $el = this.$el,\n          $xegrid = this.$xegrid;\n    return $xegrid ? $xegrid.$el.parentNode : $el.parentNode;\n  },\n\n  /**\r\n   * 获取父容器的高度\r\n   */\n  getParentHeight() {\n    const $el = this.$el,\n          $xegrid = this.$xegrid,\n          height = this.height;\n    const parentElem = $el.parentNode;\n    const parentPaddingSize = height === 'auto' ? getPaddingTopBottomSize(parentElem) : 0;\n    return Math.floor($xegrid ? $xegrid.getParentHeight() : XEUtils.toNumber(getComputedStyle(parentElem).height) - parentPaddingSize);\n  },\n\n  /**\r\n   * 获取需要排除的高度\r\n   * 但渲染表格高度时，需要排除工具栏或分页等相关组件的高度\r\n   * 如果存在表尾合计滚动条，则需要排除滚动条高度\r\n   */\n  getExcludeHeight() {\n    const $xegrid = this.$xegrid;\n    return $xegrid ? $xegrid.getExcludeHeight() : 0;\n  },\n\n  /**\r\n   * 重置表格的一切数据状态\r\n   */\n  clearAll() {\n    return clearTableAllStatus(this);\n  },\n\n  /**\r\n   * 同步 data 数据\r\n   * 如果用了该方法，那么组件将不再记录增删改的状态，只能自行实现对应逻辑\r\n   * 对于某些特殊的场景，比如深层树节点元素发生变动时可能会用到\r\n   */\n  syncData() {\n    return this.$nextTick().then(() => {\n      this.tableData = [];\n      return this.$nextTick().then(() => this.loadTableData(this.tableFullData));\n    });\n  },\n\n  /**\r\n   * 手动处理数据\r\n   * 对于手动更改了排序、筛选...等条件后需要重新处理数据时可能会用到\r\n   */\n  updateData() {\n    return this.handleTableData(true).then(this.updateFooter).then(this.recalculate);\n  },\n\n  handleTableData(force) {\n    const scrollYLoad = this.scrollYLoad,\n          scrollYStore = this.scrollYStore;\n    const fullData = force ? this.updateAfterFullData() : this.afterFullData;\n    this.tableData = scrollYLoad ? fullData.slice(scrollYStore.startIndex, scrollYStore.endIndex) : fullData.slice(0);\n    return this.$nextTick();\n  },\n\n  /**\r\n   * 加载表格数据\r\n   * @param {Array} datas 数据\r\n   */\n  loadTableData(datas) {\n    const keepSource = this.keepSource,\n          treeConfig = this.treeConfig,\n          editStore = this.editStore,\n          sYOpts = this.sYOpts,\n          scrollYStore = this.scrollYStore,\n          scrollXStore = this.scrollXStore,\n          lastScrollLeft = this.lastScrollLeft,\n          lastScrollTop = this.lastScrollTop,\n          oldScrollYLoad = this.scrollYLoad;\n    const tableFullData = datas ? datas.slice(0) : [];\n    const scrollYLoad = !treeConfig && sYOpts.enabled && sYOpts.gt > -1 && sYOpts.gt < tableFullData.length;\n    scrollYStore.startIndex = 0;\n    scrollYStore.endIndex = 1;\n    scrollXStore.startIndex = 0;\n    scrollXStore.endIndex = 1;\n    editStore.insertList = [];\n    editStore.removeList = []; // 全量数据\n\n    this.tableFullData = tableFullData; // 缓存数据\n\n    this.updateCache(true); // 原始数据\n\n    this.tableSynchData = datas;\n\n    if (keepSource) {\n      this.tableSourceData = XEUtils.clone(tableFullData, true);\n    }\n\n    this.scrollYLoad = scrollYLoad;\n\n    if (process.env.VUE_APP_VXE_TABLE_ENV === 'development') {\n      if (scrollYLoad) {\n        if (!(this.height || this.maxHeight)) {\n          UtilTools.error('vxe.error.reqProp', ['table.height | table.max-height | table.scroll-y={enabled: false}']);\n        }\n\n        if (!this.showOverflow) {\n          UtilTools.warn('vxe.error.reqProp', ['table.show-overflow']);\n        }\n\n        if (this.spanMethod) {\n          UtilTools.warn('vxe.error.scrollErrProp', ['table.span-method']);\n        }\n      }\n    }\n\n    if (this.clearCellAreas && this.mouseConfig) {\n      this.clearCellAreas();\n      this.clearCopyCellArea();\n    }\n\n    this.clearMergeCells();\n    this.clearMergeFooterItems();\n    this.handleTableData(true);\n    this.updateFooter();\n    return this.$nextTick().then(() => {\n      this.updateHeight();\n      this.updateStyle();\n    }).then(() => {\n      this.computeScrollLoad();\n    }).then(() => {\n      // 是否加载了数据\n      if (scrollYLoad) {\n        scrollYStore.endIndex = scrollYStore.visibleSize;\n      }\n\n      this.handleReserveStatus();\n      this.checkSelectionStatus();\n      return new Promise(resolve => {\n        this.$nextTick().then(() => this.recalculate()).then(() => {\n          // 是否变更虚拟滚动\n          if (oldScrollYLoad === scrollYLoad) {\n            restoreScroll(this, lastScrollLeft, lastScrollTop).then(resolve);\n          } else {\n            setTimeout(() => restoreScroll(this, lastScrollLeft, lastScrollTop).then(resolve));\n          }\n        });\n      });\n    });\n  },\n\n  /**\r\n   * 重新加载数据，不会清空表格状态\r\n   * @param {Array} datas 数据\r\n   */\n  loadData(datas) {\n    const inited = this.inited,\n          initStatus = this.initStatus;\n    return this.loadTableData(datas).then(() => {\n      this.inited = true;\n      this.initStatus = true;\n\n      if (!initStatus) {\n        this.handleLoadDefaults();\n      }\n\n      if (!inited) {\n        this.handleInitDefaults();\n      }\n\n      return this.recalculate();\n    });\n  },\n\n  /**\r\n   * 重新加载数据，会清空表格状态\r\n   * @param {Array} datas 数据\r\n   */\n  reloadData(datas) {\n    const inited = this.inited;\n    return this.clearAll().then(() => {\n      this.inited = true;\n      this.initStatus = true;\n      return this.loadTableData(datas);\n    }).then(() => {\n      this.handleLoadDefaults();\n\n      if (!inited) {\n        this.handleInitDefaults();\n      }\n\n      return this.recalculate();\n    });\n  },\n\n  /**\r\n   * 局部加载行数据并恢复到初始状态\r\n   * 对于行数据需要局部更改的场景中可能会用到\r\n   * @param {Row} row 行对象\r\n   * @param {Object} record 新数据\r\n   * @param {String} field 字段名\r\n   */\n  reloadRow(row, record, field) {\n    const keepSource = this.keepSource,\n          tableSourceData = this.tableSourceData,\n          tableData = this.tableData;\n\n    if (keepSource) {\n      const rowIndex = this.getRowIndex(row);\n      const oRow = tableSourceData[rowIndex];\n\n      if (oRow && row) {\n        if (field) {\n          XEUtils.set(oRow, field, XEUtils.get(record || row, field));\n        } else {\n          if (record) {\n            tableSourceData[rowIndex] = record;\n            XEUtils.clear(row, undefined);\n            Object.assign(row, this.defineField(Object.assign({}, record)));\n            this.updateCache(true);\n          } else {\n            XEUtils.destructuring(oRow, XEUtils.clone(row, true));\n          }\n        }\n      }\n\n      this.tableData = tableData.slice(0);\n    } else {\n      if (process.env.VUE_APP_VXE_TABLE_ENV === 'development') {\n        UtilTools.warn('vxe.error.reqProp', ['keep-source']);\n      }\n    }\n\n    return this.$nextTick();\n  },\n\n  /**\r\n   * 加载列配置\r\n   * 对于表格列需要重载、局部递增场景下可能会用到\r\n   * @param {ColumnInfo} columns 列配置\r\n   */\n  loadColumn(columns) {\n    const collectColumn = XEUtils.mapTree(columns, column => Cell.createColumn(this, column), {\n      children: 'children'\n    });\n    this.handleColumn(collectColumn);\n    return this.$nextTick();\n  },\n\n  /**\r\n   * 加载列配置并恢复到初始状态\r\n   * 对于表格列需要重载、局部递增场景下可能会用到\r\n   * @param {ColumnInfo} columns 列配置\r\n   */\n  reloadColumn(columns) {\n    return this.clearAll().then(() => {\n      return this.loadColumn(columns);\n    });\n  },\n\n  handleColumn(collectColumn) {\n    this.collectColumn = collectColumn;\n    const tableFullColumn = getColumnList(collectColumn);\n    this.tableFullColumn = tableFullColumn;\n    this.cacheColumnMap();\n    this.restoreCustomStorage();\n    this.parseColumns().then(() => {\n      if (this.scrollXLoad) {\n        this.loadScrollXData(true);\n      }\n    });\n    this.clearMergeCells();\n    this.clearMergeFooterItems();\n    this.handleTableData(true);\n\n    if (process.env.VUE_APP_VXE_TABLE_ENV === 'development') {\n      if ((this.scrollXLoad || this.scrollYLoad) && this.expandColumn) {\n        UtilTools.warn('vxe.error.scrollErrProp', ['column.type=expand']);\n      }\n    }\n\n    this.$nextTick(() => {\n      if (this.$toolbar) {\n        this.$toolbar.syncUpdate({\n          collectColumn,\n          $table: this\n        });\n      }\n    });\n  },\n\n  /**\r\n   * 更新数据行的 Map\r\n   * 牺牲数据组装的耗时，用来换取使用过程中的流畅\r\n   */\n  updateCache(source) {\n    const treeConfig = this.treeConfig,\n          treeOpts = this.treeOpts,\n          tableFullData = this.tableFullData,\n          fullDataRowMap = this.fullDataRowMap,\n          fullAllDataRowMap = this.fullAllDataRowMap;\n    let fullDataRowIdData = this.fullDataRowIdData,\n        fullAllDataRowIdData = this.fullAllDataRowIdData;\n    const rowkey = getRowkey(this);\n    const isLazy = treeConfig && treeOpts.lazy;\n\n    const handleCache = (row, index, items, path, parent) => {\n      let rowid = getRowid(this, row);\n\n      if (!rowid) {\n        rowid = getRowUniqueId();\n        XEUtils.set(row, rowkey, rowid);\n      }\n\n      if (isLazy && row[treeOpts.hasChild] && XEUtils.isUndefined(row[treeOpts.children])) {\n        row[treeOpts.children] = null;\n      }\n\n      const rest = {\n        row,\n        rowid,\n        index: treeConfig && parent ? -1 : index,\n        items,\n        parent\n      };\n\n      if (source) {\n        fullDataRowIdData[rowid] = rest;\n        fullDataRowMap.set(row, rest);\n      }\n\n      fullAllDataRowIdData[rowid] = rest;\n      fullAllDataRowMap.set(row, rest);\n    };\n\n    if (source) {\n      fullDataRowIdData = this.fullDataRowIdData = {};\n      fullDataRowMap.clear();\n    }\n\n    fullAllDataRowIdData = this.fullAllDataRowIdData = {};\n    fullAllDataRowMap.clear();\n\n    if (treeConfig) {\n      XEUtils.eachTree(tableFullData, handleCache, treeOpts);\n    } else {\n      tableFullData.forEach(handleCache);\n    }\n  },\n\n  loadChildren(row, childRecords) {\n    return this.createData(childRecords).then(rows => {\n      const keepSource = this.keepSource,\n            tableSourceData = this.tableSourceData,\n            treeOpts = this.treeOpts,\n            fullDataRowIdData = this.fullDataRowIdData,\n            fullDataRowMap = this.fullDataRowMap,\n            fullAllDataRowMap = this.fullAllDataRowMap,\n            fullAllDataRowIdData = this.fullAllDataRowIdData;\n      const children = treeOpts.children;\n\n      if (keepSource) {\n        const rowid = getRowid(this, row);\n        const matchObj = XEUtils.findTree(tableSourceData, item => rowid === getRowid(this, item), treeOpts);\n\n        if (matchObj) {\n          matchObj.item[children] = XEUtils.clone(rows, true);\n        }\n      }\n\n      XEUtils.eachTree(rows, (childRow, index, items, path, parent) => {\n        const rowid = getRowid(this, childRow);\n        const rest = {\n          row: childRow,\n          rowid,\n          index: -1,\n          items,\n          parent\n        };\n        fullDataRowIdData[rowid] = rest;\n        fullDataRowMap.set(childRow, rest);\n        fullAllDataRowIdData[rowid] = rest;\n        fullAllDataRowMap.set(childRow, rest);\n      }, treeOpts);\n      row[children] = rows;\n      return rows;\n    });\n  },\n\n  /**\r\n   * 更新数据列的 Map\r\n   * 牺牲数据组装的耗时，用来换取使用过程中的流畅\r\n   */\n  cacheColumnMap() {\n    const tableFullColumn = this.tableFullColumn,\n          collectColumn = this.collectColumn,\n          fullColumnMap = this.fullColumnMap,\n          showOverflow = this.showOverflow;\n    const fullColumnIdData = this.fullColumnIdData = {};\n    const fullColumnFieldData = this.fullColumnFieldData = {};\n    const isGroup = collectColumn.some(hasChildrenList);\n    let isAllOverflow = !!showOverflow;\n    let expandColumn;\n    let treeNodeColumn;\n    let checkboxColumn;\n    let radioColumn;\n    let hasFixed;\n\n    const handleFunc = (column, index, items, path, parent) => {\n      const colid = column.id,\n            property = column.property,\n            fixed = column.fixed,\n            type = column.type,\n            treeNode = column.treeNode;\n      const rest = {\n        column,\n        colid,\n        index,\n        items,\n        parent\n      };\n\n      if (property) {\n        if (process.env.VUE_APP_VXE_TABLE_ENV === 'development') {\n          if (fullColumnFieldData[property]) {\n            UtilTools.warn('vxe.error.colRepet', ['field', property]);\n          }\n        }\n\n        fullColumnFieldData[property] = rest;\n      }\n\n      if (!hasFixed && fixed) {\n        hasFixed = fixed;\n      }\n\n      if (treeNode) {\n        if (process.env.VUE_APP_VXE_TABLE_ENV === 'development') {\n          if (treeNodeColumn) {\n            UtilTools.warn('vxe.error.colRepet', ['tree-node', treeNode]);\n          }\n        }\n\n        if (!treeNodeColumn) {\n          treeNodeColumn = column;\n        }\n      } else if (type === 'expand') {\n        if (process.env.VUE_APP_VXE_TABLE_ENV === 'development') {\n          if (expandColumn) {\n            UtilTools.warn('vxe.error.colRepet', ['type', type]);\n          }\n        }\n\n        if (!expandColumn) {\n          expandColumn = column;\n        }\n      }\n\n      if (process.env.VUE_APP_VXE_TABLE_ENV === 'development') {\n        if (type === 'checkbox') {\n          if (checkboxColumn) {\n            UtilTools.warn('vxe.error.colRepet', ['type', type]);\n          }\n\n          if (!checkboxColumn) {\n            checkboxColumn = column;\n          }\n        } else if (type === 'radio') {\n          if (radioColumn) {\n            UtilTools.warn('vxe.error.colRepet', ['type', type]);\n          }\n\n          if (!radioColumn) {\n            radioColumn = column;\n          }\n        }\n      }\n\n      if (process.env.VUE_APP_VXE_TABLE_ENV === 'development') {\n        if (this.showOverflow && column.showOverflow === false) {\n          UtilTools.warn('vxe.error.errConflicts', [`table.show-overflow=${this.showOverflow}`, `column.show-overflow=${column.showOverflow}`]);\n        }\n\n        if (this.showHeaderOverflow && column.showHeaderOverflow === false) {\n          UtilTools.warn('vxe.error.errConflicts', [`table.show-header-overflow=${this.showHeaderOverflow}`, `column.show-header-overflow=${column.showHeaderOverflow}`]);\n        }\n\n        if (this.showFooterOverflow && column.showFooterOverflow === false) {\n          UtilTools.warn('vxe.error.errConflicts', [`table.show-footer-overflow=${this.showFooterOverflow}`, `column.show-footer-overflow=${column.showFooterOverflow}`]);\n        }\n      }\n\n      if (isAllOverflow && column.showOverflow === false) {\n        isAllOverflow = false;\n      }\n\n      if (fullColumnIdData[colid]) {\n        UtilTools.error('vxe.error.colRepet', ['colId', colid]);\n      }\n\n      fullColumnIdData[colid] = rest;\n      fullColumnMap.set(column, rest);\n    };\n\n    fullColumnMap.clear();\n\n    if (isGroup) {\n      XEUtils.eachTree(collectColumn, (column, index, items, path, parent, nodes) => {\n        column.level = nodes.length;\n        handleFunc(column, index, items, path, parent);\n      });\n    } else {\n      tableFullColumn.forEach(handleFunc);\n    }\n\n    if (process.env.VUE_APP_VXE_TABLE_ENV === 'development') {\n      if (expandColumn && this.mouseOpts.area) {\n        UtilTools.error('vxe.error.errConflicts', ['mouse-config.area', 'column.type=expand']);\n      }\n    }\n\n    this.isGroup = isGroup;\n    this.treeNodeColumn = treeNodeColumn;\n    this.expandColumn = expandColumn;\n    this.isAllOverflow = isAllOverflow;\n  },\n\n  /**\r\n   * 根据 tr 元素获取对应的 row 信息\r\n   * @param {Element} tr 元素\r\n   */\n  getRowNode(tr) {\n    if (tr) {\n      const fullAllDataRowIdData = this.fullAllDataRowIdData;\n      const rowid = tr.getAttribute('rowid');\n      const rest = fullAllDataRowIdData[rowid];\n\n      if (rest) {\n        return {\n          rowid: rest.rowid,\n          item: rest.row,\n          index: rest.index,\n          items: rest.items,\n          parent: rest.parent\n        };\n      }\n    }\n\n    return null;\n  },\n\n  /**\r\n   * 根据 th/td 元素获取对应的 column 信息\r\n   * @param {Element} cell 元素\r\n   */\n  getColumnNode(cell) {\n    if (cell) {\n      const fullColumnIdData = this.fullColumnIdData;\n      const colid = cell.getAttribute('colid');\n      const rest = fullColumnIdData[colid];\n\n      if (rest) {\n        return {\n          colid: rest.colid,\n          item: rest.column,\n          index: rest.index,\n          items: rest.items,\n          parent: rest.parent\n        };\n      }\n    }\n\n    return null;\n  },\n\n  /**\r\n   * 根据 row 获取相对于 data 中的索引\r\n   * @param {Row} row 行对象\r\n   */\n  getRowIndex(row) {\n    return this.fullDataRowMap.has(row) ? this.fullDataRowMap.get(row).index : -1;\n  },\n\n  /**\r\n   * 根据 row 获取相对于当前数据中的索引\r\n   * @param {Row} row 行对象\r\n   */\n  getVTRowIndex(row) {\n    return this.afterFullData.indexOf(row);\n  },\n\n  // 在 v3 中废弃\n  _getRowIndex(row) {\n    if (process.env.VUE_APP_VXE_TABLE_ENV === 'development') {\n      UtilTools.warn('vxe.error.delFunc', ['_getRowIndex', 'getVTRowIndex']);\n    }\n\n    return this.getVTRowIndex(row);\n  },\n\n  /**\r\n   * 根据 row 获取渲染中的虚拟索引\r\n   * @param {Row} row 行对象\r\n   */\n  getVMRowIndex(row) {\n    return this.tableData.indexOf(row);\n  },\n\n  // 在 v3 中废弃\n  $getRowIndex(row) {\n    if (process.env.VUE_APP_VXE_TABLE_ENV === 'development') {\n      UtilTools.warn('vxe.error.delFunc', ['$getRowIndex', 'getVMRowIndex']);\n    }\n\n    return this.getVMRowIndex(row);\n  },\n\n  /**\r\n   * 根据 column 获取相对于 columns 中的索引\r\n   * @param {ColumnInfo} column 列配置\r\n   */\n  getColumnIndex(column) {\n    return this.fullColumnMap.has(column) ? this.fullColumnMap.get(column).index : -1;\n  },\n\n  /**\r\n   * 根据 column 获取相对于当前表格列中的索引\r\n   * @param {ColumnInfo} column 列配置\r\n   */\n  getVTColumnIndex(column) {\n    return this.visibleColumn.indexOf(column);\n  },\n\n  // 在 v3 中废弃\n  _getColumnIndex(column) {\n    if (process.env.VUE_APP_VXE_TABLE_ENV === 'development') {\n      UtilTools.warn('vxe.error.delFunc', ['_getColumnIndex', 'getVTColumnIndex']);\n    }\n\n    return this.getVTColumnIndex(column);\n  },\n\n  /**\r\n   * 根据 column 获取渲染中的虚拟索引\r\n   * @param {ColumnInfo} column 列配置\r\n   */\n  getVMColumnIndex(column) {\n    return this.tableColumn.indexOf(column);\n  },\n\n  // 在 v3 中废弃\n  $getColumnIndex(column) {\n    if (process.env.VUE_APP_VXE_TABLE_ENV === 'development') {\n      UtilTools.warn('vxe.error.delFunc', ['$getColumnIndex', 'getVMColumnIndex']);\n    }\n\n    return this.getVMColumnIndex(column);\n  },\n\n  /**\r\n   * 判断是否为索引列\r\n   * @param {ColumnInfo} column 列配置\r\n   */\n  isSeqColumn(column) {\n    return column && (column.type === 'seq' || column.type === 'index');\n  },\n\n  /**\r\n   * 定义行数据中的列属性，如果不存在则定义\r\n   * @param {Row} record 行数据\r\n   */\n  defineField(record) {\n    const radioOpts = this.radioOpts,\n          checkboxOpts = this.checkboxOpts,\n          treeConfig = this.treeConfig,\n          treeOpts = this.treeOpts,\n          expandOpts = this.expandOpts;\n    const rowkey = getRowkey(this);\n    this.visibleColumn.forEach(_ref => {\n      let property = _ref.property,\n          editRender = _ref.editRender;\n\n      if (property && !XEUtils.has(record, property)) {\n        XEUtils.set(record, property, editRender && !XEUtils.isUndefined(editRender.defaultValue) ? editRender.defaultValue : null);\n      }\n    });\n    const ohterFields = [radioOpts.labelField, checkboxOpts.checkField, checkboxOpts.labelField, expandOpts.labelField];\n    ohterFields.forEach(key => {\n      if (key && !XEUtils.get(record, key)) {\n        XEUtils.set(record, key, null);\n      }\n    });\n\n    if (treeConfig && treeOpts.lazy && XEUtils.isUndefined(record[treeOpts.children])) {\n      record[treeOpts.children] = null;\n    } // 必须有行数据的唯一主键，可以自行设置；也可以默认生成一个随机数\n\n\n    if (!XEUtils.get(record, rowkey)) {\n      XEUtils.set(record, rowkey, getRowUniqueId());\n    }\n\n    return record;\n  },\n\n  /**\r\n   * 创建 data 对象\r\n   * 对于某些特殊场景可能会用到，会自动对数据的字段名进行检测，如果不存在就自动定义\r\n   * @param {Array} records 新数据\r\n   */\n  createData(records) {\n    const treeConfig = this.treeConfig,\n          treeOpts = this.treeOpts;\n\n    const handleRrecord = record => this.defineField(Object.assign({}, record));\n\n    const rows = treeConfig ? XEUtils.mapTree(records, handleRrecord, treeOpts) : records.map(handleRrecord);\n    return this.$nextTick().then(() => rows);\n  },\n\n  /**\r\n   * 创建 Row|Rows 对象\r\n   * 对于某些特殊场景需要对数据进行手动插入时可能会用到\r\n   * @param {Array/Object} records 新数据\r\n   */\n  createRow(records) {\n    const isArr = XEUtils.isArray(records);\n\n    if (!isArr) {\n      records = [records];\n    }\n\n    return this.$nextTick().then(() => this.createData(records).then(rows => isArr ? rows : rows[0]));\n  },\n\n  /**\r\n   * 还原数据\r\n   * 如果不传任何参数，则还原整个表格\r\n   * 如果传 row 则还原一行\r\n   * 如果传 rows 则还原多行\r\n   * 如果还额外传了 field 则还原指定的单元格数据\r\n   */\n  revertData(rows, field) {\n    const keepSource = this.keepSource,\n          tableSourceData = this.tableSourceData,\n          treeConfig = this.treeConfig;\n\n    if (!keepSource) {\n      if (process.env.VUE_APP_VXE_TABLE_ENV === 'development') {\n        UtilTools.warn('vxe.error.reqProp', ['keep-source']);\n      }\n\n      return this.$nextTick();\n    }\n\n    let targetRows = rows;\n\n    if (rows) {\n      if (!XEUtils.isArray(rows)) {\n        targetRows = [rows];\n      }\n    } else {\n      targetRows = XEUtils.toArray(this.getUpdateRecords());\n    }\n\n    if (targetRows.length) {\n      targetRows.forEach(row => {\n        if (!this.isInsertByRow(row)) {\n          const rowIndex = this.getRowIndex(row);\n\n          if (treeConfig && rowIndex === -1) {\n            throw new Error(UtilTools.getLog('vxe.error.noTree', ['revertData']));\n          }\n\n          const oRow = tableSourceData[rowIndex];\n\n          if (oRow && row) {\n            if (field) {\n              XEUtils.set(row, field, XEUtils.clone(XEUtils.get(oRow, field), true));\n            } else {\n              XEUtils.destructuring(row, XEUtils.clone(oRow, true));\n            }\n          }\n        }\n      });\n    }\n\n    if (rows) {\n      return this.$nextTick();\n    }\n\n    return this.reloadData(tableSourceData);\n  },\n\n  /**\r\n   * 清空单元格内容\r\n   * 如果不创参数，则清空整个表格内容\r\n   * 如果传 row 则清空一行内容\r\n   * 如果传 rows 则清空多行内容\r\n   * 如果还额外传了 field 则清空指定单元格内容\r\n   * @param {Array/Row} rows 行数据\r\n   * @param {String} field 字段名\r\n   */\n  clearData(rows, field) {\n    const tableFullData = this.tableFullData,\n          visibleColumn = this.visibleColumn;\n\n    if (!arguments.length) {\n      rows = tableFullData;\n    } else if (rows && !XEUtils.isArray(rows)) {\n      rows = [rows];\n    }\n\n    if (field) {\n      rows.forEach(row => XEUtils.set(row, field, null));\n    } else {\n      rows.forEach(row => {\n        visibleColumn.forEach(column => {\n          if (column.property) {\n            setCellValue(row, column, null);\n          }\n        });\n      });\n    }\n\n    return this.$nextTick();\n  },\n\n  /**\r\n   * 检查是否为临时行数据\r\n   * @param {Row} row 行对象\r\n   */\n  isInsertByRow(row) {\n    return this.editStore.insertList.indexOf(row) > -1;\n  },\n\n  /**\r\n   * 检查行或列数据是否发生改变\r\n   * @param {Row} row 行对象\r\n   * @param {String} field 字段名\r\n   */\n  isUpdateByRow(row, field) {\n    const visibleColumn = this.visibleColumn,\n          keepSource = this.keepSource,\n          treeConfig = this.treeConfig,\n          treeOpts = this.treeOpts,\n          tableSourceData = this.tableSourceData,\n          fullDataRowIdData = this.fullDataRowIdData;\n\n    if (keepSource) {\n      let oRow, property;\n      const rowid = getRowid(this, row); // 新增的数据不需要检测\n\n      if (!fullDataRowIdData[rowid]) {\n        return false;\n      }\n\n      if (treeConfig) {\n        const children = treeOpts.children;\n        const matchObj = XEUtils.findTree(tableSourceData, item => rowid === getRowid(this, item), treeOpts);\n        row = Object.assign({}, row, {\n          [children]: null\n        });\n\n        if (matchObj) {\n          oRow = Object.assign({}, matchObj.item, {\n            [children]: null\n          });\n        }\n      } else {\n        const oRowIndex = fullDataRowIdData[rowid].index;\n        oRow = tableSourceData[oRowIndex];\n      }\n\n      if (oRow) {\n        if (arguments.length > 1) {\n          return !eqCellValue(oRow, row, field);\n        }\n\n        for (let index = 0, len = visibleColumn.length; index < len; index++) {\n          property = visibleColumn[index].property;\n\n          if (property && !eqCellValue(oRow, row, property)) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  },\n\n  /**\r\n   * 获取表格的可视列，也可以指定索引获取列\r\n   * @param {Number} columnIndex 索引\r\n   */\n  getColumns(columnIndex) {\n    const columns = this.visibleColumn;\n    return XEUtils.isUndefined(columnIndex) ? columns.slice(0) : columns[columnIndex];\n  },\n\n  /**\r\n   * 根据列的唯一主键获取列\r\n   * @param {String} colid 列主键\r\n   */\n  getColumnById(colid) {\n    const fullColumnIdData = this.fullColumnIdData;\n    return fullColumnIdData[colid] ? fullColumnIdData[colid].column : null;\n  },\n\n  /**\r\n   * 根据列的字段名获取列\r\n   * @param {String} field 字段名\r\n   */\n  getColumnByField(field) {\n    const fullColumnFieldData = this.fullColumnFieldData;\n    return fullColumnFieldData[field] ? fullColumnFieldData[field].column : null;\n  },\n\n  /**\r\n   * 获取当前表格的列\r\n   * 收集到的全量列、全量表头列、处理条件之后的全量表头列、当前渲染中的表头列\r\n   */\n  getTableColumn() {\n    return {\n      collectColumn: this.collectColumn.slice(0),\n      fullColumn: this.tableFullColumn.slice(0),\n      visibleColumn: this.visibleColumn.slice(0),\n      tableColumn: this.tableColumn.slice(0)\n    };\n  },\n\n  /**\r\n   * 获取数据，和 data 的行为一致，也可以指定索引获取数据\r\n   */\n  getData(rowIndex) {\n    const tableSynchData = this.data || this.tableSynchData;\n    return XEUtils.isUndefined(rowIndex) ? tableSynchData.slice(0) : tableSynchData[rowIndex];\n  },\n\n  /**\r\n   * 用于多选行，获取已选中的数据\r\n   */\n  getCheckboxRecords() {\n    const tableFullData = this.tableFullData,\n          treeConfig = this.treeConfig,\n          treeOpts = this.treeOpts,\n          checkboxOpts = this.checkboxOpts;\n    const property = checkboxOpts.checkField;\n    let rowList = [];\n\n    if (property) {\n      if (treeConfig) {\n        rowList = XEUtils.filterTree(tableFullData, row => XEUtils.get(row, property), treeOpts);\n      } else {\n        rowList = tableFullData.filter(row => XEUtils.get(row, property));\n      }\n    } else {\n      const selection = this.selection;\n\n      if (treeConfig) {\n        rowList = XEUtils.filterTree(tableFullData, row => selection.indexOf(row) > -1, treeOpts);\n      } else {\n        rowList = tableFullData.filter(row => selection.indexOf(row) > -1);\n      }\n    }\n\n    return rowList;\n  },\n\n  /**\r\n   * 获取处理后全量的表格数据\r\n   * 如果存在筛选条件，继续处理\r\n   */\n  updateAfterFullData() {\n    const tableFullColumn = this.tableFullColumn,\n          tableFullData = this.tableFullData,\n          filterOpts = this.filterOpts,\n          sortOpts = this.sortOpts;\n    const allRemoteFilter = filterOpts.remote,\n          allFilterMethod = filterOpts.filterMethod;\n    const allRemoteSort = sortOpts.remote,\n          allSortMethod = sortOpts.sortMethod,\n          sortMultiple = sortOpts.multiple;\n    let tableData = tableFullData.slice(0);\n    const filterColumns = [];\n    const orderColumns = [];\n    tableFullColumn.forEach(column => {\n      const sortable = column.sortable,\n            order = column.order,\n            filters = column.filters;\n\n      if (!allRemoteFilter && filters && filters.length) {\n        const valueList = [];\n        const itemList = [];\n        filters.forEach(item => {\n          if (item.checked) {\n            itemList.push(item);\n            valueList.push(item.value);\n          }\n        });\n\n        if (itemList.length) {\n          filterColumns.push({\n            column,\n            valueList,\n            itemList\n          });\n        }\n      }\n\n      if (!allRemoteSort && sortable && order) {\n        orderColumns.push({\n          column,\n          property: column.property,\n          order\n        });\n      }\n    });\n\n    if (filterColumns.length) {\n      tableData = tableData.filter(row => {\n        return filterColumns.every(_ref2 => {\n          let column = _ref2.column,\n              valueList = _ref2.valueList,\n              itemList = _ref2.itemList;\n\n          if (valueList.length && !allRemoteFilter) {\n            const filterMethod = column.filterMethod,\n                  filterRender = column.filterRender;\n            const compConf = filterRender ? VXETable.renderer.get(filterRender.name) : null;\n            const compFilterMethod = compConf && compConf.renderFilter ? compConf.filterMethod : null;\n            const cellValue = UtilTools.getCellValue(row, column);\n\n            if (filterMethod) {\n              return itemList.some(item => filterMethod({\n                value: item.value,\n                option: item,\n                cellValue,\n                row,\n                column,\n                $table: this\n              }));\n            } else if (compFilterMethod) {\n              return itemList.some(item => compFilterMethod({\n                value: item.value,\n                option: item,\n                cellValue,\n                row,\n                column,\n                $table: this\n              }));\n            } else if (allFilterMethod) {\n              return allFilterMethod({\n                options: itemList,\n                values: valueList,\n                cellValue,\n                row,\n                column\n              });\n            }\n\n            return valueList.indexOf(XEUtils.get(row, column.property)) > -1;\n          }\n\n          return true;\n        });\n      });\n    }\n\n    const firstOrderColumn = orderColumns[0];\n\n    if (!allRemoteSort && firstOrderColumn) {\n      if (allSortMethod) {\n        const sortRests = allSortMethod({\n          data: tableData,\n          column: firstOrderColumn.column,\n          property: firstOrderColumn.property,\n          order: firstOrderColumn.order,\n          sortList: orderColumns,\n          $table: this\n        });\n        tableData = XEUtils.isArray(sortRests) ? sortRests : tableData;\n      } else {\n        // 兼容 v4\n        if (sortMultiple) {\n          tableData = XEUtils.orderBy(tableData, orderColumns.map(_ref3 => {\n            let column = _ref3.column,\n                order = _ref3.order;\n            return [getOrderField(this, column), order];\n          }));\n        } else {\n          let column = firstOrderColumn.column,\n              rest = null;\n\n          if (column.sortMethod) {\n            rest = tableData.sort(column.sortMethod);\n          } else if (column.sortBy) {\n            rest = arraySort(tableData, column.sortBy, true);\n          } else if (column.formatter && column.sortByFormatter) {\n            let params = {\n              $table: this,\n              column: column\n            };\n            rest = tableData.sort((row1, row2) => {\n              params.row = row1;\n              row1 = this.getCellLabel(row1, column, params);\n              params.row = row2;\n              row2 = this.getCellLabel(row2, column, params);\n              return compare(row1, row2);\n            });\n          } else if (column.property) {\n            rest = arraySort(tableData, column.property, true);\n          } else {\n            rest = tableData;\n          }\n\n          tableData = column.order === 'desc' ? rest.reverse() : rest; //        \t\n          //          // 兼容 v2，在 v4 中废弃， sortBy 不能为数组\n          //          let sortByConfs\n          //          if (XEUtils.isArray(firstOrderColumn.sortBy)) {\n          //            sortByConfs = firstOrderColumn.sortBy.map(item => [item, firstOrderColumn.order])\n          //          }\n          //          tableData = XEUtils.orderBy(tableData, sortByConfs || [firstOrderColumn].map(({ column, order }) => [getOrderField(this, column), order]))\n        }\n      }\n    }\n\n    this.afterFullData = tableData;\n    return tableData;\n  },\n\n  /**\r\n   * 根据行的唯一主键获取行\r\n   * @param {String/Number} rowid 行主键\r\n   */\n  getRowById(rowid) {\n    const fullDataRowIdData = this.fullDataRowIdData;\n    return fullDataRowIdData[rowid] ? fullDataRowIdData[rowid].row : null;\n  },\n\n  /**\r\n   * 根据行获取行的唯一主键\r\n   * @param {Row} row 行对象\r\n   */\n  getRowid(row) {\n    const fullAllDataRowMap = this.fullAllDataRowMap;\n    return fullAllDataRowMap.has(row) ? fullAllDataRowMap.get(row).rowid : null;\n  },\n\n  /**\r\n   * 获取处理后的表格数据\r\n   * 如果存在筛选条件，继续处理\r\n   * 如果存在排序，继续处理\r\n   */\n  getTableData() {\n    const tableFullData = this.tableFullData,\n          afterFullData = this.afterFullData,\n          tableData = this.tableData,\n          footerTableData = this.footerTableData;\n    return {\n      fullData: tableFullData.slice(0),\n      visibleData: afterFullData.slice(0),\n      tableData: tableData.slice(0),\n      footerData: footerTableData.slice(0)\n    };\n  },\n\n  /**\r\n   * 处理数据加载默认行为\r\n   * 默认执行一次，除非被重置\r\n   */\n  handleLoadDefaults() {\n    if (this.checkboxConfig) {\n      this.handleDefaultSelectionChecked();\n    }\n\n    if (this.radioConfig) {\n      this.handleDefaultRadioChecked();\n    }\n\n    if (this.expandConfig) {\n      this.handleDefaultRowExpand();\n    }\n\n    if (this.treeConfig) {\n      this.handleDefaultTreeExpand();\n    }\n\n    if (this.mergeCells) {\n      this.handleDefaultMergeCells();\n    }\n\n    if (this.mergeFooterItems) {\n      this.handleDefaultMergeFooterItems();\n    }\n\n    this.$nextTick(() => setTimeout(this.recalculate));\n  },\n\n  /**\r\n   * 处理初始化的默认行为\r\n   * 只会执行一次\r\n   */\n  handleInitDefaults() {\n    const sortConfig = this.sortConfig;\n\n    if (sortConfig) {\n      this.handleDefaultSort();\n    }\n  },\n\n  /**\r\n   * 隐藏指定列\r\n   */\n  hideColumn(fieldOrColumn) {\n    const column = handleFieldOrColumn(this, fieldOrColumn);\n\n    if (column) {\n      column.visible = false;\n    }\n\n    return this.handleCustom();\n  },\n\n  /**\r\n   * 显示指定列\r\n   */\n  showColumn(fieldOrColumn) {\n    const column = handleFieldOrColumn(this, fieldOrColumn);\n\n    if (column) {\n      column.visible = true;\n    }\n\n    return this.handleCustom();\n  },\n\n  /**\r\n   * 手动重置列的显示隐藏、列宽拖动的状态；\r\n   * 如果为 true 则重置所有状态\r\n   * 如果已关联工具栏，则会同步更新\r\n   */\n  resetColumn(options) {\n    const customOpts = this.customOpts;\n    const checkMethod = customOpts.checkMethod;\n    const opts = Object.assign({\n      visible: true,\n      resizable: options === true\n    }, options);\n    this.tableFullColumn.forEach(column => {\n      if (opts.resizable) {\n        column.resizeWidth = 0;\n      }\n\n      if (!checkMethod || checkMethod({\n        column\n      })) {\n        column.visible = column.defaultVisible;\n      }\n    });\n\n    if (opts.resizable) {\n      this.saveCustomResizable(true);\n    }\n\n    return this.handleCustom();\n  },\n\n  handleCustom() {\n    this.saveCustomVisible();\n    this.analyColumnWidth();\n    return this.refreshColumn();\n  },\n\n  /**\r\n   * 还原自定义列操作状态\r\n   */\n  restoreCustomStorage() {\n    const id = this.id,\n          collectColumn = this.collectColumn,\n          customConfig = this.customConfig,\n          customOpts = this.customOpts;\n    const storage = customOpts.storage;\n    const isAllStorage = customOpts.storage === true;\n    const isResizable = isAllStorage || storage && storage.resizable;\n    const isVisible = isAllStorage || storage && storage.visible;\n\n    if (customConfig && (isResizable || isVisible)) {\n      const customMap = {};\n\n      if (!id) {\n        UtilTools.error('vxe.error.reqProp', ['id']);\n        return;\n      }\n\n      if (isResizable) {\n        const columnWidthStorage = getCustomStorageMap(resizableStorageKey)[id];\n\n        if (columnWidthStorage) {\n          XEUtils.each(columnWidthStorage, (resizeWidth, field) => {\n            customMap[field] = {\n              field,\n              resizeWidth\n            };\n          });\n        }\n      }\n\n      if (isVisible) {\n        const columnVisibleStorage = getCustomStorageMap(visibleStorageKey)[id];\n\n        if (columnVisibleStorage) {\n          const colVisibles = columnVisibleStorage.split('|');\n          const colHides = colVisibles[0] ? colVisibles[0].split(',') : [];\n          const colShows = colVisibles[1] ? colVisibles[1].split(',') : [];\n          colHides.forEach(field => {\n            if (customMap[field]) {\n              customMap[field].visible = false;\n            } else {\n              customMap[field] = {\n                field,\n                visible: false\n              };\n            }\n          });\n          colShows.forEach(field => {\n            if (customMap[field]) {\n              customMap[field].visible = true;\n            } else {\n              customMap[field] = {\n                field,\n                visible: true\n              };\n            }\n          });\n        }\n      }\n\n      const keyMap = {};\n      XEUtils.eachTree(collectColumn, column => {\n        const colKey = column.getKey();\n\n        if (colKey) {\n          keyMap[colKey] = column;\n        }\n      });\n      XEUtils.each(customMap, (_ref4, field) => {\n        let visible = _ref4.visible,\n            resizeWidth = _ref4.resizeWidth;\n        const column = keyMap[field];\n\n        if (column) {\n          if (XEUtils.isNumber(resizeWidth)) {\n            column.resizeWidth = resizeWidth;\n          }\n\n          if (XEUtils.isBoolean(visible)) {\n            column.visible = visible;\n          }\n        }\n      });\n    }\n  },\n\n  saveCustomVisible() {\n    const id = this.id,\n          collectColumn = this.collectColumn,\n          customConfig = this.customConfig,\n          customOpts = this.customOpts;\n    const checkMethod = customOpts.checkMethod,\n          storage = customOpts.storage;\n    const isAllStorage = customOpts.storage === true;\n    const isVisible = isAllStorage || storage && storage.visible;\n\n    if (customConfig && isVisible) {\n      const columnVisibleStorageMap = getCustomStorageMap(visibleStorageKey);\n      const colHides = [];\n      const colShows = [];\n\n      if (!id) {\n        UtilTools.error('vxe.error.reqProp', ['id']);\n        return;\n      }\n\n      XEUtils.eachTree(collectColumn, column => {\n        if (!checkMethod || checkMethod({\n          column\n        })) {\n          if (!column.visible && column.defaultVisible) {\n            const colKey = column.getKey();\n\n            if (colKey) {\n              colHides.push(colKey);\n            }\n          } else if (column.visible && !column.defaultVisible) {\n            const colKey = column.getKey();\n\n            if (colKey) {\n              colShows.push(colKey);\n            }\n          }\n        }\n      });\n      columnVisibleStorageMap[id] = [colHides.join(',')].concat(colShows.length ? [colShows.join(',')] : []).join('|') || undefined;\n      localStorage.setItem(visibleStorageKey, XEUtils.toJSONString(columnVisibleStorageMap));\n    }\n  },\n\n  saveCustomResizable(isReset) {\n    const id = this.id,\n          collectColumn = this.collectColumn,\n          customConfig = this.customConfig,\n          customOpts = this.customOpts;\n    const storage = customOpts.storage;\n    const isAllStorage = customOpts.storage === true;\n    const isResizable = isAllStorage || storage && storage.resizable;\n\n    if (customConfig && isResizable) {\n      const columnWidthStorageMap = getCustomStorageMap(resizableStorageKey);\n      let columnWidthStorage;\n\n      if (!id) {\n        UtilTools.error('vxe.error.reqProp', ['id']);\n        return;\n      }\n\n      if (!isReset) {\n        columnWidthStorage = XEUtils.isPlainObject(columnWidthStorageMap[id]) ? columnWidthStorageMap[id] : {};\n        XEUtils.eachTree(collectColumn, column => {\n          if (column.resizeWidth) {\n            const colKey = column.getKey();\n\n            if (colKey) {\n              columnWidthStorage[colKey] = column.renderWidth;\n            }\n          }\n        });\n      }\n\n      columnWidthStorageMap[id] = XEUtils.isEmpty(columnWidthStorage) ? undefined : columnWidthStorage;\n      localStorage.setItem(resizableStorageKey, XEUtils.toJSONString(columnWidthStorageMap));\n    }\n  },\n\n  /**\r\n   * 刷新列配置\r\n   */\n  refreshColumn() {\n    return this.parseColumns().then(() => {\n      return this.refreshScroll();\n    }).then(() => {\n      return this.recalculate();\n    });\n  },\n\n  /**\r\n   * 刷新列信息\r\n   * 将固定的列左边、右边分别靠边\r\n   */\n  parseColumns() {\n    const leftList = [];\n    const centerList = [];\n    const rightList = [];\n    const collectColumn = this.collectColumn,\n          tableFullColumn = this.tableFullColumn,\n          isGroup = this.isGroup,\n          columnStore = this.columnStore,\n          sXOpts = this.sXOpts,\n          scrollXStore = this.scrollXStore; // 如果是分组表头，如果子列全部被隐藏，则根列也隐藏\n\n    if (isGroup) {\n      const leftGroupList = [];\n      const centerGroupList = [];\n      const rightGroupList = [];\n      XEUtils.eachTree(collectColumn, (column, index, items, path, parent) => {\n        const isColGroup = hasChildrenList(column); // 如果是分组，必须按组设置固定列，不允许给子列设置固定\n\n        if (parent && parent.fixed) {\n          column.fixed = parent.fixed;\n        }\n\n        if (parent && column.fixed !== parent.fixed) {\n          UtilTools.error('vxe.error.groupFixed');\n        }\n\n        if (isColGroup) {\n          column.visible = !!XEUtils.findTree(column.children, subColumn => hasChildrenList(subColumn) ? null : subColumn.visible);\n        } else if (column.visible) {\n          if (column.fixed === 'left') {\n            leftList.push(column);\n          } else if (column.fixed === 'right') {\n            rightList.push(column);\n          } else {\n            centerList.push(column);\n          }\n        }\n      });\n      collectColumn.forEach(column => {\n        if (column.visible) {\n          if (column.fixed === 'left') {\n            leftGroupList.push(column);\n          } else if (column.fixed === 'right') {\n            rightGroupList.push(column);\n          } else {\n            centerGroupList.push(column);\n          }\n        }\n      });\n      this.tableGroupColumn = leftGroupList.concat(centerGroupList).concat(rightGroupList);\n    } else {\n      // 重新分配列\n      tableFullColumn.forEach(column => {\n        if (column.visible) {\n          if (column.fixed === 'left') {\n            leftList.push(column);\n          } else if (column.fixed === 'right') {\n            rightList.push(column);\n          } else {\n            centerList.push(column);\n          }\n        }\n      });\n    }\n\n    const visibleColumn = leftList.concat(centerList).concat(rightList);\n    let scrollXLoad = sXOpts.enabled && sXOpts.gt > -1 && sXOpts.gt < tableFullColumn.length;\n    this.hasFixedColumn = leftList.length > 0 || rightList.length > 0;\n    Object.assign(columnStore, {\n      leftList,\n      centerList,\n      rightList\n    });\n\n    if (scrollXLoad && isGroup) {\n      scrollXLoad = false;\n\n      if (process.env.VUE_APP_VXE_TABLE_ENV === 'development') {\n        UtilTools.warn('vxe.error.scrollXNotGroup');\n      }\n    }\n\n    if (scrollXLoad) {\n      if (process.env.VUE_APP_VXE_TABLE_ENV === 'development') {\n        if (this.showHeader && !this.showHeaderOverflow) {\n          UtilTools.warn('vxe.error.reqProp', ['show-header-overflow']);\n        }\n\n        if (this.showFooter && !this.showFooterOverflow) {\n          UtilTools.warn('vxe.error.reqProp', ['show-footer-overflow']);\n        }\n\n        if (this.spanMethod) {\n          UtilTools.warn('vxe.error.scrollErrProp', ['span-method']);\n        }\n\n        if (this.footerSpanMethod) {\n          UtilTools.warn('vxe.error.scrollErrProp', ['footer-span-method']);\n        }\n      }\n\n      const _computeVirtualX = computeVirtualX(this),\n            visibleSize = _computeVirtualX.visibleSize;\n\n      scrollXStore.startIndex = 0;\n      scrollXStore.endIndex = visibleSize;\n      scrollXStore.visibleSize = visibleSize;\n    } // 如果列被显示/隐藏，则清除合并状态\n    // 如果列被设置为固定，则清除合并状态\n\n\n    if (visibleColumn.length !== this.visibleColumn.length || !this.visibleColumn.every((column, index) => column === visibleColumn[index])) {\n      this.clearMergeCells();\n      this.clearMergeFooterItems();\n    }\n\n    this.scrollXLoad = scrollXLoad;\n    this.visibleColumn = visibleColumn;\n    this.handleTableColumn();\n    return this.updateFooter().then(() => {\n      return this.recalculate();\n    }).then(() => {\n      this.updateCellAreas();\n      return this.recalculate();\n    });\n  },\n\n  /**\r\n   * 指定列宽的列进行拆分\r\n   */\n  analyColumnWidth() {\n    const columnOpts = this.columnOpts;\n    const defaultWidth = columnOpts.width,\n          defaultMinWidth = columnOpts.minWidth;\n    const resizeList = [];\n    const pxList = [];\n    const pxMinList = [];\n    const scaleList = [];\n    const scaleMinList = [];\n    const autoList = [];\n    this.tableFullColumn.forEach(column => {\n      if (defaultWidth && !column.width) {\n        column.width = defaultWidth;\n      }\n\n      if (defaultMinWidth && !column.minWidth) {\n        column.minWidth = defaultMinWidth;\n      }\n\n      if (column.visible) {\n        if (column.resizeWidth) {\n          resizeList.push(column);\n        } else if (DomTools.isPx(column.width)) {\n          pxList.push(column);\n        } else if (DomTools.isScale(column.width)) {\n          scaleList.push(column);\n        } else if (DomTools.isPx(column.minWidth)) {\n          pxMinList.push(column);\n        } else if (DomTools.isScale(column.minWidth)) {\n          scaleMinList.push(column);\n        } else {\n          autoList.push(column);\n        }\n      }\n    });\n    Object.assign(this.columnStore, {\n      resizeList,\n      pxList,\n      pxMinList,\n      scaleList,\n      scaleMinList,\n      autoList\n    });\n  },\n\n  /**\r\n   * 刷新滚动操作，手动同步滚动相关位置（对于某些特殊的操作，比如滚动条错位、固定列不同步）\r\n   */\n  refreshScroll() {\n    const lastScrollLeft = this.lastScrollLeft,\n          lastScrollTop = this.lastScrollTop;\n    const $refs = this.$refs;\n    const tableBody = $refs.tableBody,\n          leftBody = $refs.leftBody,\n          rightBody = $refs.rightBody,\n          tableFooter = $refs.tableFooter;\n    const tableBodyElem = tableBody ? tableBody.$el : null;\n    const leftBodyElem = leftBody ? leftBody.$el : null;\n    const rightBodyElem = rightBody ? rightBody.$el : null;\n    const tableFooterElem = tableFooter ? tableFooter.$el : null; // 还原滚动条位置\n\n    if (lastScrollLeft || lastScrollTop) {\n      return restoreScroll(this, lastScrollLeft, lastScrollTop);\n    } // 重置\n\n\n    setScrollTop(tableBodyElem, lastScrollTop);\n    setScrollTop(leftBodyElem, lastScrollTop);\n    setScrollTop(rightBodyElem, lastScrollTop);\n    setScrollLeft(tableFooterElem, lastScrollLeft);\n  },\n\n  /**\r\n   * 计算单元格列宽，动态分配可用剩余空间\r\n   * 支持 width=? width=?px width=?% min-width=? min-width=?px min-width=?%\r\n   */\n  recalculate(refull) {\n    const $refs = this.$refs;\n    const tableBody = $refs.tableBody,\n          tableHeader = $refs.tableHeader,\n          tableFooter = $refs.tableFooter;\n    const bodyElem = tableBody ? tableBody.$el : null;\n    const headerElem = tableHeader ? tableHeader.$el : null;\n    const footerElem = tableFooter ? tableFooter.$el : null;\n\n    if (bodyElem) {\n      this.autoCellWidth(headerElem, bodyElem, footerElem);\n\n      if (refull === true) {\n        // 初始化时需要在列计算之后再执行优化运算，达到最优显示效果\n        return this.computeScrollLoad().then(() => {\n          this.autoCellWidth(headerElem, bodyElem, footerElem);\n          return this.computeScrollLoad();\n        });\n      }\n    }\n\n    return this.computeScrollLoad();\n  },\n\n  /**\r\n   * 列宽算法\r\n   * 支持 px、%、固定 混合分配\r\n   * 支持动态列表调整分配\r\n   * 支持自动分配偏移量\r\n   * @param {Element} headerElem\r\n   * @param {Element} bodyElem\r\n   * @param {Element} footerElem\r\n   * @param {Number} bodyWidth\r\n   */\n  autoCellWidth(headerElem, bodyElem, footerElem) {\n    let tableWidth = 0;\n    const minCellWidth = 40; // 列宽最少限制 40px\n\n    const bodyWidth = bodyElem.clientWidth - 1;\n    let remainWidth = bodyWidth;\n    let meanWidth = remainWidth / 100;\n    const fit = this.fit,\n          columnStore = this.columnStore;\n    const resizeList = columnStore.resizeList,\n          pxMinList = columnStore.pxMinList,\n          pxList = columnStore.pxList,\n          scaleList = columnStore.scaleList,\n          scaleMinList = columnStore.scaleMinList,\n          autoList = columnStore.autoList; // 最小宽\n\n    pxMinList.forEach(column => {\n      const minWidth = parseInt(column.minWidth);\n      tableWidth += minWidth;\n      column.renderWidth = minWidth;\n    }); // 最小百分比\n\n    scaleMinList.forEach(column => {\n      const scaleWidth = Math.floor(parseInt(column.minWidth) * meanWidth);\n      tableWidth += scaleWidth;\n      column.renderWidth = scaleWidth;\n    }); // 固定百分比\n\n    scaleList.forEach(column => {\n      const scaleWidth = Math.floor(parseInt(column.width) * meanWidth);\n      tableWidth += scaleWidth;\n      column.renderWidth = scaleWidth;\n    }); // 固定宽\n\n    pxList.forEach(column => {\n      const width = parseInt(column.width);\n      tableWidth += width;\n      column.renderWidth = width;\n    }); // 调整了列宽\n\n    resizeList.forEach(column => {\n      const width = parseInt(column.resizeWidth);\n      tableWidth += width;\n      column.renderWidth = width;\n    });\n    remainWidth -= tableWidth;\n    meanWidth = remainWidth > 0 ? Math.floor(remainWidth / (scaleMinList.length + pxMinList.length + autoList.length)) : 0;\n\n    if (fit) {\n      if (remainWidth > 0) {\n        scaleMinList.concat(pxMinList).forEach(column => {\n          tableWidth += meanWidth;\n          column.renderWidth += meanWidth;\n        });\n      }\n    } else {\n      meanWidth = minCellWidth;\n    } // 自适应\n\n\n    autoList.forEach(column => {\n      const width = Math.max(meanWidth, minCellWidth);\n      column.renderWidth = width;\n      tableWidth += width;\n    });\n\n    if (fit) {\n      /**\r\n       * 偏移量算法\r\n       * 如果所有列足够放的情况下，从最后动态列开始分配\r\n       */\n      const dynamicList = scaleList.concat(scaleMinList).concat(pxMinList).concat(autoList);\n      let dynamicSize = dynamicList.length - 1;\n\n      if (dynamicSize > 0) {\n        let odiffer = bodyWidth - tableWidth;\n\n        if (odiffer > 0) {\n          while (odiffer > 0 && dynamicSize >= 0) {\n            odiffer--;\n            dynamicList[dynamicSize--].renderWidth++;\n          }\n\n          tableWidth = bodyWidth;\n        }\n      }\n    }\n\n    const tableHeight = bodyElem.offsetHeight;\n    const overflowY = bodyElem.scrollHeight > bodyElem.clientHeight;\n    this.scrollbarWidth = overflowY ? bodyElem.offsetWidth - bodyElem.clientWidth : 0;\n    this.overflowY = overflowY;\n    this.tableWidth = tableWidth;\n    this.tableHeight = tableHeight;\n\n    if (headerElem) {\n      this.headerHeight = headerElem.clientHeight;\n      this.$nextTick(() => {\n        // 检测是否同步滚动\n        if (headerElem && bodyElem && headerElem.scrollLeft !== bodyElem.scrollLeft) {\n          headerElem.scrollLeft = bodyElem.scrollLeft;\n        }\n      });\n    } else {\n      this.headerHeight = 0;\n    }\n\n    if (footerElem) {\n      const footerHeight = footerElem.offsetHeight;\n      this.scrollbarHeight = Math.max(footerHeight - footerElem.clientHeight, 0);\n      this.overflowX = tableWidth > footerElem.clientWidth;\n      this.footerHeight = footerHeight;\n    } else {\n      this.footerHeight = 0;\n      this.scrollbarHeight = Math.max(tableHeight - bodyElem.clientHeight, 0);\n      this.overflowX = tableWidth > bodyWidth;\n    }\n\n    this.updateHeight();\n    this.parentHeight = Math.max(this.headerHeight + this.footerHeight + 20, this.getParentHeight());\n\n    if (this.overflowX) {\n      this.checkScrolling();\n    }\n  },\n\n  updateHeight() {\n    this.customHeight = calcHeight(this, 'height');\n    this.customMaxHeight = calcHeight(this, 'maxHeight');\n  },\n\n  updateStyle() {\n    let $refs = this.$refs,\n        isGroup = this.isGroup,\n        fullColumnIdData = this.fullColumnIdData,\n        tableColumn = this.tableColumn,\n        customHeight = this.customHeight,\n        customMaxHeight = this.customMaxHeight,\n        border = this.border,\n        headerHeight = this.headerHeight,\n        showFooter = this.showFooter,\n        allColumnOverflow = this.showOverflow,\n        allColumnHeaderOverflow = this.showHeaderOverflow,\n        allColumnFooterOverflow = this.showFooterOverflow,\n        footerHeight = this.footerHeight,\n        tableHeight = this.tableHeight,\n        tableWidth = this.tableWidth,\n        scrollbarHeight = this.scrollbarHeight,\n        scrollbarWidth = this.scrollbarWidth,\n        scrollXLoad = this.scrollXLoad,\n        scrollYLoad = this.scrollYLoad,\n        cellOffsetWidth = this.cellOffsetWidth,\n        columnStore = this.columnStore,\n        elemStore = this.elemStore,\n        editStore = this.editStore,\n        currentRow = this.currentRow,\n        mouseConfig = this.mouseConfig,\n        keyboardConfig = this.keyboardConfig,\n        keyboardOpts = this.keyboardOpts,\n        spanMethod = this.spanMethod,\n        mergeList = this.mergeList,\n        mergeFooterList = this.mergeFooterList,\n        footerSpanMethod = this.footerSpanMethod,\n        isAllOverflow = this.isAllOverflow;\n    const containerList = ['main', 'left', 'right'];\n    const emptyPlaceholderElem = $refs.emptyPlaceholder;\n    const bodyWrapperElem = elemStore['main-body-wrapper'];\n\n    let _headerHeight = Math.max(32, headerHeight); //加\n\n\n    if (emptyPlaceholderElem) {\n      //      emptyPlaceholderElem.style.top = `${headerHeight}px`//删\n      //      emptyPlaceholderElem.style.height = bodyWrapperElem ? `${bodyWrapperElem.offsetHeight - scrollbarHeight}px` : ''//删\n      emptyPlaceholderElem.style.top = `${_headerHeight}px`; //加\n\n      emptyPlaceholderElem.style.height = 'calc(100% - ' + _headerHeight + 'px)'; //加\n    }\n\n    if (customHeight > 0) {\n      if (showFooter) {\n        customHeight += scrollbarHeight;\n      }\n    }\n\n    containerList.forEach((name, index) => {\n      const fixedType = index > 0 ? name : '';\n      const layoutList = ['header', 'body', 'footer'];\n      const fixedColumn = columnStore[`${fixedType}List`];\n      const fixedWrapperElem = $refs[`${fixedType}Container`];\n      layoutList.forEach(layout => {\n        const wrapperElem = elemStore[`${name}-${layout}-wrapper`];\n        const tableElem = elemStore[`${name}-${layout}-table`];\n\n        if (layout === 'header') {\n          // 表头体样式处理\n          // 横向滚动渲染\n          let tWidth = tableWidth; // 如果是使用优化模式\n\n          let isOptimize = false;\n\n          if (!isGroup) {\n            if (fixedType) {\n              if (scrollXLoad || allColumnHeaderOverflow) {\n                isOptimize = true;\n              }\n            }\n          }\n\n          if (isOptimize) {\n            tableColumn = fixedColumn;\n          }\n\n          if (isOptimize || scrollXLoad) {\n            tWidth = tableColumn.reduce((previous, column) => previous + column.renderWidth, 0);\n          }\n\n          if (tableElem) {\n            tableElem.style.width = tWidth ? `${tWidth + scrollbarWidth + 1}px` : ''; //改\n            // 修复 IE 中高度无法自适应问题\n\n            if (browse.msie) {\n              XEUtils.arrayEach(tableElem.querySelectorAll('.vxe-resizable'), resizeElem => {\n                resizeElem.style.height = `${resizeElem.parentNode.offsetHeight}px`;\n              });\n            }\n          }\n\n          const repairElem = elemStore[`${name}-${layout}-repair`];\n\n          if (repairElem) {\n            repairElem.style.width = `${tableWidth}px`;\n          }\n\n          const listElem = elemStore[`${name}-${layout}-list`];\n\n          if (isGroup && listElem) {\n            XEUtils.arrayEach(listElem.querySelectorAll('.col--group'), thElem => {\n              const colNode = this.getColumnNode(thElem);\n\n              if (colNode) {\n                const column = colNode.item;\n                const showHeaderOverflow = column.showHeaderOverflow;\n                const cellOverflow = XEUtils.isBoolean(showHeaderOverflow) ? showHeaderOverflow : allColumnHeaderOverflow;\n                const showEllipsis = cellOverflow === 'ellipsis';\n                const showTitle = cellOverflow === 'title';\n                const showTooltip = cellOverflow === true || cellOverflow === 'tooltip';\n                const hasEllipsis = showTitle || showTooltip || showEllipsis;\n                let childWidth = 0;\n                let countChild = 0;\n\n                if (hasEllipsis) {\n                  XEUtils.eachTree(column.children, item => {\n                    if (!item.children || !column.children.length) {\n                      countChild++;\n                    }\n\n                    childWidth += item.renderWidth;\n                  });\n                }\n\n                thElem.style.width = hasEllipsis ? `${childWidth - countChild - (border ? 2 : 0)}px` : '';\n              }\n            });\n          }\n        } else if (layout === 'body') {\n          const emptyBlockElem = elemStore[`${name}-${layout}-emptyBlock`];\n\n          if (wrapperElem) {\n            /*删\r\n               if (customMaxHeight) {\r\n                 wrapperElem.style.maxHeight = `${fixedType ? customMaxHeight - headerHeight - (showFooter ? 0 : scrollbarHeight) : customMaxHeight - headerHeight}px`\r\n               } else {\r\n                 if (customHeight > 0) {\r\n                   wrapperElem.style.height = `${fixedType ? (customHeight > 0 ? customHeight - headerHeight - footerHeight : tableHeight) - (showFooter ? 0 : scrollbarHeight) : customHeight - headerHeight - footerHeight}px`\r\n                 } else {\r\n                   wrapperElem.style.height = ''\r\n                 }\r\n               }*/\n            wrapperElem.style.height = 'calc(100% - ' + _headerHeight + 'px)'; //加\n          } // 如果是固定列\n\n\n          if (fixedWrapperElem) {\n            const isRightFixed = fixedType === 'right';\n            const fixedColumn = columnStore[`${fixedType}List`];\n\n            if (wrapperElem) {\n              //              wrapperElem.style.top = `${headerHeight}px`//删\n              wrapperElem.style.top = `${_headerHeight}px`; //加\n            } //            fixedWrapperElem.style.height = `${(customHeight > 0 ? customHeight - headerHeight - footerHeight : tableHeight) + headerHeight + footerHeight - scrollbarHeight * (showFooter ? 2 : 1)}px`//删\n\n\n            fixedWrapperElem.style.height = 'calc(100% - 11px)'; //加\n\n            fixedWrapperElem.style.width = `${fixedColumn.reduce((previous, column) => previous + column.renderWidth, isRightFixed ? scrollbarWidth : 0)}px`;\n          }\n\n          let tWidth = tableWidth; // 如果是使用优化模式\n\n          let isOptimize = false;\n\n          if (fixedType) {\n            if (!mergeList.length && !spanMethod && !(keyboardConfig && keyboardOpts.isMerge) && (scrollXLoad || scrollYLoad || (allColumnOverflow ? isAllOverflow : allColumnOverflow))) {\n              isOptimize = true;\n            }\n          }\n\n          if (isOptimize) {\n            tableColumn = fixedColumn;\n          }\n\n          if (isOptimize || scrollXLoad) {\n            tWidth = tableColumn.reduce((previous, column) => previous + column.renderWidth, 0);\n          }\n\n          if (tableElem) {\n            tableElem.style.width = tWidth ? `${tWidth + 1}px` : ''; //改\n            // 兼容性处理\n\n            tableElem.style.paddingRight = scrollbarWidth && fixedType && (browse['-moz'] || browse.safari) ? `${scrollbarWidth}px` : '';\n          }\n\n          if (emptyBlockElem) {\n            emptyBlockElem.style.width = tWidth ? `${tWidth}px` : '';\n          }\n        } else if (layout === 'footer') {\n          let tWidth = tableWidth; // 如果是使用优化模式\n\n          let isOptimize = false;\n\n          if (fixedType) {\n            if ((!mergeFooterList.length || !footerSpanMethod) && (scrollXLoad || allColumnFooterOverflow)) {\n              isOptimize = true;\n            }\n          }\n\n          if (isOptimize) {\n            tableColumn = fixedColumn;\n          }\n\n          if (isOptimize || scrollXLoad) {\n            tWidth = tableColumn.reduce((previous, column) => previous + column.renderWidth, 0);\n          }\n\n          if (wrapperElem) {\n            // 如果是固定列\n            if (fixedWrapperElem) {\n              //              wrapperElem.style.top = `${customHeight > 0 ? customHeight - footerHeight : tableHeight + headerHeight}px`//删\n              wrapperElem.style.top = `${customHeight > 0 ? customHeight - footerHeight : tableHeight + _headerHeight}px`; //加\n            }\n\n            wrapperElem.style.marginTop = `${-scrollbarHeight}px`;\n          }\n\n          if (tableElem) {\n            tableElem.style.width = tWidth ? `${tWidth + scrollbarWidth + 1}px` : ''; //改\n          }\n        }\n\n        const colgroupElem = elemStore[`${name}-${layout}-colgroup`];\n\n        if (colgroupElem) {\n          XEUtils.arrayEach(colgroupElem.children, colElem => {\n            const colid = colElem.getAttribute('name');\n\n            if (colid === 'col_gutter') {\n              colElem.style.width = `${scrollbarWidth}px`;\n            }\n\n            if (fullColumnIdData[colid]) {\n              const column = fullColumnIdData[colid].column;\n              const showHeaderOverflow = column.showHeaderOverflow,\n                    showFooterOverflow = column.showFooterOverflow,\n                    showOverflow = column.showOverflow;\n              let cellOverflow;\n              colElem.style.width = `${column.renderWidth}px`;\n\n              if (layout === 'header') {\n                cellOverflow = XEUtils.isUndefined(showHeaderOverflow) || XEUtils.isNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;\n              } else if (layout === 'footer') {\n                cellOverflow = XEUtils.isUndefined(showFooterOverflow) || XEUtils.isNull(showFooterOverflow) ? allColumnFooterOverflow : showFooterOverflow;\n              } else {\n                cellOverflow = XEUtils.isUndefined(showOverflow) || XEUtils.isNull(showOverflow) ? allColumnOverflow : showOverflow;\n              }\n\n              const showEllipsis = cellOverflow === 'ellipsis';\n              const showTitle = cellOverflow === 'title';\n              const showTooltip = cellOverflow === true || cellOverflow === 'tooltip';\n              let hasEllipsis = showTitle || showTooltip || showEllipsis;\n              const listElem = elemStore[`${name}-${layout}-list`]; // 滚动的渲染不支持动态行高\n\n              if (layout === 'header' || layout === 'footer') {\n                if (scrollXLoad && !hasEllipsis) {\n                  hasEllipsis = true;\n                }\n              } else {\n                if ((scrollXLoad || scrollYLoad) && !hasEllipsis) {\n                  hasEllipsis = true;\n                }\n              }\n\n              if (listElem) {\n                XEUtils.arrayEach(listElem.querySelectorAll(`.${column.id}`), elem => {\n                  const colspan = parseInt(elem.getAttribute('colspan') || 1);\n                  const cellElem = elem.querySelector('.vxe-cell');\n                  let colWidth = column.renderWidth;\n\n                  if (cellElem) {\n                    if (colspan > 1) {\n                      const columnIndex = this.getColumnIndex(column);\n\n                      for (let index = 1; index < colspan; index++) {\n                        const nextColumn = this.getColumns(columnIndex + index);\n\n                        if (nextColumn) {\n                          colWidth += nextColumn.renderWidth;\n                        }\n                      }\n                    }\n\n                    cellElem.style.width = hasEllipsis ? `${colWidth - cellOffsetWidth * colspan}px` : '';\n                  }\n                });\n              }\n            }\n          });\n        }\n      });\n    });\n\n    if (currentRow) {\n      this.setCurrentRow(currentRow);\n    }\n\n    if (mouseConfig && mouseConfig.selected && editStore.selected.row && editStore.selected.column) {\n      this.addColSdCls();\n    }\n\n    return this.$nextTick();\n  },\n\n  /**\r\n   * 处理固定列的显示状态\r\n   */\n  checkScrolling() {\n    const _this$$refs = this.$refs,\n          tableBody = _this$$refs.tableBody,\n          leftContainer = _this$$refs.leftContainer,\n          rightContainer = _this$$refs.rightContainer;\n    const bodyElem = tableBody ? tableBody.$el : null;\n\n    if (bodyElem) {\n      if (leftContainer) {\n        DomTools[bodyElem.scrollLeft > 0 ? 'addClass' : 'removeClass'](leftContainer, 'scrolling--middle');\n      }\n\n      if (rightContainer) {\n        DomTools[bodyElem.clientWidth < bodyElem.scrollWidth - Math.ceil(bodyElem.scrollLeft) ? 'addClass' : 'removeClass'](rightContainer, 'scrolling--middle');\n      }\n    }\n  },\n\n  preventEvent(evnt, type, args, next, end) {\n    const evntList = VXETable.interceptor.get(type);\n    let rest;\n\n    if (!evntList.some(func => func(Object.assign({\n      $grid: this.$xegrid,\n      $table: this,\n      $event: evnt\n    }, args)) === false)) {\n      if (next) {\n        rest = next();\n      }\n    }\n\n    if (end) {\n      end();\n    }\n\n    return rest;\n  },\n\n  /**\r\n   * 全局按下事件处理\r\n   */\n  handleGlobalMousedownEvent(evnt) {\n    const $el = this.$el,\n          $refs = this.$refs,\n          $xegrid = this.$xegrid,\n          $toolbar = this.$toolbar,\n          mouseConfig = this.mouseConfig,\n          editStore = this.editStore,\n          ctxMenuStore = this.ctxMenuStore,\n          editOpts = this.editOpts,\n          filterStore = this.filterStore,\n          getRowNode = this.getRowNode;\n    const actived = editStore.actived;\n    const ctxWrapper = $refs.ctxWrapper,\n          filterWrapper = $refs.filterWrapper,\n          validTip = $refs.validTip;\n\n    if (filterWrapper) {\n      if (getEventTargetNode(evnt, $el, 'vxe-cell--filter').flag) {// 如果点击了筛选按钮\n      } else if (getEventTargetNode(evnt, filterWrapper.$el).flag) {// 如果点击筛选容器\n      } else {\n        if (!getEventTargetNode(evnt, document.body, 'vxe-table--ignore-clear').flag) {\n          this.preventEvent(evnt, 'event.clearFilter', filterStore.args, this.closeFilter);\n        }\n      }\n    } // 如果已激活了编辑状态\n\n\n    if (actived.row) {\n      if (!(editOpts.autoClear === false)) {\n        // 如果是激活状态，点击了单元格之外\n        const cell = actived.args.cell;\n\n        if (!cell || !getEventTargetNode(evnt, cell).flag) {\n          if (validTip && getEventTargetNode(evnt, validTip.$el).flag) {// 如果是激活状态，且点击了校验提示框\n          } else if (!this.lastCallTime || this.lastCallTime + 50 < Date.now()) {\n            if (!getEventTargetNode(evnt, document.body, 'vxe-table--ignore-clear').flag) {\n              // 如果手动调用了激活单元格，避免触发源被移除后导致重复关闭\n              this.preventEvent(evnt, 'event.clearActived', actived.args, () => {\n                let isClearActived;\n\n                if (editOpts.mode === 'row') {\n                  const rowNode = getEventTargetNode(evnt, $el, 'vxe-body--row'); // row 方式，如果点击了不同行\n\n                  isClearActived = rowNode.flag ? getRowNode(rowNode.targetElem).item !== actived.args.row : false;\n                } else {\n                  // cell 方式，如果是非编辑列\n                  isClearActived = !getEventTargetNode(evnt, $el, 'col--edit').flag;\n                } // 如果点击表头行，则清除激活状态\n\n\n                if (!isClearActived) {\n                  isClearActived = getEventTargetNode(evnt, $el, 'vxe-header--row').flag;\n                } // 如果点击表尾行，则清除激活状态\n\n\n                if (!isClearActived) {\n                  isClearActived = getEventTargetNode(evnt, $el, 'vxe-footer--row').flag;\n                } // 如果固定了高度且点击了行之外的空白处，则清除激活状态\n\n\n                if (!isClearActived && this.height && !this.overflowY) {\n                  const bodyWrapperElem = evnt.target;\n\n                  if (hasClass(bodyWrapperElem, 'vxe-table--body-wrapper')) {\n                    isClearActived = evnt.offsetY < bodyWrapperElem.clientHeight;\n                  }\n                }\n\n                if (isClearActived || // 如果点击了当前表格之外\n                !getEventTargetNode(evnt, $el).flag) {\n                  setTimeout(() => this.clearActived(evnt));\n                }\n              });\n            }\n          }\n        }\n      }\n    } else if (mouseConfig) {\n      if (!getEventTargetNode(evnt, $el).flag && !($xegrid && getEventTargetNode(evnt, $xegrid.$el).flag) && !(ctxWrapper && getEventTargetNode(evnt, ctxWrapper.$el).flag) && !($toolbar && getEventTargetNode(evnt, $toolbar.$el).flag)) {\n        this.clearSelected();\n\n        if (!getEventTargetNode(evnt, document.body, 'vxe-table--ignore-areas-clear').flag) {\n          this.preventEvent(evnt, 'event.clearAreas', {}, () => {\n            this.clearCellAreas();\n            this.clearCopyCellArea();\n          });\n        }\n      }\n    } // 如果配置了快捷菜单且，点击了其他地方则关闭\n\n\n    if (ctxMenuStore.visible && ctxWrapper && !getEventTargetNode(evnt, ctxWrapper.$el).flag) {\n      this.closeMenu();\n    } // 最后激活的表格\n\n\n    this.isActivated = getEventTargetNode(evnt, ($xegrid || this).$el).flag;\n  },\n\n  /**\r\n   * 窗口失焦事件处理\r\n   */\n  handleGlobalBlurEvent() {\n    this.closeFilter();\n    this.closeMenu();\n  },\n\n  /**\r\n   * 全局滚动事件\r\n   */\n  handleGlobalMousewheelEvent() {\n    this.closeTooltip();\n    this.closeMenu();\n  },\n\n  /**\r\n   * 表格键盘事件\r\n   */\n  keydownEvent(evnt) {\n    const filterStore = this.filterStore,\n          ctxMenuStore = this.ctxMenuStore,\n          editStore = this.editStore,\n          keyboardConfig = this.keyboardConfig,\n          mouseConfig = this.mouseConfig,\n          mouseOpts = this.mouseOpts;\n    const actived = editStore.actived;\n    const keyCode = evnt.keyCode;\n    const isEsc = keyCode === 27;\n\n    if (isEsc) {\n      this.preventEvent(evnt, 'event.keydown', null, () => {\n        if (keyboardConfig && mouseConfig && mouseOpts.area && this.handleKeyboardEvent) {\n          this.handleKeyboardEvent(evnt);\n        } else if (actived.row || filterStore.visible || ctxMenuStore.visible) {\n          evnt.stopPropagation(); // 如果按下了 Esc 键，关闭快捷菜单、筛选\n\n          this.closeFilter();\n          this.closeMenu(); // 如果是激活编辑状态，则取消编辑\n\n          if (actived.row) {\n            const params = actived.args;\n            this.clearActived(evnt); // 如果配置了选中功能，则为选中状态\n\n            if (mouseConfig && mouseOpts.selected) {\n              this.$nextTick(() => this.handleSelected(params, evnt));\n            }\n          }\n        }\n\n        this.emitEvent('keydown', {}, evnt);\n      });\n    }\n  },\n\n  /**\r\n   * 全局键盘事件\r\n   */\n  handleGlobalKeydownEvent(evnt) {\n    // 该行为只对当前激活的表格有效\n    if (this.isActivated) {\n      this.preventEvent(evnt, 'event.keydown', null, () => {\n        const filterStore = this.filterStore,\n              isCtxMenu = this.isCtxMenu,\n              ctxMenuStore = this.ctxMenuStore,\n              editStore = this.editStore,\n              editOpts = this.editOpts,\n              editConfig = this.editConfig,\n              mouseConfig = this.mouseConfig,\n              mouseOpts = this.mouseOpts,\n              keyboardConfig = this.keyboardConfig,\n              keyboardOpts = this.keyboardOpts,\n              treeConfig = this.treeConfig,\n              treeOpts = this.treeOpts,\n              highlightCurrentRow = this.highlightCurrentRow,\n              currentRow = this.currentRow,\n              bodyCtxMenu = this.bodyCtxMenu;\n        const selected = editStore.selected,\n              actived = editStore.actived;\n        const keyCode = evnt.keyCode;\n        const isBack = keyCode === 8;\n        const isTab = keyCode === 9;\n        const isEnter = keyCode === 13;\n        const isEsc = keyCode === 27;\n        const isSpacebar = keyCode === 32;\n        const isLeftArrow = keyCode === 37;\n        const isUpArrow = keyCode === 38;\n        const isRightArrow = keyCode === 39;\n        const isDwArrow = keyCode === 40;\n        const isDel = keyCode === 46;\n        const isF2 = keyCode === 113;\n        const isContextMenu = keyCode === 93;\n        const hasMetaKey = evnt.metaKey;\n        const hasCtrlKey = evnt.ctrlKey;\n        const hasShiftKey = evnt.shiftKey;\n        const hasAltKey = evnt.altKey;\n        const operArrow = isLeftArrow || isUpArrow || isRightArrow || isDwArrow;\n        const operCtxMenu = isCtxMenu && ctxMenuStore.visible && (isEnter || isSpacebar || operArrow);\n        const isEditStatus = editConfig && actived.column && actived.row;\n        let params;\n\n        if (filterStore.visible) {\n          if (isEsc) {\n            this.closeFilter();\n          }\n\n          return;\n        }\n\n        if (operCtxMenu) {\n          // 如果配置了右键菜单; 支持方向键操作、回车\n          evnt.preventDefault();\n\n          if (ctxMenuStore.showChild && hasChildrenList(ctxMenuStore.selected)) {\n            this.moveCtxMenu(evnt, keyCode, ctxMenuStore, 'selectChild', 37, false, ctxMenuStore.selected.children);\n          } else {\n            this.moveCtxMenu(evnt, keyCode, ctxMenuStore, 'selected', 39, true, this.ctxMenuList);\n          }\n        } else if (keyboardConfig && mouseConfig && mouseOpts.area && this.handleKeyboardEvent) {\n          this.handleKeyboardEvent(evnt);\n        } else if (keyboardConfig && isSpacebar && keyboardOpts.isChecked && selected.row && selected.column && (selected.column.type === 'checkbox' || selected.column.type === 'radio')) {\n          // 空格键支持选中复选框\n          evnt.preventDefault();\n\n          if (selected.column.type === 'checkbox') {\n            this.handleToggleCheckRowEvent(evnt, selected.args);\n          } else {\n            this.triggerRadioRowEvent(evnt, selected.args);\n          }\n        } else if (isF2) {\n          if (!isEditStatus) {\n            // 如果按下了 F2 键\n            if (selected.row && selected.column) {\n              evnt.stopPropagation();\n              evnt.preventDefault();\n              this.handleActived(selected.args, evnt);\n            }\n          }\n        } else if (isContextMenu) {\n          // 如果按下上下文键\n          this._keyCtx = selected.row && selected.column && bodyCtxMenu.length;\n          clearTimeout(this.keyCtxTimeout);\n          this.keyCtxTimeout = setTimeout(() => {\n            this._keyCtx = false;\n          }, 1000);\n        } else if (isEnter && !hasAltKey && keyboardConfig && keyboardOpts.isEnter && (selected.row || actived.row || treeConfig && highlightCurrentRow && currentRow)) {\n          // 退出选中\n          if (hasCtrlKey) {\n            // 如果是激活编辑状态，则取消编辑\n            if (actived.row) {\n              params = actived.args;\n              this.clearActived(evnt); // 如果配置了选中功能，则为选中状态\n\n              if (mouseConfig && mouseOpts.selected) {\n                this.$nextTick(() => this.handleSelected(params, evnt));\n              }\n            }\n          } else {\n            // 如果是激活状态，退则出到上一行/下一行\n            if (selected.row || actived.row) {\n              const targetArgs = selected.row ? selected.args : actived.args;\n\n              if (hasShiftKey) {\n                if (keyboardOpts.enterToTab) {\n                  this.moveTabSelected(targetArgs, hasShiftKey, evnt);\n                } else {\n                  this.moveSelected(targetArgs, isLeftArrow, true, isRightArrow, false, evnt);\n                }\n              } else {\n                if (keyboardOpts.enterToTab) {\n                  this.moveTabSelected(targetArgs, hasShiftKey, evnt);\n                } else {\n                  this.moveSelected(targetArgs, isLeftArrow, false, isRightArrow, true, evnt);\n                }\n              }\n            } else if (treeConfig && highlightCurrentRow && currentRow) {\n              // 如果是树形表格当前行回车移动到子节点\n              const childrens = currentRow[treeOpts.children];\n\n              if (childrens && childrens.length) {\n                evnt.preventDefault();\n                const targetRow = childrens[0];\n                params = {\n                  $table: this,\n                  row: targetRow\n                };\n                this.setTreeExpand(currentRow, true).then(() => this.scrollToRow(targetRow)).then(() => this.triggerCurrentRowEvent(evnt, params));\n              }\n            }\n          }\n        } else if (operArrow && keyboardConfig && keyboardOpts.isArrow) {\n          if (!isEditStatus) {\n            // 如果按下了方向键\n            if (selected.row && selected.column) {\n              this.moveSelected(selected.args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow, evnt);\n            } else if ((isUpArrow || isDwArrow) && highlightCurrentRow) {\n              // 当前行按键上下移动\n              this.moveCurrentRow(isUpArrow, isDwArrow, evnt);\n            }\n          }\n        } else if (isTab && keyboardConfig && keyboardOpts.isTab) {\n          // 如果按下了 Tab 键切换\n          if (selected.row || selected.column) {\n            this.moveTabSelected(selected.args, hasShiftKey, evnt);\n          } else if (actived.row || actived.column) {\n            this.moveTabSelected(actived.args, hasShiftKey, evnt);\n          }\n        } else if (keyboardConfig && (isDel || (treeConfig && highlightCurrentRow && currentRow ? isBack && keyboardOpts.isArrow : isBack))) {\n          if (!isEditStatus) {\n            const delMethod = keyboardOpts.delMethod,\n                  backMethod = keyboardOpts.backMethod; // 如果是删除键\n\n            if (keyboardOpts.isDel && (selected.row || selected.column)) {\n              if (delMethod) {\n                delMethod({\n                  row: selected.row,\n                  rowIndex: this.getRowIndex(selected.row),\n                  column: selected.column,\n                  columnIndex: this.getColumnIndex(selected.column),\n                  $table: this\n                });\n              } else {\n                setCellValue(selected.row, selected.column, null);\n              }\n\n              if (isBack) {\n                if (backMethod) {\n                  backMethod({\n                    row: selected.row,\n                    rowIndex: this.getRowIndex(selected.row),\n                    column: selected.column,\n                    columnIndex: this.getColumnIndex(selected.column),\n                    $table: this\n                  });\n                } else {\n                  this.handleActived(selected.args, evnt);\n                }\n              } else if (isDel) {\n                // 如果按下 del 键，更新表尾数据\n                this.updateFooter();\n              }\n            } else if (isBack && keyboardOpts.isArrow && treeConfig && highlightCurrentRow && currentRow) {\n              // 如果树形表格回退键关闭当前行返回父节点\n              const _XEUtils$findTree = XEUtils.findTree(this.afterFullData, item => item === currentRow, treeOpts),\n                    parentRow = _XEUtils$findTree.parent;\n\n              if (parentRow) {\n                evnt.preventDefault();\n                params = {\n                  $table: this,\n                  row: parentRow\n                };\n                this.setTreeExpand(parentRow, false).then(() => this.scrollToRow(parentRow)).then(() => this.triggerCurrentRowEvent(evnt, params));\n              }\n            }\n          }\n        } else if (keyboardConfig && keyboardOpts.isEdit && !hasCtrlKey && !hasMetaKey && (isSpacebar || keyCode >= 48 && keyCode <= 57 || keyCode >= 65 && keyCode <= 90 || keyCode >= 96 && keyCode <= 111 || keyCode >= 186 && keyCode <= 192 || keyCode >= 219 && keyCode <= 222)) {\n          const editMethod = keyboardOpts.editMethod; // 启用编辑后，空格键功能将失效\n          // if (isSpacebar) {\n          //   evnt.preventDefault()\n          // }\n          // 如果是按下非功能键之外允许直接编辑\n\n          if (selected.column && selected.row && isEnableConf(selected.column.editRender)) {\n            if (!editOpts.activeMethod || editOpts.activeMethod(selected.args)) {\n              if (editMethod) {\n                editMethod({\n                  row: selected.row,\n                  rowIndex: this.getRowIndex(selected.row),\n                  column: selected.column,\n                  columnIndex: this.getColumnIndex(selected.column),\n                  $table: this\n                });\n              } else {\n                setCellValue(selected.row, selected.column, null);\n                this.handleActived(selected.args, evnt);\n              }\n            }\n          }\n        }\n\n        this.emitEvent('keydown', {}, evnt);\n      });\n    }\n  },\n\n  handleGlobalPasteEvent(evnt) {\n    const isActivated = this.isActivated,\n          keyboardConfig = this.keyboardConfig,\n          keyboardOpts = this.keyboardOpts,\n          mouseConfig = this.mouseConfig,\n          mouseOpts = this.mouseOpts,\n          editStore = this.editStore,\n          filterStore = this.filterStore;\n    const actived = editStore.actived;\n\n    if (isActivated && !filterStore.visible) {\n      if (!(actived.row || actived.column)) {\n        if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && this.handlePasteCellAreaEvent) {\n          this.handlePasteCellAreaEvent(evnt);\n        }\n      }\n\n      this.emitEvent('paste', {}, evnt);\n    }\n  },\n\n  handleGlobalCopyEvent(evnt) {\n    const isActivated = this.isActivated,\n          keyboardConfig = this.keyboardConfig,\n          keyboardOpts = this.keyboardOpts,\n          mouseConfig = this.mouseConfig,\n          mouseOpts = this.mouseOpts,\n          editStore = this.editStore,\n          filterStore = this.filterStore;\n    const actived = editStore.actived;\n\n    if (isActivated && !filterStore.visible) {\n      if (!(actived.row || actived.column)) {\n        if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && this.handleCopyCellAreaEvent) {\n          this.handleCopyCellAreaEvent(evnt);\n        }\n      }\n\n      this.emitEvent('copy', {}, evnt);\n    }\n  },\n\n  handleGlobalCutEvent(evnt) {\n    const isActivated = this.isActivated,\n          keyboardConfig = this.keyboardConfig,\n          keyboardOpts = this.keyboardOpts,\n          mouseConfig = this.mouseConfig,\n          mouseOpts = this.mouseOpts,\n          editStore = this.editStore,\n          filterStore = this.filterStore;\n    const actived = editStore.actived;\n\n    if (isActivated && !filterStore.visible) {\n      if (!(actived.row || actived.column)) {\n        if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && this.handleCutCellAreaEvent) {\n          this.handleCutCellAreaEvent(evnt);\n        }\n      }\n\n      this.emitEvent('cut', {}, evnt);\n    }\n  },\n\n  handleGlobalResizeEvent() {\n    this.closeMenu();\n    this.updateCellAreas();\n    this.recalculate(true);\n  },\n\n  handleTooltipLeaveMethod() {\n    const tooltipOpts = this.tooltipOpts;\n    setTimeout(() => {\n      if (!this.tooltipActive) {\n        this.closeTooltip();\n      }\n    }, tooltipOpts.leaveDelay);\n    return false;\n  },\n\n  handleTargetEnterEvent() {\n    clearTimeout(this.tooltipTimeout);\n    this.tooltipActive = true;\n    this.closeTooltip();\n  },\n\n  handleTargetLeaveEvent() {\n    const tooltipOpts = this.tooltipOpts;\n    this.tooltipActive = false;\n\n    if (tooltipOpts.enterable) {\n      this.tooltipTimeout = setTimeout(() => {\n        const tooltip = this.$refs.tooltip;\n\n        if (tooltip && !tooltip.isHover) {\n          this.closeTooltip();\n        }\n      }, tooltipOpts.leaveDelay);\n    } else {\n      this.closeTooltip();\n    }\n  },\n\n  triggerHeaderHelpEvent(evnt, params) {\n    const column = params.column;\n    const titleHelp = column.titleHelp;\n\n    if (titleHelp.message) {\n      const $refs = this.$refs,\n            tooltipStore = this.tooltipStore;\n      const tooltip = $refs.tooltip;\n      const content = UtilTools.getFuncText(titleHelp.message);\n      this.handleTargetEnterEvent();\n      tooltipStore.visible = true;\n\n      if (tooltip) {\n        tooltip.open(evnt.currentTarget, content);\n      }\n    }\n  },\n\n  /**\r\n   * 触发表头 tooltip 事件\r\n   */\n  triggerHeaderTooltipEvent(evnt, params) {\n    const tooltipStore = this.tooltipStore;\n    const column = params.column;\n    const titleElem = evnt.currentTarget;\n    this.handleTargetEnterEvent();\n\n    if (tooltipStore.column !== column || !tooltipStore.visible) {\n      this.handleTooltip(evnt, titleElem, titleElem, null, params);\n    }\n  },\n\n  /**\r\n   * 触发单元格 tooltip 事件\r\n   */\n  triggerBodyTooltipEvent(evnt, params) {\n    const editConfig = this.editConfig,\n          editOpts = this.editOpts,\n          editStore = this.editStore,\n          tooltipStore = this.tooltipStore;\n    const actived = editStore.actived;\n    const row = params.row,\n          column = params.column;\n    const cell = evnt.currentTarget;\n    this.handleTargetEnterEvent();\n\n    if (editConfig) {\n      if (editOpts.mode === 'row' && actived.row === row || actived.row === row && actived.column === column) {\n        return;\n      }\n    }\n\n    if (tooltipStore.column !== column || tooltipStore.row !== row || !tooltipStore.visible) {\n      let overflowElem;\n      let tipElem;\n\n      if (column.treeNode) {\n        overflowElem = cell.querySelector('.vxe-tree-cell');\n\n        if (column.type === 'html') {\n          tipElem = cell.querySelector('.vxe-cell--html');\n        }\n      } else {\n        tipElem = cell.querySelector(column.type === 'html' ? '.vxe-cell--html' : '.vxe-cell--label');\n      }\n\n      this.handleTooltip(evnt, cell, overflowElem || cell.children[0], tipElem, params);\n    }\n  },\n\n  /**\r\n   * 触发表尾 tooltip 事件\r\n   */\n  triggerFooterTooltipEvent(evnt, params) {\n    const column = params.column;\n    const tooltipStore = this.tooltipStore;\n    const cell = evnt.currentTarget;\n    this.handleTargetEnterEvent();\n\n    if (tooltipStore.column !== column || !tooltipStore.visible) {\n      this.handleTooltip(evnt, cell, cell.querySelector('.vxe-cell--item') || cell.children[0], null, params);\n    }\n  },\n\n  /**\r\n   * 处理显示 tooltip\r\n   * @param {Event} evnt 事件\r\n   * @param {ColumnInfo} column 列配置\r\n   * @param {Row} row 行对象\r\n   */\n  handleTooltip(evnt, cell, overflowElem, tipElem, params) {\n    params.cell = cell;\n    const $refs = this.$refs,\n          tooltipOpts = this.tooltipOpts,\n          tooltipStore = this.tooltipStore;\n    const column = params.column,\n          row = params.row;\n    const showAll = tooltipOpts.showAll,\n          enabled = tooltipOpts.enabled,\n          contentMethod = tooltipOpts.contentMethod;\n    const tooltip = $refs.tooltip;\n    const customContent = contentMethod ? contentMethod(params) : null;\n    const useCustom = contentMethod && !XEUtils.eqNull(customContent);\n    const content = useCustom ? customContent : (column.type === 'html' ? overflowElem.innerText : overflowElem.textContent).trim();\n    const isCellOverflow = overflowElem.scrollWidth > overflowElem.clientWidth;\n\n    if (content && (showAll || enabled || useCustom || isCellOverflow)) {\n      Object.assign(tooltipStore, {\n        row,\n        column,\n        visible: true\n      });\n\n      if (tooltip) {\n        tooltip.open(isCellOverflow ? overflowElem : tipElem || overflowElem, UtilTools.formatText(content));\n      }\n    }\n\n    return this.$nextTick();\n  },\n\n  openTooltip(target, content) {\n    const $refs = this.$refs;\n    const commTip = $refs.commTip;\n\n    if (commTip) {\n      return commTip.open(target, content);\n    }\n\n    return this.$nextTick();\n  },\n\n  /**\r\n   * 关闭 tooltip\r\n   */\n  closeTooltip() {\n    const $refs = this.$refs,\n          tooltipStore = this.tooltipStore;\n    const tooltip = $refs.tooltip;\n    const commTip = $refs.commTip;\n\n    if (tooltipStore.visible) {\n      Object.assign(tooltipStore, {\n        row: null,\n        column: null,\n        content: null,\n        visible: false\n      });\n\n      if (tooltip) {\n        tooltip.close();\n      }\n    }\n\n    if (commTip) {\n      commTip.close();\n    }\n\n    return this.$nextTick();\n  },\n\n  /**\r\n   * 判断复选框是否全选\r\n   */\n  isAllCheckboxChecked() {\n    return this.isAllSelected;\n  },\n\n  /**\r\n   * 判断复选框是否全选\r\n   */\n  isCheckboxIndeterminate() {\n    return !this.isAllSelected && this.isIndeterminate;\n  },\n\n  /**\r\n   * 获取复选框半选状态的行数据\r\n   */\n  getCheckboxIndeterminateRecords() {\n    const treeConfig = this.treeConfig,\n          treeIndeterminates = this.treeIndeterminates;\n\n    if (treeConfig) {\n      return treeIndeterminates.slice(0);\n    }\n\n    return [];\n  },\n\n  /**\r\n   * 处理默认勾选\r\n   */\n  handleDefaultSelectionChecked() {\n    const fullDataRowIdData = this.fullDataRowIdData,\n          checkboxOpts = this.checkboxOpts;\n    const checkAll = checkboxOpts.checkAll,\n          checkRowKeys = checkboxOpts.checkRowKeys;\n\n    if (checkAll) {\n      this.setAllCheckboxRow(true);\n    } else if (checkRowKeys) {\n      const defSelection = [];\n      checkRowKeys.forEach(rowid => {\n        if (fullDataRowIdData[rowid]) {\n          defSelection.push(fullDataRowIdData[rowid].row);\n        }\n      });\n      this.setCheckboxRow(defSelection, true);\n    }\n  },\n\n  /**\r\n   * 用于多选行，设置行为选中状态，第二个参数为选中与否\r\n   * @param {Array/Row} rows 行数据\r\n   * @param {Boolean} value 是否选中\r\n   */\n  setCheckboxRow(rows, value) {\n    if (rows && !XEUtils.isArray(rows)) {\n      rows = [rows];\n    }\n\n    rows.forEach(row => this.handleSelectRow({\n      row\n    }, !!value));\n    return this.$nextTick();\n  },\n\n  isCheckedByCheckboxRow(row) {\n    const property = this.checkboxOpts.checkField;\n\n    if (property) {\n      return XEUtils.get(row, property);\n    }\n\n    return this.selection.indexOf(row) > -1;\n  },\n\n  /**\r\n   * 多选，行选中事件\r\n   * value 选中true 不选false 不确定-1\r\n   */\n  handleSelectRow(_ref5, value) {\n    let row = _ref5.row;\n    const selection = this.selection,\n          afterFullData = this.afterFullData,\n          treeConfig = this.treeConfig,\n          treeOpts = this.treeOpts,\n          treeIndeterminates = this.treeIndeterminates,\n          checkboxOpts = this.checkboxOpts;\n    const property = checkboxOpts.checkField,\n          checkStrictly = checkboxOpts.checkStrictly,\n          checkMethod = checkboxOpts.checkMethod;\n\n    if (property) {\n      if (treeConfig && !checkStrictly) {\n        if (value === -1) {\n          if (treeIndeterminates.indexOf(row) === -1) {\n            treeIndeterminates.push(row);\n          }\n\n          XEUtils.set(row, property, false);\n        } else {\n          // 更新子节点状态\n          XEUtils.eachTree([row], item => {\n            if (row === item || !checkMethod || checkMethod({\n              row: item\n            })) {\n              XEUtils.set(item, property, value);\n              XEUtils.remove(treeIndeterminates, half => half === item);\n              this.handleCheckboxReserveRow(row, value);\n            }\n          }, treeOpts);\n        } // 如果存在父节点，更新父节点状态\n\n\n        const matchObj = XEUtils.findTree(afterFullData, item => item === row, treeOpts);\n\n        if (matchObj && matchObj.parent) {\n          let parentStatus;\n          const vItems = checkMethod ? matchObj.items.filter(item => checkMethod({\n            row: item\n          })) : matchObj.items;\n          const indeterminatesItem = XEUtils.find(matchObj.items, item => treeIndeterminates.indexOf(item) > -1);\n\n          if (indeterminatesItem) {\n            parentStatus = -1;\n          } else {\n            const selectItems = matchObj.items.filter(item => XEUtils.get(item, property));\n            parentStatus = selectItems.filter(item => vItems.indexOf(item) > -1).length === vItems.length ? true : selectItems.length || value === -1 ? -1 : false;\n          }\n\n          return this.handleSelectRow({\n            row: matchObj.parent\n          }, parentStatus);\n        }\n      } else {\n        if (!checkMethod || checkMethod({\n          row\n        })) {\n          XEUtils.set(row, property, value);\n          this.handleCheckboxReserveRow(row, value);\n        }\n      }\n    } else {\n      if (treeConfig && !checkStrictly) {\n        if (value === -1) {\n          if (treeIndeterminates.indexOf(row) === -1) {\n            treeIndeterminates.push(row);\n          }\n\n          XEUtils.remove(selection, item => item === row);\n        } else {\n          // 更新子节点状态\n          XEUtils.eachTree([row], item => {\n            if (row === item || !checkMethod || checkMethod({\n              row: item\n            })) {\n              if (value) {\n                selection.push(item);\n              } else {\n                XEUtils.remove(selection, select => select === item);\n              }\n\n              XEUtils.remove(treeIndeterminates, half => half === item);\n              this.handleCheckboxReserveRow(row, value);\n            }\n          }, treeOpts);\n        } // 如果存在父节点，更新父节点状态\n\n\n        const matchObj = XEUtils.findTree(afterFullData, item => item === row, treeOpts);\n\n        if (matchObj && matchObj.parent) {\n          let parentStatus;\n          const vItems = checkMethod ? matchObj.items.filter(item => checkMethod({\n            row: item\n          })) : matchObj.items;\n          const indeterminatesItem = XEUtils.find(matchObj.items, item => treeIndeterminates.indexOf(item) > -1);\n\n          if (indeterminatesItem) {\n            parentStatus = -1;\n          } else {\n            const selectItems = matchObj.items.filter(item => selection.indexOf(item) > -1);\n            parentStatus = selectItems.filter(item => vItems.indexOf(item) > -1).length === vItems.length ? true : selectItems.length || value === -1 ? -1 : false;\n          }\n\n          return this.handleSelectRow({\n            row: matchObj.parent\n          }, parentStatus);\n        }\n      } else {\n        if (!checkMethod || checkMethod({\n          row\n        })) {\n          if (value) {\n            if (selection.indexOf(row) === -1) {\n              selection.push(row);\n            }\n          } else {\n            XEUtils.remove(selection, item => item === row);\n          }\n\n          this.handleCheckboxReserveRow(row, value);\n        }\n      }\n    }\n\n    this.checkSelectionStatus();\n  },\n\n  handleToggleCheckRowEvent(evnt, params) {\n    const selection = this.selection,\n          checkboxOpts = this.checkboxOpts;\n    const property = checkboxOpts.checkField;\n    const row = params.row;\n    const value = property ? !XEUtils.get(row, property) : selection.indexOf(row) === -1;\n\n    if (evnt) {\n      this.triggerCheckRowEvent(evnt, params, value);\n    } else {\n      this.handleSelectRow(params, value);\n    }\n  },\n\n  triggerCheckRowEvent(evnt, params, value) {\n    const checkMethod = this.checkboxOpts.checkMethod;\n\n    if (!checkMethod || checkMethod({\n      row: params.row\n    })) {\n      this.handleSelectRow(params, value);\n      this.emitEvent('checkbox-change', Object.assign({\n        records: this.getCheckboxRecords(),\n        reserves: this.getCheckboxReserveRecords(),\n        indeterminates: this.getCheckboxIndeterminateRecords(),\n        checked: value\n      }, params), evnt);\n    }\n  },\n\n  /**\r\n   * 多选，切换某一行的选中状态\r\n   */\n  toggleCheckboxRow(row) {\n    this.handleToggleCheckRowEvent(null, {\n      row\n    });\n    return this.$nextTick();\n  },\n\n  /**\r\n   * 用于多选行，设置所有行的选中状态\r\n   * @param {Boolean} value 是否选中\r\n   */\n  setAllCheckboxRow(value) {\n    const afterFullData = this.afterFullData,\n          treeConfig = this.treeConfig,\n          treeOpts = this.treeOpts,\n          selection = this.selection,\n          checkboxReserveRowMap = this.checkboxReserveRowMap,\n          checkboxOpts = this.checkboxOpts;\n    const property = checkboxOpts.checkField,\n          reserve = checkboxOpts.reserve,\n          checkStrictly = checkboxOpts.checkStrictly,\n          checkMethod = checkboxOpts.checkMethod;\n    let selectRows = [];\n    const beforeSelection = treeConfig ? [] : selection.filter(row => afterFullData.indexOf(row) === -1);\n\n    if (checkStrictly) {\n      this.isAllSelected = value;\n    } else {\n      /**\r\n       * 绑定属性方式（高性能，有污染）\r\n       * 必须在行数据存在对应的属性，否则将不响应\r\n       */\n      if (property) {\n        const checkValFn = row => {\n          if (!checkMethod || checkMethod({\n            row\n          })) {\n            if (value) {\n              selectRows.push(row);\n            }\n\n            XEUtils.set(row, property, value);\n          }\n        }; // 如果存在选中方法\n        // 如果方法成立，则更新值，否则忽略该数据\n\n\n        if (treeConfig) {\n          XEUtils.eachTree(afterFullData, checkValFn, treeOpts);\n        } else {\n          afterFullData.forEach(checkValFn);\n        }\n      } else {\n        /**\r\n         * 默认方式（低性能，无污染）\r\n         * 无需任何属性，直接绑定\r\n         */\n        if (treeConfig) {\n          if (value) {\n            /**\r\n             * 如果是树勾选\r\n             * 如果方法成立，则添加到临时集合中\r\n             */\n            XEUtils.eachTree(afterFullData, row => {\n              if (!checkMethod || checkMethod({\n                row\n              })) {\n                selectRows.push(row);\n              }\n            }, treeOpts);\n          } else {\n            /**\r\n             * 如果是树取消\r\n             * 如果方法成立，则不添加到临时集合中\r\n             */\n            if (checkMethod) {\n              XEUtils.eachTree(afterFullData, row => {\n                if (checkMethod({\n                  row\n                }) ? 0 : selection.indexOf(row) > -1) {\n                  selectRows.push(row);\n                }\n              }, treeOpts);\n            }\n          }\n        } else {\n          if (value) {\n            /**\r\n             * 如果是行勾选\r\n             * 如果存在选中方法且成立或者本身已勾选，则添加到临时集合中\r\n             * 如果不存在选中方法，则添加所有数据到临时集合中\r\n             */\n            if (checkMethod) {\n              selectRows = afterFullData.filter(row => selection.indexOf(row) > -1 || checkMethod({\n                row\n              }));\n            } else {\n              selectRows = afterFullData.slice(0);\n            }\n          } else {\n            /**\r\n             * 如果是行取消\r\n             * 如果方法成立，则不添加到临时集合中；如果方法不成立则判断当前是否已勾选，如果已被勾选则添加到新集合中\r\n             * 如果不存在选中方法，无需处理，临时集合默认为空\r\n             */\n            if (checkMethod) {\n              selectRows = afterFullData.filter(row => checkMethod({\n                row\n              }) ? 0 : selection.indexOf(row) > -1);\n            }\n          }\n        }\n      }\n\n      if (reserve) {\n        if (value) {\n          selectRows.forEach(row => {\n            checkboxReserveRowMap[getRowid(this, row)] = row;\n          });\n        } else {\n          afterFullData.forEach(row => this.handleCheckboxReserveRow(row, false));\n        }\n      }\n\n      this.selection = property ? [] : beforeSelection.concat(selectRows);\n    }\n\n    this.treeIndeterminates = [];\n    this.checkSelectionStatus();\n  },\n\n  checkSelectionStatus() {\n    const afterFullData = this.afterFullData,\n          selection = this.selection,\n          treeIndeterminates = this.treeIndeterminates,\n          checkboxOpts = this.checkboxOpts,\n          treeConfig = this.treeConfig;\n    const checkField = checkboxOpts.checkField,\n          halfField = checkboxOpts.halfField,\n          checkStrictly = checkboxOpts.checkStrictly,\n          checkMethod = checkboxOpts.checkMethod;\n\n    if (!checkStrictly) {\n      let isAllSelected = false;\n      let isIndeterminate = false;\n\n      if (checkField) {\n        isAllSelected = afterFullData.length && afterFullData.every(checkMethod ? row => !checkMethod({\n          row\n        }) || XEUtils.get(row, checkField) : row => XEUtils.get(row, checkField));\n\n        if (treeConfig) {\n          if (halfField) {\n            isIndeterminate = !isAllSelected && afterFullData.some(row => XEUtils.get(row, checkField) || XEUtils.get(row, halfField) || treeIndeterminates.indexOf(row) > -1);\n          } else {\n            isIndeterminate = !isAllSelected && afterFullData.some(row => XEUtils.get(row, checkField) || treeIndeterminates.indexOf(row) > -1);\n          }\n        } else {\n          if (halfField) {\n            isIndeterminate = !isAllSelected && afterFullData.some(row => XEUtils.get(row, checkField) || XEUtils.get(row, halfField));\n          } else {\n            isIndeterminate = !isAllSelected && afterFullData.some(row => XEUtils.get(row, checkField));\n          }\n        }\n      } else {\n        isAllSelected = afterFullData.length && afterFullData.every(checkMethod ? row => !checkMethod({\n          row\n        }) || selection.indexOf(row) > -1 : row => selection.indexOf(row) > -1);\n\n        if (treeConfig) {\n          isIndeterminate = !isAllSelected && afterFullData.some(row => treeIndeterminates.indexOf(row) > -1 || selection.indexOf(row) > -1);\n        } else {\n          isIndeterminate = !isAllSelected && afterFullData.some(row => selection.indexOf(row) > -1);\n        }\n      }\n\n      this.isAllSelected = isAllSelected;\n      this.isIndeterminate = isIndeterminate;\n    }\n  },\n\n  // 还原展开、选中等相关状态\n  handleReserveStatus() {\n    const expandColumn = this.expandColumn,\n          treeOpts = this.treeOpts,\n          treeConfig = this.treeConfig,\n          fullDataRowIdData = this.fullDataRowIdData,\n          fullAllDataRowMap = this.fullAllDataRowMap,\n          currentRow = this.currentRow,\n          selectRow = this.selectRow,\n          radioReserveRow = this.radioReserveRow,\n          radioOpts = this.radioOpts,\n          checkboxOpts = this.checkboxOpts,\n          selection = this.selection,\n          rowExpandeds = this.rowExpandeds,\n          treeExpandeds = this.treeExpandeds,\n          expandOpts = this.expandOpts; // 单选框\n\n    if (selectRow && !fullAllDataRowMap.has(selectRow)) {\n      this.selectRow = null; // 刷新单选行状态\n    } // 还原保留选中状态\n\n\n    if (radioOpts.reserve && radioReserveRow) {\n      const rowid = getRowid(this, radioReserveRow);\n\n      if (fullDataRowIdData[rowid]) {\n        this.setRadioRow(fullDataRowIdData[rowid].row);\n      }\n    } // 复选框\n\n\n    this.selection = getRecoverRow(this, selection); // 刷新多选行状态\n    // 还原保留选中状态\n\n    if (checkboxOpts.reserve) {\n      this.setCheckboxRow(handleReserveRow(this, this.checkboxReserveRowMap), true);\n    }\n\n    if (currentRow && !fullAllDataRowMap.has(currentRow)) {\n      this.currentRow = null; // 刷新当前行状态\n    } // 行展开\n\n\n    this.rowExpandeds = expandColumn ? getRecoverRow(this, rowExpandeds) : []; // 刷新行展开状态\n    // 还原保留状态\n\n    if (expandColumn && expandOpts.reserve) {\n      this.setRowExpand(handleReserveRow(this, this.rowExpandedReserveRowMap), true);\n    } // 树展开\n\n\n    this.treeExpandeds = treeConfig ? getRecoverRow(this, treeExpandeds) : []; // 刷新树展开状态\n\n    if (treeConfig && treeOpts.reserve) {\n      this.setTreeExpand(handleReserveRow(this, this.treeExpandedReserveRowMap), true);\n    }\n  },\n\n  /**\r\n   * 获取单选框保留选中的行\r\n   */\n  getRadioReserveRecord() {\n    const fullDataRowIdData = this.fullDataRowIdData,\n          radioReserveRow = this.radioReserveRow,\n          radioOpts = this.radioOpts;\n\n    if (radioOpts.reserve && radioReserveRow) {\n      if (!fullDataRowIdData[getRowid(this, radioReserveRow)]) {\n        return radioReserveRow;\n      }\n    }\n\n    return null;\n  },\n\n  clearRadioReserve() {\n    this.radioReserveRow = null;\n    return this.$nextTick();\n  },\n\n  handleRadioReserveRow(row) {\n    const radioOpts = this.radioOpts;\n\n    if (radioOpts.reserve) {\n      this.radioReserveRow = row;\n    }\n  },\n\n  /**\r\n   * 获取复选框保留选中的行\r\n   */\n  getCheckboxReserveRecords() {\n    const fullDataRowIdData = this.fullDataRowIdData,\n          checkboxReserveRowMap = this.checkboxReserveRowMap,\n          checkboxOpts = this.checkboxOpts;\n    const reserveSelection = [];\n\n    if (checkboxOpts.reserve) {\n      XEUtils.each(checkboxReserveRowMap, (row, rowid) => {\n        if (row && !fullDataRowIdData[rowid]) {\n          reserveSelection.push(row);\n        }\n      });\n    }\n\n    return reserveSelection;\n  },\n\n  clearCheckboxReserve() {\n    this.checkboxReserveRowMap = {};\n    return this.$nextTick();\n  },\n\n  handleCheckboxReserveRow(row, checked) {\n    const checkboxReserveRowMap = this.checkboxReserveRowMap,\n          checkboxOpts = this.checkboxOpts;\n\n    if (checkboxOpts.reserve) {\n      const rowid = getRowid(this, row);\n\n      if (checked) {\n        checkboxReserveRowMap[rowid] = row;\n      } else if (checkboxReserveRowMap[rowid]) {\n        delete checkboxReserveRowMap[rowid];\n      }\n    }\n  },\n\n  /**\r\n   * 多选，选中所有事件\r\n   */\n  triggerCheckAllEvent(evnt, value) {\n    this.setAllCheckboxRow(value);\n    this.emitEvent('checkbox-all', {\n      records: this.getCheckboxRecords(),\n      reserves: this.getCheckboxReserveRecords(),\n      indeterminates: this.getCheckboxIndeterminateRecords(),\n      checked: value\n    }, evnt);\n  },\n\n  /**\r\n   * 多选，切换所有行的选中状态\r\n   */\n  toggleAllCheckboxRow() {\n    this.triggerCheckAllEvent(null, !this.isAllSelected);\n    return this.$nextTick();\n  },\n\n  /**\r\n   * 用于多选行，手动清空用户的选择\r\n   * 清空行为不管是否被禁用还是保留记录，都将彻底清空选中状态\r\n   */\n  clearCheckboxRow() {\n    const tableFullData = this.tableFullData,\n          treeConfig = this.treeConfig,\n          treeOpts = this.treeOpts,\n          checkboxOpts = this.checkboxOpts;\n    const property = checkboxOpts.checkField,\n          reserve = checkboxOpts.reserve;\n\n    if (property) {\n      if (treeConfig) {\n        XEUtils.eachTree(tableFullData, item => XEUtils.set(item, property, false), treeOpts);\n      } else {\n        tableFullData.forEach(item => XEUtils.set(item, property, false));\n      }\n    }\n\n    if (reserve) {\n      tableFullData.forEach(row => this.handleCheckboxReserveRow(row, false));\n    }\n\n    this.isAllSelected = false;\n    this.isIndeterminate = false;\n    this.selection = [];\n    this.treeIndeterminates = [];\n    return this.$nextTick();\n  },\n\n  /**\r\n   * 处理单选框默认勾选\r\n   */\n  handleDefaultRadioChecked() {\n    const radioOpts = this.radioOpts,\n          fullDataRowIdData = this.fullDataRowIdData;\n    const rowid = radioOpts.checkRowKey,\n          reserve = radioOpts.reserve;\n\n    if (rowid) {\n      if (fullDataRowIdData[rowid]) {\n        this.setRadioRow(fullDataRowIdData[rowid].row);\n      }\n\n      if (reserve) {\n        const rowkey = getRowkey(this);\n        this.radioReserveRow = {\n          [rowkey]: rowid\n        };\n      }\n    }\n  },\n\n  /**\r\n   * 单选，行选中事件\r\n   */\n  triggerRadioRowEvent(evnt, params) {\n    const isChange = this.selectRow !== params.row;\n    this.setRadioRow(params.row);\n\n    if (isChange) {\n      this.emitEvent('radio-change', params, evnt);\n    }\n  },\n\n  triggerCurrentRowEvent(evnt, params) {\n    const isChange = this.currentRow !== params.row;\n    this.setCurrentRow(params.row);\n\n    if (isChange) {\n      this.emitEvent('current-change', params, evnt);\n    }\n  },\n\n  /**\r\n   * 用于当前行，设置某一行为高亮状态\r\n   * @param {Row} row 行对象\r\n   */\n  setCurrentRow(row) {\n    const $el = this.$el;\n    this.clearCurrentRow();\n    this.clearCurrentColumn();\n    this.currentRow = row;\n\n    if (this.highlightCurrentRow) {\n      if ($el) {\n        XEUtils.arrayEach($el.querySelectorAll(`[rowid=\"${getRowid(this, row)}\"]`), elem => {\n          addClass(elem, 'row--current');\n          elem.style['background-color'] = $_theme.selected_color;\n        });\n      }\n    }\n\n    return this.$nextTick();\n  },\n\n  isCheckedByRadioRow(row) {\n    return this.selectRow === row;\n  },\n\n  /**\r\n   * 用于单选行，设置某一行为选中状态\r\n   * @param {Row} row 行对象\r\n   */\n  setRadioRow(row) {\n    const radioOpts = this.radioOpts;\n    const checkMethod = radioOpts.checkMethod;\n\n    if (row && (!checkMethod || checkMethod({\n      row\n    }))) {\n      this.selectRow = row;\n      this.handleRadioReserveRow(row);\n    }\n\n    return this.$nextTick();\n  },\n\n  /**\r\n   * 用于当前行，手动清空当前高亮的状态\r\n   */\n  clearCurrentRow() {\n    const $el = this.$el;\n    this.currentRow = null;\n    this.hoverRow = null;\n\n    if ($el) {\n      XEUtils.arrayEach($el.querySelectorAll('.row--current'), elem => {\n        removeClass(elem, 'row--current');\n        elem.style['background-color'] = '';\n      });\n    }\n\n    return this.$nextTick();\n  },\n\n  /**\r\n   * 用于单选行，手动清空用户的选择\r\n   */\n  clearRadioRow() {\n    this.selectRow = null;\n    return this.$nextTick();\n  },\n\n  /**\r\n   * 用于当前行，获取当前行的数据\r\n   */\n  getCurrentRecord() {\n    return this.highlightCurrentRow ? this.currentRow : null;\n  },\n\n  /**\r\n   * 用于单选行，获取当已选中的数据\r\n   */\n  getRadioRecord() {\n    return this.selectRow;\n  },\n\n  /**\r\n   * 行 hover 事件\r\n   */\n  triggerHoverEvent(evnt, _ref6) {\n    let row = _ref6.row;\n    this.setHoverRow(row);\n  },\n\n  setHoverRow(row) {\n    const $el = this.$el;\n    const rowid = getRowid(this, row);\n    this.clearHoverRow();\n\n    if ($el) {\n      XEUtils.arrayEach($el.querySelectorAll(`[rowid=\"${rowid}\"]`), elem => addClass(elem, 'row--hover'));\n    }\n\n    this.hoverRow = row;\n  },\n\n  clearHoverRow() {\n    const $el = this.$el;\n\n    if ($el) {\n      XEUtils.arrayEach($el.querySelectorAll('.vxe-body--row.row--hover'), elem => removeClass(elem, 'row--hover'));\n    }\n\n    this.hoverRow = null;\n  },\n\n  triggerHeaderCellClickEvent(evnt, params) {\n    const _lastResizeTime = this._lastResizeTime,\n          sortOpts = this.sortOpts;\n    const column = params.column;\n    const cell = evnt.currentTarget;\n\n    const triggerResizable = _lastResizeTime && _lastResizeTime > Date.now() - 300;\n\n    const triggerSort = getEventTargetNode(evnt, cell, 'vxe-cell--sort').flag;\n    const triggerFilter = getEventTargetNode(evnt, cell, 'vxe-cell--filter').flag;\n\n    if (sortOpts.trigger === 'cell' && !(triggerResizable || triggerSort || triggerFilter)) {\n      this.triggerSortEvent(evnt, column, getNextSortOrder(this, column));\n    }\n\n    this.emitEvent('header-cell-click', Object.assign({\n      triggerResizable,\n      triggerSort,\n      triggerFilter,\n      cell\n    }, params), evnt);\n\n    if (this.highlightCurrentColumn) {\n      return this.setCurrentColumn(column);\n    }\n\n    return this.$nextTick();\n  },\n\n  triggerHeaderCellDblclickEvent(evnt, params) {\n    this.emitEvent('header-cell-dblclick', Object.assign({\n      cell: evnt.currentTarget\n    }, params), evnt);\n  },\n\n  getCurrentColumn() {\n    return this.highlightCurrentColumn ? this.currentColumn : null;\n  },\n\n  /**\r\n   * 用于当前列，设置某列行为高亮状态\r\n   * @param {ColumnInfo} fieldOrColumn 列配置\r\n   */\n  setCurrentColumn(fieldOrColumn) {\n    const column = handleFieldOrColumn(this, fieldOrColumn);\n\n    if (column) {\n      this.clearCurrentRow();\n      this.clearCurrentColumn();\n      this.currentColumn = column;\n    }\n\n    return this.$nextTick();\n  },\n\n  /**\r\n   * 用于当前列，手动清空当前高亮的状态\r\n   */\n  clearCurrentColumn() {\n    this.currentColumn = null;\n    return this.$nextTick();\n  },\n\n  checkValidate(type) {\n    if (VXETable._valid) {\n      return this.triggerValidate(type);\n    }\n\n    return this.$nextTick();\n  },\n\n  /**\r\n   * 当单元格发生改变时\r\n   * 如果存在规则，则校验\r\n   */\n  handleChangeCell(evnt, params) {\n    this.checkValidate('blur').catch(e => e).then(() => {\n      this.handleActived(params, evnt).then(() => this.checkValidate('change')).catch(e => e);\n    });\n  },\n\n  /**\r\n   * 列点击事件\r\n   * 如果是单击模式，则激活为编辑状态\r\n   * 如果是双击模式，则单击后选中状态\r\n   */\n  triggerCellClickEvent(evnt, params) {\n    const highlightCurrentRow = this.highlightCurrentRow,\n          editStore = this.editStore,\n          radioOpts = this.radioOpts,\n          expandOpts = this.expandOpts,\n          treeOpts = this.treeOpts,\n          editConfig = this.editConfig,\n          editOpts = this.editOpts,\n          checkboxOpts = this.checkboxOpts;\n    const actived = editStore.actived;\n    const _params = params,\n          row = _params.row,\n          column = _params.column;\n    const type = column.type,\n          treeNode = column.treeNode;\n    const isRadioType = type === 'radio';\n    const isCheckboxType = type === 'checkbox';\n    const isExpandType = type === 'expand';\n    const cell = evnt.currentTarget;\n    const triggerRadio = isRadioType && getEventTargetNode(evnt, cell, 'vxe-cell--radio').flag;\n    const triggerCheckbox = isCheckboxType && getEventTargetNode(evnt, cell, 'vxe-cell--checkbox').flag;\n    const triggerTreeNode = treeNode && getEventTargetNode(evnt, cell, 'vxe-tree--btn-wrapper').flag;\n    const triggerExpandNode = isExpandType && getEventTargetNode(evnt, cell, 'vxe-table--expanded').flag;\n    params = Object.assign({\n      cell,\n      triggerRadio,\n      triggerCheckbox,\n      triggerTreeNode,\n      triggerExpandNode\n    }, params);\n\n    if (!triggerCheckbox && !triggerRadio) {\n      // 如果是展开行\n      if (!triggerExpandNode && (expandOpts.trigger === 'row' || isExpandType && expandOpts.trigger === 'cell')) {\n        this.triggerRowExpandEvent(evnt, params);\n      } // 如果是树形表格\n\n\n      if (treeOpts.trigger === 'row' || treeNode && treeOpts.trigger === 'cell') {\n        this.triggerTreeExpandEvent(evnt, params);\n      }\n    } // 如果点击了树节点\n\n\n    if (!triggerTreeNode) {\n      if (!triggerExpandNode) {\n        // 如果是高亮行\n        if (highlightCurrentRow) {\n          if (!triggerCheckbox && !triggerRadio) {\n            this.triggerCurrentRowEvent(evnt, params);\n          }\n        } // 如果是单选框\n\n\n        if (!triggerRadio && (radioOpts.trigger === 'row' || isRadioType && radioOpts.trigger === 'cell')) {\n          this.triggerRadioRowEvent(evnt, params);\n        } // 如果是复选框\n\n\n        if (!triggerCheckbox && (checkboxOpts.trigger === 'row' || isCheckboxType && checkboxOpts.trigger === 'cell')) {\n          this.handleToggleCheckRowEvent(evnt, params);\n        }\n      } // 如果设置了单元格选中功能，则不会使用点击事件去处理（只能支持双击模式）\n\n\n      if (editConfig) {\n        if (editOpts.trigger === 'manual') {\n          if (actived.args && actived.row === row && column !== actived.column) {\n            this.handleChangeCell(evnt, params);\n          }\n        } else if (!actived.args || row !== actived.row || column !== actived.column) {\n          if (editOpts.trigger === 'click') {\n            this.handleChangeCell(evnt, params);\n          } else if (editOpts.trigger === 'dblclick') {\n            if (editOpts.mode === 'row' && actived.row === row) {\n              this.handleChangeCell(evnt, params);\n            }\n          }\n        }\n      }\n    }\n\n    this.emitEvent('cell-click', params, evnt);\n  },\n\n  /**\r\n   * 列双击点击事件\r\n   * 如果是双击模式，则激活为编辑状态\r\n   */\n  triggerCellDblclickEvent(evnt, params) {\n    const editStore = this.editStore,\n          editConfig = this.editConfig,\n          editOpts = this.editOpts;\n    const actived = editStore.actived;\n    const cell = evnt.currentTarget;\n    params.cell = cell;\n\n    if (editConfig && editOpts.trigger === 'dblclick') {\n      if (!actived.args || evnt.currentTarget !== actived.args.cell) {\n        if (editOpts.mode === 'row') {\n          this.checkValidate('blur').catch(e => e).then(() => {\n            this.handleActived(params, evnt).then(() => this.checkValidate('change')).catch(e => e);\n          });\n        } else if (editOpts.mode === 'cell') {\n          this.handleActived(params, evnt).then(() => this.checkValidate('change')).catch(e => e);\n        }\n      }\n    }\n\n    this.emitEvent('cell-dblclick', params, evnt);\n  },\n\n  handleDefaultSort() {\n    const sortConfig = this.sortConfig,\n          sortOpts = this.sortOpts;\n    let defaultSort = sortOpts.defaultSort;\n\n    if (defaultSort) {\n      if (!XEUtils.isArray(defaultSort)) {\n        defaultSort = [defaultSort];\n      }\n\n      if (defaultSort.length) {\n        (sortConfig.multiple ? defaultSort : defaultSort.slice(0, 1)).forEach(item => {\n          const field = item.field,\n                order = item.order;\n\n          if (field && order) {\n            const column = this.getColumnByField(field);\n\n            if (column && column.sortable) {\n              column.order = order;\n              column.sortTime = Date.now();\n            }\n          }\n        });\n\n        if (!sortOpts.remote) {\n          this.handleTableData(true).then(this.updateStyle);\n        }\n      }\n    }\n  },\n\n  /**\r\n   * 点击排序事件\r\n   */\n  triggerSortEvent(evnt, column, order) {\n    const sortOpts = this.sortOpts;\n    const property = column.property;\n\n    if (column.sortable || column.remoteSort) {\n      let row = this.currentRow; //加\n\n      row && this.clearCurrentRow(); //加\n\n      if (!order || column.order === order) {\n        this.clearSort(sortOpts.multiple ? column : null);\n      } else {\n        //        this.sort({ field: property, order })//删\n        this.sort({\n          field: column,\n          order\n        }); //加\n      }\n\n      const params = {\n        column,\n        property,\n        order: column.order,\n        sortList: this.getSortColumns()\n      };\n      row && this.$nextTick(() => this.setCurrentRow(row)); //加\n\n      this.emitEvent('sort-change', params, evnt);\n    }\n  },\n\n  sort(sortConfs, sortOrder) {\n    const sortOpts = this.sortOpts;\n    const multiple = sortOpts.multiple,\n          remote = sortOpts.remote,\n          orders = sortOpts.orders;\n\n    if (sortConfs) {\n      if (XEUtils.isString(sortConfs)) {\n        sortConfs = [{\n          field: sortConfs,\n          order: sortOrder\n        }];\n      }\n    }\n\n    if (!XEUtils.isArray(sortConfs)) {\n      sortConfs = [sortConfs];\n    }\n\n    if (sortConfs.length) {\n      let firstSortColumn;\n\n      if (!multiple) {\n        clearAllSort(this);\n      }\n\n      (multiple ? sortConfs : [sortConfs[0]]).forEach(confs => {\n        let field = confs.field,\n            order = confs.order;\n        let column = field;\n\n        if (XEUtils.isString(field)) {\n          column = this.getColumnByField(field);\n        }\n\n        if (column && (column.sortable || column.remoteSort)) {\n          if (!firstSortColumn) {\n            firstSortColumn = column;\n          }\n\n          if (orders.indexOf(order) === -1) {\n            order = getNextSortOrder(this, column);\n          }\n\n          if (column.order !== order) {\n            column.order = order;\n          }\n        }\n      }); // 如果是服务端排序，则跳过本地排序处理\n\n      if (!remote || firstSortColumn && firstSortColumn.remoteSort) {\n        this.handleTableData(true);\n      }\n\n      return this.$nextTick().then(this.updateStyle);\n    }\n\n    return this.$nextTick();\n  },\n\n  /**\r\n   * 清空指定列的排序条件\r\n   * 如果为空则清空所有列的排序条件\r\n   * @param {String} column 列或字段名\r\n   */\n  clearSort(fieldOrColumn) {\n    const sortOpts = this.sortOpts;\n\n    if (fieldOrColumn) {\n      const column = handleFieldOrColumn(this, fieldOrColumn);\n\n      if (column) {\n        column.order = null;\n      }\n    } else {\n      clearAllSort(this);\n    }\n\n    if (!sortOpts.remote) {\n      return this.handleTableData(true);\n    }\n\n    return this.$nextTick();\n  },\n\n  // 在 v3 中废弃\n  getSortColumn() {\n    if (process.env.VUE_APP_VXE_TABLE_ENV === 'development') {\n      UtilTools.warn('vxe.error.delFunc', ['getSortColumn', 'getSortColumns']);\n    }\n\n    return XEUtils.find(this.tableFullColumn, column => (column.sortable || column.remoteSort) && column.order);\n  },\n\n  isSort(fieldOrColumn) {\n    if (fieldOrColumn) {\n      const column = handleFieldOrColumn(this, fieldOrColumn);\n      return column && column.sortable && !!column.order;\n    }\n\n    return this.getSortColumns().length > 0;\n  },\n\n  getSortColumns() {\n    const sortList = [];\n    this.tableFullColumn.forEach(column => {\n      const order = column.order;\n\n      if ((column.sortable || column.remoteSort) && order) {\n        sortList.push({\n          column,\n          property: column.property,\n          order\n        });\n      }\n    });\n    return sortList;\n  },\n\n  /**\r\n   * 关闭筛选\r\n   * @param {Event} evnt 事件\r\n   */\n  closeFilter() {\n    Object.assign(this.filterStore, {\n      isAllSelected: false,\n      isIndeterminate: false,\n      options: [],\n      visible: false\n    });\n    return this.$nextTick();\n  },\n\n  /**\r\n   * 判断指定列是否为筛选状态，如果为空则判断所有列\r\n   * @param {String} fieldOrColumn 字段名\r\n   */\n  isFilter(fieldOrColumn) {\n    const column = handleFieldOrColumn(this, fieldOrColumn);\n\n    if (column) {\n      return column.filters && column.filters.some(option => option.checked);\n    }\n\n    return this.getCheckedFilters().length > 0;\n  },\n\n  /**\r\n   * 判断展开行是否懒加载完成\r\n   * @param {Row} row 行对象\r\n   */\n  isRowExpandLoaded(row) {\n    const rest = this.fullAllDataRowMap.get(row);\n    return rest && rest.expandLoaded;\n  },\n\n  clearRowExpandLoaded(row) {\n    const expandOpts = this.expandOpts,\n          expandLazyLoadeds = this.expandLazyLoadeds,\n          fullAllDataRowMap = this.fullAllDataRowMap;\n    const lazy = expandOpts.lazy;\n    const rest = fullAllDataRowMap.get(row);\n\n    if (lazy && rest) {\n      rest.expandLoaded = false;\n      XEUtils.remove(expandLazyLoadeds, item => row === item);\n    }\n\n    return this.$nextTick();\n  },\n\n  /**\r\n   * 重新加载展开行的内容\r\n   * @param {Row} row 行对象\r\n   */\n  reloadExpandContent(row) {\n    const expandOpts = this.expandOpts,\n          expandLazyLoadeds = this.expandLazyLoadeds;\n    const lazy = expandOpts.lazy;\n\n    if (lazy && expandLazyLoadeds.indexOf(row) === -1) {\n      this.clearRowExpandLoaded(row).then(() => this.handleAsyncRowExpand(row));\n    }\n\n    return this.$nextTick();\n  },\n\n  /**\r\n   * 展开行事件\r\n   */\n  triggerRowExpandEvent(evnt, params) {\n    const expandOpts = this.expandOpts,\n          expandLazyLoadeds = this.expandLazyLoadeds,\n          column = this.expandColumn;\n    const row = params.row;\n    const lazy = expandOpts.lazy;\n\n    if (!lazy || expandLazyLoadeds.indexOf(row) === -1) {\n      const expanded = !this.isExpandByRow(row);\n      const columnIndex = this.getColumnIndex(column);\n      const $columnIndex = this.getVMColumnIndex(column);\n      this.setRowExpand(row, expanded);\n      this.emitEvent('toggle-row-expand', {\n        expanded,\n        column,\n        columnIndex,\n        $columnIndex,\n        row,\n        rowIndex: this.getRowIndex(row),\n        $rowIndex: this.getVMRowIndex(row)\n      }, evnt);\n    }\n  },\n\n  /**\r\n   * 切换展开行\r\n   */\n  toggleRowExpand(row) {\n    return this.setRowExpand(row, !this.isExpandByRow(row));\n  },\n\n  /**\r\n   * 处理默认展开行\r\n   */\n  handleDefaultRowExpand() {\n    const expandOpts = this.expandOpts,\n          fullDataRowIdData = this.fullDataRowIdData;\n    const expandAll = expandOpts.expandAll,\n          expandRowKeys = expandOpts.expandRowKeys;\n\n    if (expandAll) {\n      this.setAllRowExpand(true);\n    } else if (expandRowKeys) {\n      const defExpandeds = [];\n      expandRowKeys.forEach(rowid => {\n        if (fullDataRowIdData[rowid]) {\n          defExpandeds.push(fullDataRowIdData[rowid].row);\n        }\n      });\n      this.setRowExpand(defExpandeds, true);\n    }\n  },\n\n  /**\r\n   * 设置所有行的展开与否\r\n   * @param {Boolean} expanded 是否展开\r\n   */\n  setAllRowExpand(expanded) {\n    return this.setRowExpand(this.expandOpts.lazy ? this.tableData : this.tableFullData, expanded);\n  },\n\n  handleAsyncRowExpand(row) {\n    const rest = this.fullAllDataRowMap.get(row);\n    return new Promise(resolve => {\n      this.expandLazyLoadeds.push(row);\n      this.expandOpts.loadMethod({\n        $table: this,\n        row,\n        rowIndex: this.getRowIndex(row),\n        $rowIndex: this.getVMRowIndex(row)\n      }).catch(e => e).then(() => {\n        rest.expandLoaded = true;\n        XEUtils.remove(this.expandLazyLoadeds, item => item === row);\n        this.rowExpandeds.push(row);\n        resolve(this.$nextTick().then(this.recalculate));\n      });\n    });\n  },\n\n  /**\r\n   * 设置展开行，二个参数设置这一行展开与否\r\n   * 支持单行\r\n   * 支持多行\r\n   * @param {Array/Row} rows 行数据\r\n   * @param {Boolean} expanded 是否展开\r\n   */\n  setRowExpand(rows, expanded) {\n    const fullAllDataRowMap = this.fullAllDataRowMap,\n          expandLazyLoadeds = this.expandLazyLoadeds,\n          expandOpts = this.expandOpts,\n          column = this.expandColumn;\n    let rowExpandeds = this.rowExpandeds;\n    const reserve = expandOpts.reserve,\n          lazy = expandOpts.lazy,\n          accordion = expandOpts.accordion,\n          toggleMethod = expandOpts.toggleMethod;\n    const lazyRests = [];\n    const columnIndex = this.getColumnIndex(column);\n    const $columnIndex = this.getVMColumnIndex(column);\n\n    if (rows) {\n      if (!XEUtils.isArray(rows)) {\n        rows = [rows];\n      }\n\n      if (accordion) {\n        // 只能同时展开一个\n        rowExpandeds = [];\n        rows = rows.slice(rows.length - 1, rows.length);\n      }\n\n      const validRows = toggleMethod ? rows.filter(row => toggleMethod({\n        expanded,\n        column,\n        columnIndex,\n        $columnIndex,\n        row,\n        rowIndex: this.getRowIndex(row),\n        $rowIndex: this.getVMRowIndex(row)\n      })) : rows;\n\n      if (expanded) {\n        validRows.forEach(row => {\n          if (rowExpandeds.indexOf(row) === -1) {\n            const rest = fullAllDataRowMap.get(row);\n            const isLoad = lazy && !rest.expandLoaded && expandLazyLoadeds.indexOf(row) === -1;\n\n            if (isLoad) {\n              lazyRests.push(this.handleAsyncRowExpand(row));\n            } else {\n              rowExpandeds.push(row);\n            }\n          }\n        });\n      } else {\n        XEUtils.remove(rowExpandeds, row => validRows.indexOf(row) > -1);\n      }\n\n      if (reserve) {\n        validRows.forEach(row => this.handleRowExpandReserve(row, expanded));\n      }\n    }\n\n    this.rowExpandeds = rowExpandeds;\n    return Promise.all(lazyRests).then(this.recalculate);\n  },\n\n  /**\r\n   * 判断行是否为展开状态\r\n   * @param {Row} row 行对象\r\n   */\n  isExpandByRow(row) {\n    return this.rowExpandeds.indexOf(row) > -1;\n  },\n\n  /**\r\n   * 手动清空展开行状态，数据会恢复成未展开的状态\r\n   */\n  clearRowExpand() {\n    const expandOpts = this.expandOpts,\n          rowExpandeds = this.rowExpandeds,\n          tableFullData = this.tableFullData;\n    const reserve = expandOpts.reserve;\n    const isExists = rowExpandeds.length;\n    this.rowExpandeds = [];\n\n    if (reserve) {\n      tableFullData.forEach(row => this.handleRowExpandReserve(row, false));\n    }\n\n    return this.$nextTick().then(() => {\n      if (isExists) {\n        this.recalculate();\n      }\n    });\n  },\n\n  clearRowExpandReserve() {\n    this.rowExpandedReserveRowMap = {};\n    return this.$nextTick();\n  },\n\n  handleRowExpandReserve(row, expanded) {\n    const rowExpandedReserveRowMap = this.rowExpandedReserveRowMap,\n          expandOpts = this.expandOpts;\n\n    if (expandOpts.reserve) {\n      const rowid = getRowid(this, row);\n\n      if (expanded) {\n        rowExpandedReserveRowMap[rowid] = row;\n      } else if (rowExpandedReserveRowMap[rowid]) {\n        delete rowExpandedReserveRowMap[rowid];\n      }\n    }\n  },\n\n  getRowExpandRecords() {\n    return this.rowExpandeds.slice(0);\n  },\n\n  getTreeExpandRecords() {\n    return this.treeExpandeds.slice(0);\n  },\n\n  /**\r\n   * 获取数表格状态\r\n   */\n  getTreeStatus() {\n    if (this.treeConfig) {\n      return {\n        config: this.treeOpts,\n        rowExpandeds: this.getTreeExpandRecords()\n      };\n    }\n\n    return null;\n  },\n\n  /**\r\n   * 判断树节点是否懒加载完成\r\n   * @param {Row} row 行对象\r\n   */\n  isTreeExpandLoaded(row) {\n    const rest = this.fullAllDataRowMap.get(row);\n    return rest && rest.treeLoaded;\n  },\n\n  clearTreeExpandLoaded(row) {\n    const treeOpts = this.treeOpts,\n          treeExpandeds = this.treeExpandeds,\n          fullAllDataRowMap = this.fullAllDataRowMap;\n    const lazy = treeOpts.lazy;\n    const rest = fullAllDataRowMap.get(row);\n\n    if (lazy && rest) {\n      rest.treeLoaded = false;\n      XEUtils.remove(treeExpandeds, item => row === item);\n    }\n\n    return this.$nextTick();\n  },\n\n  /**\r\n   * 重新加载树的子节点\r\n   * @param {Row} row 行对象\r\n   */\n  reloadTreeChilds(row) {\n    const treeOpts = this.treeOpts,\n          treeLazyLoadeds = this.treeLazyLoadeds;\n    const lazy = treeOpts.lazy,\n          hasChild = treeOpts.hasChild;\n\n    if (lazy && row[hasChild] && treeLazyLoadeds.indexOf(row) === -1) {\n      this.clearTreeExpandLoaded(row).then(() => this.handleAsyncTreeExpandChilds(row));\n    }\n\n    return this.$nextTick();\n  },\n\n  /**\r\n   * 展开树节点事件\r\n   */\n  triggerTreeExpandEvent(evnt, params) {\n    const treeOpts = this.treeOpts,\n          treeLazyLoadeds = this.treeLazyLoadeds;\n    const row = params.row,\n          column = params.column;\n    const lazy = treeOpts.lazy;\n\n    if (!lazy || treeLazyLoadeds.indexOf(row) === -1) {\n      const expanded = !this.isTreeExpandByRow(row);\n      const columnIndex = this.getColumnIndex(column);\n      const $columnIndex = this.getVMColumnIndex(column);\n      this.setTreeExpand(row, expanded);\n      this.emitEvent('toggle-tree-expand', {\n        expanded,\n        column,\n        columnIndex,\n        $columnIndex,\n        row\n      }, evnt);\n    }\n  },\n\n  /**\r\n   * 切换/展开树节点\r\n   */\n  toggleTreeExpand(row) {\n    return this.setTreeExpand(row, !this.isTreeExpandByRow(row));\n  },\n\n  /**\r\n   * 处理默认展开树节点\r\n   */\n  handleDefaultTreeExpand() {\n    const treeConfig = this.treeConfig,\n          treeOpts = this.treeOpts,\n          tableFullData = this.tableFullData;\n\n    if (treeConfig) {\n      const expandAll = treeOpts.expandAll,\n            expandRowKeys = treeOpts.expandRowKeys;\n\n      if (expandAll) {\n        this.setAllTreeExpand(true);\n      } else if (expandRowKeys) {\n        const defExpandeds = [];\n        const rowkey = getRowkey(this);\n        expandRowKeys.forEach(rowid => {\n          const matchObj = XEUtils.findTree(tableFullData, item => rowid === XEUtils.get(item, rowkey), treeOpts);\n\n          if (matchObj) {\n            defExpandeds.push(matchObj.item);\n          }\n        });\n        this.setTreeExpand(defExpandeds, true);\n      }\n    }\n  },\n\n  handleAsyncTreeExpandChilds(row) {\n    const fullAllDataRowMap = this.fullAllDataRowMap,\n          treeExpandeds = this.treeExpandeds,\n          treeOpts = this.treeOpts,\n          treeLazyLoadeds = this.treeLazyLoadeds,\n          checkboxOpts = this.checkboxOpts;\n    const loadMethod = treeOpts.loadMethod;\n    const checkStrictly = checkboxOpts.checkStrictly;\n    const rest = fullAllDataRowMap.get(row);\n    return new Promise(resolve => {\n      treeLazyLoadeds.push(row);\n      loadMethod({\n        $table: this,\n        row\n      }).catch(() => []).then(childRecords => {\n        rest.treeLoaded = true;\n        XEUtils.remove(treeLazyLoadeds, item => item === row);\n\n        if (!XEUtils.isArray(childRecords)) {\n          childRecords = [];\n        }\n\n        if (childRecords) {\n          this.loadChildren(row, childRecords).then(childRows => {\n            if (childRows.length && treeExpandeds.indexOf(row) === -1) {\n              treeExpandeds.push(row);\n            } // 如果当前节点已选中，则展开后子节点也被选中\n\n\n            if (!checkStrictly && this.isCheckedByCheckboxRow(row)) {\n              this.setCheckboxRow(childRows, true);\n            }\n          });\n        }\n\n        resolve(this.$nextTick().then(this.recalculate));\n      });\n    });\n  },\n\n  /**\r\n   * 设置所有树节点的展开与否\r\n   * @param {Boolean} expanded 是否展开\r\n   */\n  setAllTreeExpand(expanded) {\n    const tableFullData = this.tableFullData,\n          treeOpts = this.treeOpts;\n    const lazy = treeOpts.lazy,\n          children = treeOpts.children;\n    const expandeds = [];\n    XEUtils.eachTree(tableFullData, row => {\n      const rowChildren = row[children];\n\n      if (lazy || rowChildren && rowChildren.length) {\n        expandeds.push(row);\n      }\n    }, treeOpts);\n    return this.setTreeExpand(expandeds, expanded);\n  },\n\n  /**\r\n   * 设置展开树形节点，二个参数设置这一行展开与否\r\n   * 支持单行\r\n   * 支持多行\r\n   * @param {Array/Row} rows 行数据\r\n   * @param {Boolean} expanded 是否展开\r\n   */\n  setTreeExpand(rows, expanded) {\n    const fullAllDataRowMap = this.fullAllDataRowMap,\n          tableFullData = this.tableFullData,\n          treeExpandeds = this.treeExpandeds,\n          treeOpts = this.treeOpts,\n          treeLazyLoadeds = this.treeLazyLoadeds,\n          treeNodeColumn = this.treeNodeColumn;\n    const reserve = treeOpts.reserve,\n          lazy = treeOpts.lazy,\n          hasChild = treeOpts.hasChild,\n          children = treeOpts.children,\n          accordion = treeOpts.accordion,\n          toggleMethod = treeOpts.toggleMethod;\n    const result = [];\n    const columnIndex = this.getColumnIndex(treeNodeColumn);\n    const $columnIndex = this.getVMColumnIndex(treeNodeColumn);\n\n    if (rows) {\n      if (!XEUtils.isArray(rows)) {\n        rows = [rows];\n      }\n\n      if (rows.length) {\n        let validRows = toggleMethod ? rows.filter(row => toggleMethod({\n          expanded,\n          column: treeNodeColumn,\n          columnIndex,\n          $columnIndex,\n          row\n        })) : rows;\n\n        if (accordion) {\n          validRows = validRows.length ? [validRows[validRows.length - 1]] : []; // 同一级只能展开一个\n\n          const matchObj = XEUtils.findTree(tableFullData, item => item === validRows[0], treeOpts);\n\n          if (matchObj) {\n            XEUtils.remove(treeExpandeds, item => matchObj.items.indexOf(item) > -1);\n          }\n        }\n\n        if (expanded) {\n          validRows.forEach(row => {\n            if (treeExpandeds.indexOf(row) === -1) {\n              const rest = fullAllDataRowMap.get(row);\n              const isLoad = lazy && row[hasChild] && !rest.treeLoaded && treeLazyLoadeds.indexOf(row) === -1; // 是否使用懒加载\n\n              if (isLoad) {\n                result.push(this.handleAsyncTreeExpandChilds(row));\n              } else {\n                if (row[children] && row[children].length) {\n                  treeExpandeds.push(row);\n                }\n              }\n            }\n          });\n        } else {\n          XEUtils.remove(treeExpandeds, row => validRows.indexOf(row) > -1);\n        }\n\n        if (reserve) {\n          validRows.forEach(row => this.handleTreeExpandReserve(row, expanded));\n        }\n\n        return Promise.all(result).then(this.recalculate);\n      }\n    }\n\n    return this.$nextTick();\n  },\n\n  /**\r\n   * 判断行是否为树形节点展开状态\r\n   * @param {Row} row 行对象\r\n   */\n  isTreeExpandByRow(row) {\n    return this.treeExpandeds.indexOf(row) > -1;\n  },\n\n  /**\r\n   * 手动清空树形节点的展开状态，数据会恢复成未展开的状态\r\n   */\n  clearTreeExpand() {\n    const treeOpts = this.treeOpts,\n          treeExpandeds = this.treeExpandeds,\n          tableFullData = this.tableFullData;\n    const reserve = treeOpts.reserve;\n    const isExists = treeExpandeds.length;\n    this.treeExpandeds = [];\n\n    if (reserve) {\n      XEUtils.eachTree(tableFullData, row => this.handleTreeExpandReserve(row, false), treeOpts);\n    }\n\n    return this.$nextTick().then(() => {\n      if (isExists) {\n        this.recalculate();\n      }\n    });\n  },\n\n  clearTreeExpandReserve() {\n    this.treeExpandedReserveRowMap = {};\n    return this.$nextTick();\n  },\n\n  handleTreeExpandReserve(row, expanded) {\n    const treeExpandedReserveRowMap = this.treeExpandedReserveRowMap,\n          treeOpts = this.treeOpts;\n\n    if (treeOpts.reserve) {\n      const rowid = getRowid(this, row);\n\n      if (expanded) {\n        treeExpandedReserveRowMap[rowid] = row;\n      } else if (treeExpandedReserveRowMap[rowid]) {\n        delete treeExpandedReserveRowMap[rowid];\n      }\n    }\n  },\n\n  /**\r\n   * 获取表格的滚动状态\r\n   */\n  getScroll() {\n    const $refs = this.$refs,\n          scrollXLoad = this.scrollXLoad,\n          scrollYLoad = this.scrollYLoad;\n    const bodyElem = $refs.tableBody.$el;\n    return {\n      virtualX: scrollXLoad,\n      virtualY: scrollYLoad,\n      scrollTop: bodyElem.scrollTop,\n      scrollLeft: bodyElem.scrollLeft\n    };\n  },\n\n  /**\r\n   * 横向 X 可视渲染事件处理\r\n   */\n  triggerScrollXEvent() {\n    this.loadScrollXData();\n  },\n\n  loadScrollXData() {\n    const mergeList = this.mergeList,\n          mergeFooterList = this.mergeFooterList,\n          scrollXStore = this.scrollXStore;\n    const startIndex = scrollXStore.startIndex,\n          endIndex = scrollXStore.endIndex,\n          offsetSize = scrollXStore.offsetSize;\n\n    const _computeVirtualX2 = computeVirtualX(this),\n          toVisibleIndex = _computeVirtualX2.toVisibleIndex,\n          visibleSize = _computeVirtualX2.visibleSize;\n\n    const offsetItem = {\n      startIndex: Math.max(0, toVisibleIndex - 1 - offsetSize),\n      endIndex: toVisibleIndex + visibleSize + offsetSize\n    };\n    calculateMergerOffserIndex(mergeList.concat(mergeFooterList), offsetItem, 'col');\n    const offsetStartIndex = offsetItem.startIndex,\n          offsetEndIndex = offsetItem.endIndex;\n\n    if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {\n      if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {\n        scrollXStore.startIndex = offsetStartIndex;\n        scrollXStore.endIndex = offsetEndIndex;\n        this.updateScrollXData();\n      }\n    }\n\n    this.closeTooltip();\n  },\n\n  /**\r\n   * 纵向 Y 可视渲染事件处理\r\n   */\n  triggerScrollYEvent(evnt) {\n    let row = this.currentRow; //加\n\n    row && this.clearCurrentRow(); //加\n\n    const scrollYStore = this.scrollYStore;\n    const adaptive = scrollYStore.adaptive,\n          offsetSize = scrollYStore.offsetSize,\n          visibleSize = scrollYStore.visibleSize; // webkit 浏览器使用最佳的渲染方式，且最高渲染量不能大于 40 条\n\n    if (isWebkit && adaptive && offsetSize * 2 + visibleSize <= 40) {\n      this.loadScrollYData(evnt);\n    } else {\n      this.debounceScrollY(evnt);\n    }\n\n    row && this.$nextTick(() => this.setCurrentRow(row)); //加\n  },\n\n  debounceScrollY: XEUtils.debounce(function (evnt) {\n    this.loadScrollYData(evnt);\n  }, debounceScrollYDuration, {\n    leading: false,\n    trailing: true\n  }),\n\n  /**\r\n   * 纵向 Y 可视渲染处理\r\n   */\n  loadScrollYData(evnt) {\n    const mergeList = this.mergeList,\n          scrollYStore = this.scrollYStore;\n    const startIndex = scrollYStore.startIndex,\n          endIndex = scrollYStore.endIndex,\n          visibleSize = scrollYStore.visibleSize,\n          offsetSize = scrollYStore.offsetSize,\n          rowHeight = scrollYStore.rowHeight;\n    const scrollBodyElem = evnt.currentTarget || evnt.target;\n    const scrollTop = scrollBodyElem.scrollTop;\n    const toVisibleIndex = Math.floor(scrollTop / rowHeight);\n    const offsetItem = {\n      startIndex: Math.max(0, toVisibleIndex - 1 - offsetSize),\n      endIndex: toVisibleIndex + visibleSize + offsetSize\n    };\n    calculateMergerOffserIndex(mergeList, offsetItem, 'row');\n    const offsetStartIndex = offsetItem.startIndex,\n          offsetEndIndex = offsetItem.endIndex;\n\n    if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {\n      if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {\n        scrollYStore.startIndex = offsetStartIndex;\n        scrollYStore.endIndex = offsetEndIndex;\n        this.updateScrollYData();\n      }\n    }\n  },\n\n  // 计算可视渲染相关数据\n  computeScrollLoad() {\n    return this.$nextTick().then(() => {\n      const sYOpts = this.sYOpts,\n            sXOpts = this.sXOpts,\n            scrollXLoad = this.scrollXLoad,\n            scrollYLoad = this.scrollYLoad,\n            scrollXStore = this.scrollXStore,\n            scrollYStore = this.scrollYStore; // 计算 X 逻辑\n\n      if (scrollXLoad) {\n        const _computeVirtualX3 = computeVirtualX(this),\n              visibleXSize = _computeVirtualX3.visibleSize;\n\n        const offsetXSize = sXOpts.oSize ? XEUtils.toNumber(sXOpts.oSize) : browse.msie ? 10 : browse.edge ? 5 : 0;\n        scrollXStore.offsetSize = offsetXSize;\n        scrollXStore.visibleSize = visibleXSize;\n        scrollXStore.endIndex = Math.max(scrollXStore.startIndex + scrollXStore.visibleSize + offsetXSize, scrollXStore.endIndex);\n        this.updateScrollXData();\n      } else {\n        this.updateScrollXSpace();\n      } // 计算 Y 逻辑\n\n\n      const _computeVirtualY = computeVirtualY(this),\n            rowHeight = _computeVirtualY.rowHeight,\n            visibleYSize = _computeVirtualY.visibleSize;\n\n      scrollYStore.rowHeight = rowHeight;\n\n      if (scrollYLoad) {\n        const offsetYSize = sYOpts.oSize ? XEUtils.toNumber(sYOpts.oSize) : browse.msie ? 20 : browse.edge ? 10 : 0;\n        scrollYStore.offsetSize = offsetYSize;\n        scrollYStore.visibleSize = visibleYSize;\n        scrollYStore.endIndex = Math.max(scrollYStore.startIndex + visibleYSize + offsetYSize, scrollYStore.endIndex);\n        this.updateScrollYData();\n      } else {\n        this.updateScrollYSpace();\n      }\n\n      this.rowHeight = rowHeight;\n      this.$nextTick(this.updateStyle);\n    });\n  },\n\n  handleTableColumn() {\n    const scrollXLoad = this.scrollXLoad,\n          visibleColumn = this.visibleColumn,\n          scrollXStore = this.scrollXStore;\n    this.tableColumn = scrollXLoad ? visibleColumn.slice(scrollXStore.startIndex, scrollXStore.endIndex) : visibleColumn.slice(0);\n  },\n\n  updateScrollXData() {\n    this.handleTableColumn();\n    this.updateScrollXSpace();\n  },\n\n  // 更新横向 X 可视渲染上下剩余空间大小\n  updateScrollXSpace() {\n    const $refs = this.$refs,\n          elemStore = this.elemStore,\n          visibleColumn = this.visibleColumn,\n          scrollXStore = this.scrollXStore,\n          scrollXLoad = this.scrollXLoad,\n          tableWidth = this.tableWidth,\n          scrollbarWidth = this.scrollbarWidth;\n    const tableHeader = $refs.tableHeader,\n          tableBody = $refs.tableBody,\n          tableFooter = $refs.tableFooter;\n    const tableBodyElem = tableBody ? tableBody.$el : null;\n\n    if (tableBodyElem) {\n      const tableHeaderElem = tableHeader ? tableHeader.$el : null;\n      const tableFooterElem = tableFooter ? tableFooter.$el : null;\n      const headerElem = tableHeaderElem ? tableHeaderElem.querySelector('.vxe-table--header') : null;\n      const bodyElem = tableBodyElem.querySelector('.vxe-table--body');\n      const footerElem = tableFooterElem ? tableFooterElem.querySelector('.vxe-table--footer') : null;\n      const leftSpaceWidth = visibleColumn.slice(0, scrollXStore.startIndex).reduce((previous, column) => previous + column.renderWidth, 0);\n      let marginLeft = '';\n\n      if (scrollXLoad) {\n        marginLeft = `${leftSpaceWidth}px`;\n      }\n\n      if (headerElem) {\n        headerElem.style.marginLeft = marginLeft;\n      }\n\n      bodyElem.style.marginLeft = marginLeft;\n\n      if (footerElem) {\n        footerElem.style.marginLeft = marginLeft;\n      }\n\n      const containerList = ['main'];\n      containerList.forEach(name => {\n        const layoutList = ['header', 'body', 'footer'];\n        layoutList.forEach(layout => {\n          const xSpaceElem = elemStore[`${name}-${layout}-xSpace`];\n\n          if (xSpaceElem) {\n            xSpaceElem.style.width = scrollXLoad ? `${tableWidth + (layout === 'header' ? scrollbarWidth : 0)}px` : '';\n          }\n        });\n      });\n      this.$nextTick(this.updateStyle);\n    }\n  },\n\n  updateScrollYData() {\n    this.handleTableData();\n    this.updateScrollYSpace();\n  },\n\n  // 更新纵向 Y 可视渲染上下剩余空间大小\n  updateScrollYSpace() {\n    const elemStore = this.elemStore,\n          scrollYStore = this.scrollYStore,\n          scrollYLoad = this.scrollYLoad,\n          afterFullData = this.afterFullData;\n    const startIndex = scrollYStore.startIndex,\n          rowHeight = scrollYStore.rowHeight;\n    const bodyHeight = afterFullData.length * rowHeight;\n    const topSpaceHeight = Math.max(0, startIndex * rowHeight);\n    const containerList = ['main', 'left', 'right'];\n    let marginTop = '';\n    let ySpaceHeight = '';\n\n    if (scrollYLoad) {\n      marginTop = `${topSpaceHeight}px`;\n      ySpaceHeight = `${bodyHeight}px`;\n    }\n\n    containerList.forEach(name => {\n      const layoutList = ['header', 'body', 'footer'];\n      const tableElem = elemStore[`${name}-body-table`];\n\n      if (tableElem) {\n        tableElem.style.marginTop = marginTop;\n      }\n\n      layoutList.forEach(layout => {\n        const ySpaceElem = elemStore[`${name}-${layout}-ySpace`];\n\n        if (ySpaceElem) {\n          ySpaceElem.style.height = ySpaceHeight;\n        }\n      });\n    });\n    this.$nextTick(this.updateStyle);\n  },\n\n  /**\r\n   * 如果有滚动条，则滚动到对应的位置\r\n   * @param {Number} scrollLeft 左距离\r\n   * @param {Number} scrollTop 上距离\r\n   */\n  scrollTo(scrollLeft, scrollTop) {\n    const $refs = this.$refs;\n    const tableBody = $refs.tableBody,\n          rightBody = $refs.rightBody,\n          tableFooter = $refs.tableFooter;\n    const tableBodyElem = tableBody ? tableBody.$el : null;\n    const rightBodyElem = rightBody ? rightBody.$el : null;\n    const tableFooterElem = tableFooter ? tableFooter.$el : null;\n\n    if (XEUtils.isNumber(scrollLeft)) {\n      setScrollLeft(tableFooterElem || tableBodyElem, scrollLeft);\n    }\n\n    if (XEUtils.isNumber(scrollTop)) {\n      setScrollTop(rightBodyElem || tableBodyElem, scrollTop);\n    }\n\n    if (this.scrollXLoad || this.scrollYLoad) {\n      return new Promise(resolve => setTimeout(() => resolve(this.$nextTick()), 50));\n    }\n\n    return this.$nextTick();\n  },\n\n  /**\r\n   * 如果有滚动条，则滚动到对应的行\r\n   * @param {Row} row 行对象\r\n   * @param {ColumnInfo} column 列配置\r\n   */\n  scrollToRow(row, fieldOrColumn) {\n    const rest = [];\n\n    if (row) {\n      if (this.treeConfig) {\n        rest.push(this.scrollToTreeRow(row));\n      } else {\n        rest.push(DomTools.rowToVisible(this, row));\n      }\n    }\n\n    if (fieldOrColumn) {\n      rest.push(this.scrollToColumn(fieldOrColumn));\n    }\n\n    return Promise.all(rest);\n  },\n\n  /**\r\n   * 如果有滚动条，则滚动到对应的列\r\n   * @param {ColumnInfo} column 列配置\r\n   */\n  scrollToColumn(fieldOrColumn) {\n    const column = handleFieldOrColumn(this, fieldOrColumn);\n\n    if (column && this.fullColumnMap.has(column)) {\n      return DomTools.colToVisible(this, column);\n    }\n\n    return this.$nextTick();\n  },\n\n  /**\r\n   * 对于树形结构中，可以直接滚动到指定深层节点中\r\n   * 对于某些特定的场景可能会用到，比如定位到某一节点\r\n   * @param {Row} row 行对象\r\n   */\n  scrollToTreeRow(row) {\n    const tableFullData = this.tableFullData,\n          treeConfig = this.treeConfig,\n          treeOpts = this.treeOpts;\n\n    if (treeConfig) {\n      const matchObj = XEUtils.findTree(tableFullData, item => item === row, treeOpts);\n\n      if (matchObj) {\n        const nodes = matchObj.nodes;\n        nodes.forEach((row, index) => {\n          if (index < nodes.length - 1 && !this.isTreeExpandByRow(row)) {\n            this.setTreeExpand(row, true);\n          }\n        });\n      }\n    }\n\n    return this.$nextTick();\n  },\n\n  /**\r\n   * 手动清除滚动相关信息，还原到初始状态\r\n   */\n  clearScroll() {\n    const $refs = this.$refs;\n    const tableBody = $refs.tableBody,\n          rightBody = $refs.rightBody,\n          tableFooter = $refs.tableFooter;\n    const tableBodyElem = tableBody ? tableBody.$el : null;\n    const rightBodyElem = rightBody ? rightBody.$el : null;\n    const tableFooterElem = tableFooter ? tableFooter.$el : null;\n\n    if (rightBodyElem) {\n      rightBodyElem.scrollTop = 0;\n    }\n\n    if (tableFooterElem) {\n      tableFooterElem.scrollLeft = 0;\n    }\n\n    if (tableBodyElem) {\n      tableBodyElem.scrollTop = 0;\n      tableBodyElem.scrollLeft = 0;\n    }\n\n    return this.$nextTick();\n  },\n\n  /**\r\n   * 更新表尾合计\r\n   */\n  updateFooter() {\n    const showFooter = this.showFooter,\n          visibleColumn = this.visibleColumn,\n          footerMethod = this.footerMethod;\n\n    if (showFooter && footerMethod) {\n      this.footerTableData = visibleColumn.length ? footerMethod({\n        columns: visibleColumn,\n        data: this.afterFullData,\n        $table: this,\n        $grid: this.$xegrid\n      }) : [];\n    }\n\n    return this.$nextTick();\n  },\n\n  /**\r\n   * 更新列状态\r\n   * 如果组件值 v-model 发生 change 时，调用改函数用于更新某一列编辑状态\r\n   * 如果单元格配置了校验规则，则会进行校验\r\n   */\n  updateStatus(scope, cellValue) {\n    const customVal = !XEUtils.isUndefined(cellValue);\n    return this.$nextTick().then(() => {\n      const $refs = this.$refs,\n            editRules = this.editRules,\n            validStore = this.validStore;\n\n      if (scope && $refs.tableBody && editRules) {\n        const row = scope.row,\n              column = scope.column;\n        const type = 'change';\n\n        if (this.hasCellRules(type, row, column)) {\n          const cell = this.getCell(row, column);\n\n          if (cell) {\n            return this.validCellRules(type, row, column, cellValue).then(() => {\n              if (customVal && validStore.visible) {\n                setCellValue(row, column, cellValue);\n              }\n\n              this.clearValidate();\n            }).catch(_ref7 => {\n              let rule = _ref7.rule;\n\n              if (customVal) {\n                setCellValue(row, column, cellValue);\n              }\n\n              this.showValidTooltip({\n                rule,\n                row,\n                column,\n                cell\n              });\n            });\n          }\n        }\n      }\n    });\n  },\n\n  handleDefaultMergeCells() {\n    this.setMergeCells(this.mergeCells);\n  },\n\n  /**\r\n   * 设置合并单元格\r\n   * @param {TableMergeConfig[]} merges { row: Row|number, column: ColumnInfo|number, rowspan: number, colspan: number }\r\n   */\n  setMergeCells(merges) {\n    if (this.spanMethod) {\n      UtilTools.error('vxe.error.errConflicts', ['merge-cells', 'span-method']);\n    }\n\n    setMerges(this, merges, this.mergeList, this.afterFullData);\n    return this.$nextTick().then(() => this.updateCellAreas());\n  },\n\n  /**\r\n   * 移除单元格合并\r\n   * @param {TableMergeConfig[]} merges 多个或数组 [{row:Row|number, col:ColumnInfo|number}]\r\n   */\n  removeMergeCells(merges) {\n    if (this.spanMethod) {\n      UtilTools.error('vxe.error.errConflicts', ['merge-cells', 'span-method']);\n    }\n\n    const rest = removeMerges(this, merges, this.mergeList, this.afterFullData);\n    return this.$nextTick().then(() => {\n      this.updateCellAreas();\n      return rest;\n    });\n  },\n\n  /**\r\n   * 获取所有被合并的单元格\r\n   */\n  getMergeCells() {\n    return this.mergeList.slice(0);\n  },\n\n  /**\r\n   * 清除所有单元格合并\r\n   */\n  clearMergeCells() {\n    this.mergeList = [];\n    return this.$nextTick();\n  },\n\n  handleDefaultMergeFooterItems() {\n    this.setMergeFooterItems(this.mergeFooterItems);\n  },\n\n  setMergeFooterItems(merges) {\n    if (this.footerSpanMethod) {\n      UtilTools.error('vxe.error.errConflicts', ['merge-footer-items', 'footer-span-method']);\n    }\n\n    setMerges(this, merges, this.mergeFooterList, null);\n    return this.$nextTick().then(() => this.updateCellAreas());\n  },\n\n  removeMergeFooterItems(merges) {\n    if (this.footerSpanMethod) {\n      UtilTools.error('vxe.error.errConflicts', ['merge-footer-items', 'footer-span-method']);\n    }\n\n    const rest = removeMerges(this, merges, this.mergeFooterList, null);\n    return this.$nextTick().then(() => {\n      this.updateCellAreas();\n      return rest;\n    });\n  },\n\n  /**\r\n   * 获取所有被合并的表尾\r\n   */\n  getMergeFooterItems() {\n    return this.mergeFooterList.slice(0);\n  },\n\n  /**\r\n   * 清除所有表尾合并\r\n   */\n  clearMergeFooterItems() {\n    this.mergeFooterList = [];\n    return this.$nextTick();\n  },\n\n  updateZindex() {\n    if (this.zIndex) {\n      this.tZindex = this.zIndex;\n    } else if (this.tZindex < UtilTools.getLastZIndex()) {\n      this.tZindex = UtilTools.nextZIndex();\n    }\n  },\n\n  updateCellAreas() {\n    if (this.mouseConfig && this.mouseOpts.area && this.handleUpdateCellAreas) {\n      this.handleUpdateCellAreas();\n    }\n  },\n\n  emitEvent(type, params, evnt) {\n    this.$emit(type, Object.assign({\n      $table: this,\n      $grid: this.$xegrid,\n      $event: evnt\n    }, params));\n  },\n\n  focus() {\n    this.isActivated = true;\n    return this.$nextTick();\n  },\n\n  blur() {\n    this.isActivated = false;\n    return this.$nextTick();\n  },\n\n  // 连接工具栏\n  connect($toolbar) {\n    if ($toolbar && $toolbar.syncUpdate) {\n      $toolbar.syncUpdate({\n        collectColumn: this.collectColumn,\n        $table: this\n      });\n      this.$toolbar = $toolbar;\n    } else {\n      UtilTools.error('vxe.error.barUnableLink');\n    }\n\n    return this.$nextTick();\n  },\n\n  /*************************\r\n   * Publish methods\r\n   *************************/\n  getCell(row, column) {\n    const $refs = this.$refs;\n    const rowid = getRowid(this, row);\n    const bodyElem = $refs[`${column.fixed || 'table'}Body`] || $refs.tableBody;\n\n    if (bodyElem && bodyElem.$el) {\n      return bodyElem.$el.querySelector(`.vxe-body--row[rowid=\"${rowid}\"] .${column.id}`);\n    }\n\n    return null;\n  },\n\n  getCellLabel(row, column) {\n    const formatter = column.formatter;\n    const cellValue = UtilTools.getCellValue(row, column);\n    let cellLabel = cellValue;\n\n    if (formatter) {\n      let rest, formatData;\n      const fullAllDataRowMap = this.fullAllDataRowMap;\n      const colid = column.id;\n      const cacheFormat = fullAllDataRowMap.has(row);\n\n      if (cacheFormat) {\n        rest = fullAllDataRowMap.get(row);\n        formatData = rest.formatData;\n\n        if (!formatData) {\n          formatData = fullAllDataRowMap.get(row).formatData = {};\n        }\n\n        if (rest && formatData[colid]) {\n          if (formatData[colid].value === cellValue) {\n            return formatData[colid].label;\n          }\n        }\n      }\n\n      const formatParams = {\n        cellValue,\n        row,\n        rowIndex: this.getRowIndex(row),\n        column,\n        columnIndex: this.getColumnIndex(column)\n      };\n\n      if (XEUtils.isString(formatter)) {\n        const globalFunc = formats.get(formatter);\n        cellLabel = globalFunc ? globalFunc(formatParams) : '';\n      } else if (XEUtils.isArray(formatter)) {\n        const globalFunc = formats.get(formatter[0]);\n        cellLabel = globalFunc ? globalFunc(formatParams, ...formatter.slice(1)) : '';\n      } else {\n        cellLabel = formatter(formatParams);\n      }\n\n      if (formatData) {\n        formatData[colid] = {\n          value: cellValue,\n          label: cellLabel\n        };\n      }\n    }\n\n    return cellLabel;\n  }\n  /*************************\r\n   * Publish methods\r\n   *************************/\n\n\n}; // Module methods\n\nconst funcs = 'setFilter,clearFilter,getCheckedFilters,closeMenu,setActiveCellArea,getActiveCellArea,getCellAreas,clearCellAreas,copyCellArea,cutCellArea,pasteCellArea,getCopyCellArea,clearCopyCellArea,setCellAreas,openFind,openReplace,getSelectedCell,clearSelected,insert,insertAt,remove,removeCheckboxRow,removeRadioRow,removeCurrentRow,getRecordset,getInsertRecords,getRemoveRecords,getUpdateRecords,clearActived,getActiveRecord,isActiveByRow,setActiveRow,setActiveCell,setSelectCell,clearValidate,fullValidate,validate,openExport,openPrint,exportData,openImport,importData,saveFile,readFile,importByFile,print'.split(',');\nfuncs.forEach(name => {\n  Methods[name] = function () {\n    return this[`_${name}`] ? this[`_${name}`](...arguments) : null;\n  };\n});\nexport default Methods;",null]}