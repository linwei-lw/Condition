{"remainingRequest":"D:\\cdRule\\node_modules\\thread-loader\\dist\\cjs.js!D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js!D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js!D:\\cdRule\\src\\components\\Table\\table\\src\\util.js","dependencies":[{"path":"D:\\cdRule\\src\\components\\Table\\table\\src\\util.js","mtime":1635230121673},{"path":"D:\\cdRule\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\thread-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import VXETable from '../../v-x-e-table';\nimport XEUtils from 'xe-utils';\nimport { DomTools } from '../../tools';\nconst lineOffsetSizes = {\n  mini: 3,\n  small: 2,\n  medium: 1\n};\n\nfunction getPaddingLeftRightSize(elem) {\n  if (elem) {\n    const computedStyle = getComputedStyle(elem);\n    const paddingLeft = XEUtils.toNumber(computedStyle.paddingLeft);\n    const paddingRight = XEUtils.toNumber(computedStyle.paddingRight);\n    return paddingLeft + paddingRight;\n  }\n\n  return 0;\n}\n\nfunction getElemenMarginWidth(elem) {\n  if (elem) {\n    const computedStyle = getComputedStyle(elem);\n    const marginLeft = XEUtils.toNumber(computedStyle.marginLeft);\n    const marginRight = XEUtils.toNumber(computedStyle.marginRight);\n    return elem.offsetWidth + marginLeft + marginRight;\n  }\n\n  return 0;\n}\n\nexport function handleFieldOrColumn(_vm, fieldOrColumn) {\n  if (fieldOrColumn) {\n    return XEUtils.isString(fieldOrColumn) ? _vm.getColumnByField(fieldOrColumn) : fieldOrColumn;\n  }\n\n  return null;\n}\n\nfunction queryCellElement(cell, selector) {\n  return cell.querySelector('.vxe-cell' + selector);\n}\n\nexport function getColMinWidth(params) {\n  const $table = params.$table,\n        column = params.column,\n        cell = params.cell;\n  const allColumnHeaderOverflow = $table.showHeaderOverflow,\n        resizableOpts = $table.resizableOpts;\n  const minWidth = resizableOpts.minWidth; // 如果自定义调整宽度逻辑\n\n  if (minWidth) {\n    const customMinWidth = XEUtils.isFunction(minWidth) ? minWidth(params) : minWidth;\n\n    if (customMinWidth !== 'auto') {\n      return Math.max(1, XEUtils.toNumber(customMinWidth));\n    }\n  }\n\n  const showHeaderOverflow = column.showHeaderOverflow,\n        colMinWidth = column.minWidth;\n  const headOverflow = XEUtils.isUndefined(showHeaderOverflow) || XEUtils.isNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;\n  const showEllipsis = headOverflow === 'ellipsis';\n  const showTitle = headOverflow === 'title';\n  const showTooltip = headOverflow === true || headOverflow === 'tooltip';\n  const hasEllipsis = showTitle || showTooltip || showEllipsis;\n  const minTitleWidth = XEUtils.floor((XEUtils.toNumber(getComputedStyle(cell).fontSize) || 14) * 1.6);\n  const paddingLeftRight = getPaddingLeftRightSize(cell) + getPaddingLeftRightSize(queryCellElement(cell, ''));\n  let mWidth = minTitleWidth + paddingLeftRight; // 默认最小宽处理\n\n  if (hasEllipsis) {\n    const checkboxIconWidth = getPaddingLeftRightSize(queryCellElement(cell, '--title>.vxe-cell--checkbox'));\n    const requiredIconWidth = getElemenMarginWidth(queryCellElement(cell, '>.vxe-cell--required-icon'));\n    const editIconWidth = getElemenMarginWidth(queryCellElement(cell, '>.vxe-cell--edit-icon'));\n    const helpIconWidth = getElemenMarginWidth(queryCellElement(cell, '>.vxe-cell-help-icon'));\n    const sortIconWidth = getElemenMarginWidth(queryCellElement(cell, '>.vxe-cell--sort'));\n    const filterIconWidth = getElemenMarginWidth(queryCellElement(cell, '>.vxe-cell--filter'));\n    mWidth += checkboxIconWidth + requiredIconWidth + editIconWidth + helpIconWidth + filterIconWidth + sortIconWidth;\n  } // 如果设置最小宽\n\n\n  if (colMinWidth) {\n    const tableBody = $table.$refs.tableBody;\n    const bodyElem = tableBody ? tableBody.$el : null;\n\n    if (bodyElem) {\n      if (DomTools.isScale(colMinWidth)) {\n        const bodyWidth = bodyElem.clientWidth - 1;\n        const meanWidth = bodyWidth / 100;\n        return Math.max(mWidth, Math.floor(XEUtils.toInteger(colMinWidth) * meanWidth));\n      } else if (DomTools.isPx(colMinWidth)) {\n        return Math.max(mWidth, XEUtils.toInteger(colMinWidth));\n      }\n    }\n  }\n\n  return mWidth;\n}\n\nfunction countTreeExpand(prevRow, params) {\n  const $table = params.$table;\n  const rowChildren = prevRow[$table.treeOpts.children];\n  let count = 1;\n\n  if ($table.isTreeExpandByRow(prevRow)) {\n    for (let index = 0; index < rowChildren.length; index++) {\n      count += countTreeExpand(rowChildren[index], params);\n    }\n  }\n\n  return count;\n}\n\nexport function getOffsetSize($xetable) {\n  return lineOffsetSizes[$xetable.vSize] || 0;\n}\nexport function calcTreeLine(params, items) {\n  const $table = params.$table,\n        $rowIndex = params.$rowIndex;\n  let expandSize = 1;\n\n  if ($rowIndex) {\n    expandSize = countTreeExpand(items[$rowIndex - 1], params);\n  }\n\n  return $table.rowHeight * expandSize - ($rowIndex ? 1 : 12 - getOffsetSize($table));\n}\nexport function mergeBodyMethod(mergeList, _rowIndex, _columnIndex) {\n  for (let mIndex = 0; mIndex < mergeList.length; mIndex++) {\n    const _mergeList$mIndex = mergeList[mIndex],\n          mergeRowIndex = _mergeList$mIndex.row,\n          mergeColIndex = _mergeList$mIndex.col,\n          mergeRowspan = _mergeList$mIndex.rowspan,\n          mergeColspan = _mergeList$mIndex.colspan;\n\n    if (mergeColIndex > -1 && mergeRowIndex > -1 && mergeRowspan && mergeColspan) {\n      if (mergeRowIndex === _rowIndex && mergeColIndex === _columnIndex) {\n        return {\n          rowspan: mergeRowspan,\n          colspan: mergeColspan\n        };\n      }\n\n      if (_rowIndex >= mergeRowIndex && _rowIndex < mergeRowIndex + mergeRowspan && _columnIndex >= mergeColIndex && _columnIndex < mergeColIndex + mergeColspan) {\n        return {\n          rowspan: 0,\n          colspan: 0\n        };\n      }\n    }\n  }\n}\nexport function clearTableDefaultStatus(_vm) {\n  _vm.initStatus = false;\n\n  _vm.clearSort();\n\n  _vm.clearCurrentRow();\n\n  _vm.clearCurrentColumn();\n\n  _vm.clearRadioRow();\n\n  _vm.clearRadioReserve();\n\n  _vm.clearCheckboxRow();\n\n  _vm.clearCheckboxReserve();\n\n  _vm.clearRowExpand();\n\n  _vm.clearTreeExpand();\n\n  _vm.clearTreeExpandReserve();\n\n  if (_vm.clearActived && VXETable._edit) {\n    _vm.clearActived();\n  }\n\n  if (_vm.clearSelected && (_vm.keyboardConfig || _vm.mouseConfig)) {\n    _vm.clearSelected();\n  }\n\n  if (_vm.clearCellAreas && _vm.mouseConfig) {\n    _vm.clearCellAreas();\n\n    _vm.clearCopyCellArea();\n  }\n\n  return _vm.clearScroll();\n}\nexport function clearTableAllStatus(_vm) {\n  if (_vm.clearFilter && VXETable._filter) {\n    _vm.clearFilter();\n  }\n\n  return clearTableDefaultStatus(_vm);\n}",null]}