{"remainingRequest":"D:\\cdRule\\node_modules\\thread-loader\\dist\\cjs.js!D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js!D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js!D:\\cdRule\\src\\components\\Table\\modal\\src\\modal.js","dependencies":[{"path":"D:\\cdRule\\src\\components\\Table\\modal\\src\\modal.js","mtime":1635230121053},{"path":"D:\\cdRule\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\thread-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.regexp.split\";\nimport \"core-js/modules/es6.regexp.replace\";\nimport \"core-js/modules/es6.regexp.split\";\nimport _slicedToArray from \"D:\\\\cdRule\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport \"core-js/modules/es6.regexp.replace\";\nimport GlobalConfig from '../../v-x-e-table/src/conf';\nimport vSize from '../../mixins/size';\nimport XEUtils from 'xe-utils';\nimport { UtilTools, DomTools, GlobalEvent } from '../../tools';\nexport const allActivedModals = [];\nexport const msgQueue = [];\nexport default {\n  name: 'VxeModal',\n  mixins: [vSize],\n  props: {\n    value: Boolean,\n    id: String,\n    type: {\n      type: String,\n      default: 'modal'\n    },\n    loading: {\n      type: Boolean,\n      default: null\n    },\n    status: String,\n    iconStatus: String,\n    className: String,\n    top: {\n      type: [Number, String],\n      default: () => GlobalConfig.modal.top\n    },\n    position: [String, Object],\n    title: String,\n    duration: {\n      type: [Number, String],\n      default: () => GlobalConfig.modal.duration\n    },\n    // 请使用 content\n    message: [String, Function],\n    content: [String, Function],\n    cancelButtonText: {\n      type: String,\n      default: () => GlobalConfig.modal.cancelButtonText\n    },\n    confirmButtonText: {\n      type: String,\n      default: () => GlobalConfig.modal.confirmButtonText\n    },\n    lockView: {\n      type: Boolean,\n      default: () => GlobalConfig.modal.lockView\n    },\n    lockScroll: Boolean,\n    mask: {\n      type: Boolean,\n      default: () => GlobalConfig.modal.mask\n    },\n    maskClosable: {\n      type: Boolean,\n      default: () => GlobalConfig.modal.maskClosable\n    },\n    escClosable: {\n      type: Boolean,\n      default: () => GlobalConfig.modal.escClosable\n    },\n    resize: {\n      type: Boolean,\n      default: () => GlobalConfig.modal.resize\n    },\n    showHeader: {\n      type: Boolean,\n      default: () => GlobalConfig.modal.showHeader\n    },\n    showFooter: {\n      type: Boolean,\n      default: () => GlobalConfig.modal.showFooter\n    },\n    showZoom: {\n      type: Boolean,\n      default: null\n    },\n    showClose: {\n      type: Boolean,\n      default: () => GlobalConfig.modal.showClose\n    },\n    dblclickZoom: {\n      type: Boolean,\n      default: () => GlobalConfig.modal.dblclickZoom\n    },\n    width: [Number, String],\n    height: [Number, String],\n    minWidth: {\n      type: [Number, String],\n      default: () => GlobalConfig.modal.minWidth\n    },\n    minHeight: {\n      type: [Number, String],\n      default: () => GlobalConfig.modal.minHeight\n    },\n    zIndex: Number,\n    marginSize: {\n      type: [Number, String],\n      default: GlobalConfig.modal.marginSize\n    },\n    fullscreen: Boolean,\n    remember: {\n      type: Boolean,\n      default: () => GlobalConfig.modal.remember\n    },\n    destroyOnClose: {\n      type: Boolean,\n      default: () => GlobalConfig.modal.destroyOnClose\n    },\n    showTitleOverflow: {\n      type: Boolean,\n      default: () => GlobalConfig.modal.showTitleOverflow\n    },\n    transfer: {\n      type: Boolean,\n      default: () => GlobalConfig.modal.transfer\n    },\n    storage: {\n      type: Boolean,\n      default: () => GlobalConfig.modal.storage\n    },\n    storageKey: {\n      type: String,\n      default: () => GlobalConfig.modal.storageKey\n    },\n    animat: {\n      type: Boolean,\n      default: () => GlobalConfig.modal.animat\n    },\n    size: {\n      type: String,\n      default: () => GlobalConfig.modal.size || GlobalConfig.size\n    },\n    beforeHideMethod: {\n      type: Function,\n      default: () => GlobalConfig.modal.beforeHideMethod\n    },\n    slots: Object,\n    events: Object\n  },\n\n  data() {\n    return {\n      inited: false,\n      visible: false,\n      contentVisible: false,\n      modalTop: 0,\n      modalZindex: 0,\n      zoomLocat: null,\n      firstOpen: false\n    };\n  },\n\n  computed: {\n    isMsg() {\n      return this.type === 'message';\n    }\n\n  },\n  watch: {\n    width() {\n      this.recalculate();\n    },\n\n    height() {\n      this.recalculate();\n    },\n\n    value(visible) {\n      this[visible ? 'open' : 'close']('model');\n    }\n\n  },\n\n  created() {\n    if (this.storage && !this.id) {\n      UtilTools.error('vxe.error.reqProp', ['modal.id']);\n    }\n  },\n\n  mounted() {\n    const $listeners = this.$listeners,\n          _this$events = this.events,\n          events = _this$events === void 0 ? {} : _this$events;\n\n    if (this.value) {\n      this.open();\n    }\n\n    this.recalculate();\n\n    if (this.escClosable) {\n      GlobalEvent.on(this, 'keydown', this.handleGlobalKeydownEvent);\n    } // 触发 inserted 事件\n\n\n    const type = 'inserted';\n    const params = {\n      type,\n      $modal: this,\n      $event: {\n        type\n      }\n    };\n\n    if ($listeners.inserted) {\n      this.$emit('inserted', params);\n    } else if (events.inserted) {\n      events.inserted.call(this, params);\n    }\n  },\n\n  beforeDestroy() {\n    const $el = this.$el;\n    GlobalEvent.off(this, 'keydown');\n    this.removeMsgQueue();\n\n    if ($el.parentNode === document.body) {\n      $el.parentNode.removeChild($el);\n    }\n  },\n\n  render(h) {\n    const _e = this._e,\n          $scopedSlots = this.$scopedSlots,\n          _this$slots = this.slots,\n          slots = _this$slots === void 0 ? {} : _this$slots,\n          inited = this.inited,\n          vSize = this.vSize,\n          className = this.className,\n          type = this.type,\n          resize = this.resize,\n          showClose = this.showClose,\n          showZoom = this.showZoom,\n          animat = this.animat,\n          loading = this.loading,\n          status = this.status,\n          iconStatus = this.iconStatus,\n          showFooter = this.showFooter,\n          zoomLocat = this.zoomLocat,\n          modalTop = this.modalTop,\n          dblclickZoom = this.dblclickZoom,\n          contentVisible = this.contentVisible,\n          visible = this.visible,\n          title = this.title,\n          lockScroll = this.lockScroll,\n          lockView = this.lockView,\n          mask = this.mask,\n          isMsg = this.isMsg,\n          showTitleOverflow = this.showTitleOverflow,\n          destroyOnClose = this.destroyOnClose;\n    const content = this.content || this.message;\n    const defaultSlot = $scopedSlots.default || slots.default;\n    const footerSlot = $scopedSlots.footer || slots.footer;\n    const headerSlot = $scopedSlots.header || slots.header;\n    const titleSlot = $scopedSlots.title || slots.title;\n    const headerOns = {\n      mousedown: this.mousedownEvent\n    };\n\n    if (showZoom && dblclickZoom && type === 'modal') {\n      headerOns.dblclick = this.toggleZoomEvent;\n    }\n\n    return h('div', {\n      class: ['vxe-modal--wrapper', `type--${type}`, className || '', {\n        [`size--${vSize}`]: vSize,\n        [`status--${status}`]: status,\n        'is--animat': animat,\n        'lock--scroll': lockScroll,\n        'lock--view': lockView,\n        'is--resize': resize,\n        'is--mask': mask,\n        'is--maximize': zoomLocat,\n        'is--visible': contentVisible,\n        'is--active': visible,\n        'is--loading': loading\n      }],\n      style: {\n        zIndex: this.modalZindex,\n        top: modalTop ? `${modalTop}px` : null\n      },\n      on: {\n        click: this.selfClickEvent\n      }\n    }, [h('div', {\n      class: 'vxe-modal--box',\n      on: {\n        mousedown: this.boxMousedownEvent\n      },\n      ref: 'modalBox'\n    }, [this.showHeader ? h('div', {\n      class: ['vxe-modal--header', !isMsg && showTitleOverflow ? 'is--ellipsis' : ''],\n      on: headerOns\n    }, headerSlot ? !inited || destroyOnClose && !visible ? [] : headerSlot.call(this, {\n      $modal: this\n    }, h) : [titleSlot ? titleSlot.call(this, {\n      $modal: this\n    }, h) : h('span', {\n      class: 'vxe-modal--title'\n    }, title ? UtilTools.getFuncText(title) : GlobalConfig.i18n('vxe.alert.title')), showZoom ? h('i', {\n      class: ['vxe-modal--zoom-btn', 'trigger--btn', zoomLocat ? GlobalConfig.icon.MODAL_ZOOM_OUT : GlobalConfig.icon.MODAL_ZOOM_IN],\n      attrs: {\n        title: GlobalConfig.i18n(`vxe.modal.zoom${zoomLocat ? 'Out' : 'In'}`)\n      },\n      on: {\n        click: this.toggleZoomEvent\n      }\n    }) : _e(), showClose ? h('i', {\n      class: ['vxe-modal--close-btn', 'trigger--btn', GlobalConfig.icon.MODAL_CLOSE],\n      attrs: {\n        title: GlobalConfig.i18n('vxe.modal.close')\n      },\n      on: {\n        click: this.closeEvent\n      }\n    }) : _e()]) : null, h('div', {\n      class: 'vxe-modal--body'\n    }, [status ? h('div', {\n      class: 'vxe-modal--status-wrapper'\n    }, [h('i', {\n      class: ['vxe-modal--status-icon', iconStatus || GlobalConfig.icon[`MODAL_${status}`.toLocaleUpperCase()]]\n    })]) : null, h('div', {\n      class: 'vxe-modal--content'\n    }, defaultSlot ? !inited || destroyOnClose && !visible ? [] : defaultSlot.call(this, {\n      $modal: this\n    }, h) : UtilTools.getFuncText(content)), !isMsg ? h('div', {\n      class: ['vxe-loading', {\n        'is--visible': loading\n      }]\n    }, [h('div', {\n      class: 'vxe-loading--spinner'\n    })]) : null]), showFooter ? h('div', {\n      class: 'vxe-modal--footer'\n    }, footerSlot ? !inited || destroyOnClose && !visible ? [] : footerSlot.call(this, {\n      $modal: this\n    }, h) : [type === 'confirm' ? h('vxe-button', {\n      ref: 'cancelBtn',\n      on: {\n        click: this.cancelEvent\n      }\n    }, this.cancelButtonText || GlobalConfig.i18n('vxe.button.cancel')) : null, h('vxe-button', {\n      ref: 'confirmBtn',\n      props: {\n        status: 'primary'\n      },\n      on: {\n        click: this.confirmEvent\n      }\n    }, this.confirmButtonText || GlobalConfig.i18n('vxe.button.confirm'))]) : null, !isMsg && resize ? h('span', {\n      class: 'vxe-modal--resize'\n    }, ['wl', 'wr', 'swst', 'sest', 'st', 'swlb', 'selb', 'sb'].map(type => {\n      return h('span', {\n        class: `${type}-resize`,\n        attrs: {\n          type: type\n        },\n        on: {\n          mousedown: this.dragEvent\n        }\n      });\n    })) : null])]);\n  },\n\n  methods: {\n    recalculate() {\n      const width = this.width,\n            height = this.height;\n      const modalBoxElem = this.getBox();\n      modalBoxElem.style.width = width ? isNaN(width) ? width : `${width}px` : null;\n      modalBoxElem.style.height = height ? isNaN(height) ? height : `${height}px` : null;\n      return this.$nextTick();\n    },\n\n    selfClickEvent(evnt) {\n      if (this.maskClosable && evnt.target === this.$el) {\n        const type = 'mask';\n        this.close(type);\n      }\n    },\n\n    updateZindex() {\n      const zIndex = this.zIndex,\n            modalZindex = this.modalZindex;\n\n      if (zIndex) {\n        this.modalZindex = zIndex;\n      } else if (modalZindex < UtilTools.getLastZIndex()) {\n        this.modalZindex = UtilTools.nextZIndex();\n      }\n    },\n\n    closeEvent(evnt) {\n      const type = 'close';\n      this.$emit(type, {\n        type,\n        $modal: this,\n        $event: evnt\n      });\n      this.close(type);\n    },\n\n    confirmEvent(evnt) {\n      const type = 'confirm';\n      this.$emit(type, {\n        type,\n        $modal: this,\n        $event: evnt\n      });\n      this.close(type);\n    },\n\n    cancelEvent(evnt) {\n      const type = 'cancel';\n      this.$emit(type, {\n        type,\n        $modal: this,\n        $event: evnt\n      });\n      this.close(type);\n    },\n\n    open() {\n      const $refs = this.$refs,\n            _this$events2 = this.events,\n            events = _this$events2 === void 0 ? {} : _this$events2,\n            inited = this.inited,\n            duration = this.duration,\n            visible = this.visible,\n            isMsg = this.isMsg,\n            remember = this.remember,\n            showFooter = this.showFooter;\n\n      if (!inited) {\n        this.inited = true;\n\n        if (this.transfer) {\n          document.body.appendChild(this.$el);\n        }\n      }\n\n      if (!visible) {\n        if (!remember) {\n          this.recalculate();\n        }\n\n        this.visible = true;\n        this.contentVisible = false;\n        this.updateZindex();\n        allActivedModals.push(this);\n        setTimeout(() => {\n          this.contentVisible = true;\n          this.$nextTick(() => {\n            if (showFooter) {\n              const operBtn = $refs.confirmBtn || $refs.cancelBtn;\n\n              if (operBtn) {\n                operBtn.focus();\n              }\n            }\n\n            const type = '';\n            const params = {\n              type,\n              $modal: this\n            };\n\n            if (events.show) {\n              events.show.call(this, params);\n            } else {\n              this.$emit('input', true);\n              this.$emit('show', params);\n            }\n          });\n        }, 10);\n\n        if (isMsg) {\n          this.addMsgQueue();\n\n          if (duration !== -1) {\n            setTimeout(() => this.close('close'), XEUtils.toNumber(duration));\n          }\n        } else {\n          this.$nextTick(() => {\n            const firstOpen = this.firstOpen,\n                  fullscreen = this.fullscreen;\n\n            if (!remember || !firstOpen) {\n              this.updatePosition().then(() => {\n                setTimeout(() => this.updatePosition(), 20);\n              });\n            }\n\n            if (!firstOpen) {\n              this.firstOpen = true;\n\n              if (this.hasPosStorage()) {\n                this.restorePosStorage();\n              } else if (fullscreen) {\n                this.$nextTick(() => this.maximize());\n              }\n            }\n          });\n        }\n      }\n    },\n\n    addMsgQueue() {\n      if (msgQueue.indexOf(this) === -1) {\n        msgQueue.push(this);\n      }\n\n      this.updateStyle();\n    },\n\n    removeMsgQueue() {\n      if (msgQueue.indexOf(this) > -1) {\n        XEUtils.remove(msgQueue, comp => comp === this);\n      }\n\n      this.updateStyle();\n    },\n\n    updateStyle() {\n      this.$nextTick(() => {\n        let offsetTop = 0;\n        msgQueue.forEach(comp => {\n          offsetTop += XEUtils.toNumber(comp.top);\n          comp.modalTop = offsetTop;\n          offsetTop += comp.$refs.modalBox.clientHeight;\n        });\n      });\n    },\n\n    updatePosition() {\n      return this.$nextTick().then(() => {\n        const marginSize = this.marginSize,\n              position = this.position;\n        const modalBoxElem = this.getBox();\n        const clientVisibleWidth = document.documentElement.clientWidth || document.body.clientWidth;\n        const clientVisibleHeight = document.documentElement.clientHeight || document.body.clientHeight;\n        const isPosCenter = position === 'center';\n\n        const _ref = isPosCenter ? {\n          top: position,\n          left: position\n        } : Object.assign({}, position),\n              top = _ref.top,\n              left = _ref.left;\n\n        const topCenter = isPosCenter || top === 'center';\n        const leftCenter = isPosCenter || left === 'center';\n        let posTop = '';\n        let posLeft = '';\n\n        if (left && !leftCenter) {\n          posLeft = isNaN(left) ? left : `${left}px`;\n        } else {\n          posLeft = `${Math.max(marginSize, clientVisibleWidth / 2 - modalBoxElem.offsetWidth / 2)}px`;\n        }\n\n        if (top && !topCenter) {\n          posTop = isNaN(top) ? top : `${top}px`;\n        } else {\n          posTop = `${Math.max(marginSize, clientVisibleHeight / 2 - modalBoxElem.offsetHeight / 2)}px`;\n        }\n\n        modalBoxElem.style.top = posTop;\n        modalBoxElem.style.left = posLeft;\n      });\n    },\n\n    close(type) {\n      const _this$events3 = this.events,\n            events = _this$events3 === void 0 ? {} : _this$events3,\n            remember = this.remember,\n            visible = this.visible,\n            isMsg = this.isMsg,\n            beforeHideMethod = this.beforeHideMethod;\n      const params = {\n        type,\n        $modal: this\n      };\n\n      if (visible) {\n        Promise.resolve(beforeHideMethod ? beforeHideMethod(params) : null).then(rest => {\n          if (!XEUtils.isError(rest)) {\n            if (isMsg) {\n              this.removeMsgQueue();\n            }\n\n            this.contentVisible = false;\n\n            if (!remember) {\n              this.zoomLocat = null;\n            }\n\n            XEUtils.remove(allActivedModals, item => item === this);\n            this.$emit('before-hide', params);\n            setTimeout(() => {\n              this.visible = false;\n\n              if (events.hide) {\n                events.hide.call(this, params);\n              } else {\n                this.$emit('input', false);\n                this.$emit('hide', params);\n              }\n            }, 200);\n          }\n        }).catch(e => e);\n      }\n    },\n\n    handleGlobalKeydownEvent(evnt) {\n      const isEsc = evnt.keyCode === 27;\n\n      if (isEsc) {\n        const lastModal = XEUtils.max(allActivedModals, item => item.modalZindex); // 多个时，只关掉最上层的窗口\n\n        if (lastModal) {\n          setTimeout(() => {\n            if (lastModal === this && lastModal.escClosable) {\n              this.close('exit');\n            }\n          }, 10);\n        }\n      }\n    },\n\n    getBox() {\n      return this.$refs.modalBox;\n    },\n\n    isMaximized() {\n      return !!this.zoomLocat;\n    },\n\n    maximize() {\n      return this.$nextTick().then(() => {\n        if (!this.zoomLocat) {\n          const marginSize = this.marginSize;\n          const modalBoxElem = this.getBox();\n\n          const _DomTools$getDomNode = DomTools.getDomNode(),\n                visibleHeight = _DomTools$getDomNode.visibleHeight,\n                visibleWidth = _DomTools$getDomNode.visibleWidth;\n\n          this.zoomLocat = {\n            top: modalBoxElem.offsetTop,\n            left: modalBoxElem.offsetLeft,\n            width: modalBoxElem.offsetWidth + (modalBoxElem.style.width ? 0 : 1),\n            height: modalBoxElem.offsetHeight + (modalBoxElem.style.height ? 0 : 1)\n          };\n          Object.assign(modalBoxElem.style, {\n            top: `${marginSize}px`,\n            left: `${marginSize}px`,\n            width: `${visibleWidth - marginSize * 2}px`,\n            height: `${visibleHeight - marginSize * 2}px`\n          });\n          this.savePosStorage();\n        }\n      });\n    },\n\n    revert() {\n      return this.$nextTick().then(() => {\n        const zoomLocat = this.zoomLocat;\n\n        if (zoomLocat) {\n          const modalBoxElem = this.getBox();\n          this.zoomLocat = null;\n          Object.assign(modalBoxElem.style, {\n            top: `${zoomLocat.top}px`,\n            left: `${zoomLocat.left}px`,\n            width: `${zoomLocat.width}px`,\n            height: `${zoomLocat.height}px`\n          });\n          this.savePosStorage();\n        }\n      });\n    },\n\n    zoom() {\n      return this[this.zoomLocat ? 'revert' : 'maximize']().then(() => this.isMaximized());\n    },\n\n    toggleZoomEvent(evnt) {\n      const $listeners = this.$listeners,\n            zoomLocat = this.zoomLocat,\n            _this$events4 = this.events,\n            events = _this$events4 === void 0 ? {} : _this$events4;\n      const params = {\n        type: zoomLocat ? 'revert' : 'max',\n        $modal: this,\n        $event: evnt\n      };\n      return this.zoom().then(() => {\n        if ($listeners.zoom) {\n          this.$emit('zoom', params);\n        } else if (events.zoom) {\n          events.zoom.call(this, params);\n        }\n      });\n    },\n\n    getPosition() {\n      if (!this.isMsg) {\n        const modalBoxElem = this.getBox();\n\n        if (modalBoxElem) {\n          return {\n            top: modalBoxElem.offsetTop,\n            left: modalBoxElem.offsetLeft\n          };\n        }\n      }\n\n      return null;\n    },\n\n    setPosition(top, left) {\n      if (!this.isMsg) {\n        const modalBoxElem = this.getBox();\n\n        if (XEUtils.isNumber(top)) {\n          modalBoxElem.style.top = `${top}px`;\n        }\n\n        if (XEUtils.isNumber(left)) {\n          modalBoxElem.style.left = `${left}px`;\n        }\n      }\n\n      return this.$nextTick();\n    },\n\n    boxMousedownEvent() {\n      const modalZindex = this.modalZindex;\n\n      if (allActivedModals.some(_vm => _vm.visible && _vm.modalZindex > modalZindex)) {\n        this.updateZindex();\n      }\n    },\n\n    mousedownEvent(evnt) {\n      const remember = this.remember,\n            storage = this.storage,\n            marginSize = this.marginSize,\n            zoomLocat = this.zoomLocat;\n      const modalBoxElem = this.getBox();\n\n      if (!zoomLocat && evnt.button === 0 && !DomTools.getEventTargetNode(evnt, modalBoxElem, 'trigger--btn').flag) {\n        evnt.preventDefault();\n        const domMousemove = document.onmousemove;\n        const domMouseup = document.onmouseup;\n        const disX = evnt.clientX - modalBoxElem.offsetLeft;\n        const disY = evnt.clientY - modalBoxElem.offsetTop;\n\n        const _DomTools$getDomNode2 = DomTools.getDomNode(),\n              visibleHeight = _DomTools$getDomNode2.visibleHeight,\n              visibleWidth = _DomTools$getDomNode2.visibleWidth;\n\n        document.onmousemove = evnt => {\n          evnt.preventDefault();\n          const offsetWidth = modalBoxElem.offsetWidth;\n          const offsetHeight = modalBoxElem.offsetHeight;\n          const minX = marginSize;\n          const maxX = visibleWidth - offsetWidth - marginSize - 1;\n          const minY = marginSize;\n          const maxY = visibleHeight - offsetHeight - marginSize - 1;\n          let left = evnt.clientX - disX;\n          let top = evnt.clientY - disY;\n\n          if (left > maxX) {\n            left = maxX;\n          }\n\n          if (left < minX) {\n            left = minX;\n          }\n\n          if (top > maxY) {\n            top = maxY;\n          }\n\n          if (top < minY) {\n            top = minY;\n          }\n\n          modalBoxElem.style.left = `${left}px`;\n          modalBoxElem.style.top = `${top}px`;\n        };\n\n        document.onmouseup = () => {\n          document.onmousemove = domMousemove;\n          document.onmouseup = domMouseup;\n\n          if (remember && storage) {\n            this.$nextTick(() => {\n              this.savePosStorage();\n            });\n          }\n        };\n      }\n    },\n\n    dragEvent(evnt) {\n      evnt.preventDefault();\n      const $listeners = this.$listeners,\n            marginSize = this.marginSize,\n            _this$events5 = this.events,\n            events = _this$events5 === void 0 ? {} : _this$events5,\n            remember = this.remember,\n            storage = this.storage;\n\n      const _DomTools$getDomNode3 = DomTools.getDomNode(),\n            visibleHeight = _DomTools$getDomNode3.visibleHeight,\n            visibleWidth = _DomTools$getDomNode3.visibleWidth;\n\n      const type = evnt.target.getAttribute('type');\n      const minWidth = XEUtils.toNumber(this.minWidth);\n      const minHeight = XEUtils.toNumber(this.minHeight);\n      const maxWidth = visibleWidth;\n      const maxHeight = visibleHeight;\n      const modalBoxElem = this.getBox();\n      const domMousemove = document.onmousemove;\n      const domMouseup = document.onmouseup;\n      const clientWidth = modalBoxElem.clientWidth;\n      const clientHeight = modalBoxElem.clientHeight;\n      const disX = evnt.clientX;\n      const disY = evnt.clientY;\n      const offsetTop = modalBoxElem.offsetTop;\n      const offsetLeft = modalBoxElem.offsetLeft;\n      const params = {\n        type: 'resize',\n        $modal: this\n      };\n\n      document.onmousemove = evnt => {\n        evnt.preventDefault();\n        let dragLeft;\n        let dragTop;\n        let width;\n        let height;\n\n        switch (type) {\n          case 'wl':\n            dragLeft = disX - evnt.clientX;\n            width = dragLeft + clientWidth;\n\n            if (offsetLeft - dragLeft > marginSize) {\n              if (width > minWidth) {\n                modalBoxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;\n                modalBoxElem.style.left = `${offsetLeft - dragLeft}px`;\n              }\n            }\n\n            break;\n\n          case 'swst':\n            dragLeft = disX - evnt.clientX;\n            dragTop = disY - evnt.clientY;\n            width = dragLeft + clientWidth;\n            height = dragTop + clientHeight;\n\n            if (offsetLeft - dragLeft > marginSize) {\n              if (width > minWidth) {\n                modalBoxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;\n                modalBoxElem.style.left = `${offsetLeft - dragLeft}px`;\n              }\n            }\n\n            if (offsetTop - dragTop > marginSize) {\n              if (height > minHeight) {\n                modalBoxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;\n                modalBoxElem.style.top = `${offsetTop - dragTop}px`;\n              }\n            }\n\n            break;\n\n          case 'swlb':\n            dragLeft = disX - evnt.clientX;\n            dragTop = evnt.clientY - disY;\n            width = dragLeft + clientWidth;\n            height = dragTop + clientHeight;\n\n            if (offsetLeft - dragLeft > marginSize) {\n              if (width > minWidth) {\n                modalBoxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;\n                modalBoxElem.style.left = `${offsetLeft - dragLeft}px`;\n              }\n            }\n\n            if (offsetTop + height + marginSize < visibleHeight) {\n              if (height > minHeight) {\n                modalBoxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;\n              }\n            }\n\n            break;\n\n          case 'st':\n            dragTop = disY - evnt.clientY;\n            height = clientHeight + dragTop;\n\n            if (offsetTop - dragTop > marginSize) {\n              if (height > minHeight) {\n                modalBoxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;\n                modalBoxElem.style.top = `${offsetTop - dragTop}px`;\n              }\n            }\n\n            break;\n\n          case 'wr':\n            dragLeft = evnt.clientX - disX;\n            width = dragLeft + clientWidth;\n\n            if (offsetLeft + width + marginSize < visibleWidth) {\n              if (width > minWidth) {\n                modalBoxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;\n              }\n            }\n\n            break;\n\n          case 'sest':\n            dragLeft = evnt.clientX - disX;\n            dragTop = disY - evnt.clientY;\n            width = dragLeft + clientWidth;\n            height = dragTop + clientHeight;\n\n            if (offsetLeft + width + marginSize < visibleWidth) {\n              if (width > minWidth) {\n                modalBoxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;\n              }\n            }\n\n            if (offsetTop - dragTop > marginSize) {\n              if (height > minHeight) {\n                modalBoxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;\n                modalBoxElem.style.top = `${offsetTop - dragTop}px`;\n              }\n            }\n\n            break;\n\n          case 'selb':\n            dragLeft = evnt.clientX - disX;\n            dragTop = evnt.clientY - disY;\n            width = dragLeft + clientWidth;\n            height = dragTop + clientHeight;\n\n            if (offsetLeft + width + marginSize < visibleWidth) {\n              if (width > minWidth) {\n                modalBoxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;\n              }\n            }\n\n            if (offsetTop + height + marginSize < visibleHeight) {\n              if (height > minHeight) {\n                modalBoxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;\n              }\n            }\n\n            break;\n\n          case 'sb':\n            dragTop = evnt.clientY - disY;\n            height = dragTop + clientHeight;\n\n            if (offsetTop + height + marginSize < visibleHeight) {\n              if (height > minHeight) {\n                modalBoxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;\n              }\n            }\n\n            break;\n        }\n\n        modalBoxElem.className = modalBoxElem.className.replace(/\\s?is--drag/, '') + ' is--drag';\n\n        if (remember && storage) {\n          this.savePosStorage();\n        }\n\n        if ($listeners.zoom) {\n          this.$emit('zoom', params);\n        } else if (events.zoom) {\n          events.zoom.call(this, params);\n        }\n      };\n\n      document.onmouseup = () => {\n        this.zoomLocat = null;\n        document.onmousemove = domMousemove;\n        document.onmouseup = domMouseup;\n        setTimeout(() => {\n          modalBoxElem.className = modalBoxElem.className.replace(/\\s?is--drag/, '');\n        }, 50);\n      };\n    },\n\n    getStorageMap(key) {\n      const version = GlobalConfig.version;\n      const rest = XEUtils.toStringJSON(localStorage.getItem(key));\n      return rest && rest._v === version ? rest : {\n        _v: version\n      };\n    },\n\n    hasPosStorage() {\n      const id = this.id,\n            remember = this.remember,\n            storage = this.storage,\n            storageKey = this.storageKey;\n      return !!(remember && storage && this.getStorageMap(storageKey)[id]);\n    },\n\n    restorePosStorage() {\n      const id = this.id,\n            remember = this.remember,\n            storage = this.storage,\n            storageKey = this.storageKey;\n\n      if (remember && storage) {\n        const posStorage = this.getStorageMap(storageKey)[id];\n\n        if (posStorage) {\n          const modalBoxElem = this.getBox();\n\n          const _posStorage$split = posStorage.split(','),\n                _posStorage$split2 = _slicedToArray(_posStorage$split, 8),\n                left = _posStorage$split2[0],\n                top = _posStorage$split2[1],\n                width = _posStorage$split2[2],\n                height = _posStorage$split2[3],\n                zoomLeft = _posStorage$split2[4],\n                zoomTop = _posStorage$split2[5],\n                zoomWidth = _posStorage$split2[6],\n                zoomHeight = _posStorage$split2[7];\n\n          if (left) {\n            modalBoxElem.style.left = `${left}px`;\n          }\n\n          if (top) {\n            modalBoxElem.style.top = `${top}px`;\n          }\n\n          if (width) {\n            modalBoxElem.style.width = `${width}px`;\n          }\n\n          if (height) {\n            modalBoxElem.style.height = `${height}px`;\n          }\n\n          if (zoomLeft && zoomTop) {\n            this.zoomLocat = {\n              left: zoomLeft,\n              top: zoomTop,\n              width: zoomWidth,\n              height: zoomHeight\n            };\n          }\n        }\n      }\n    },\n\n    savePosStorage() {\n      const id = this.id,\n            remember = this.remember,\n            storage = this.storage,\n            storageKey = this.storageKey,\n            zoomLocat = this.zoomLocat;\n\n      if (remember && storage) {\n        const modalBoxElem = this.getBox();\n        const posStorageMap = this.getStorageMap(storageKey);\n        posStorageMap[id] = [modalBoxElem.style.left, modalBoxElem.style.top, modalBoxElem.style.width, modalBoxElem.style.height].concat(zoomLocat ? [zoomLocat.left, zoomLocat.top, zoomLocat.width, zoomLocat.height] : []).map(val => val ? XEUtils.toNumber(val) : '').join(',');\n        localStorage.setItem(storageKey, XEUtils.toJSONString(posStorageMap));\n      }\n    }\n\n  }\n};",null]}