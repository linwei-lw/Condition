{"remainingRequest":"D:\\cdRule\\node_modules\\thread-loader\\dist\\cjs.js!D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js!D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js!D:\\cdRule\\src\\components\\Table\\pulldown\\src\\pulldown.js","dependencies":[{"path":"D:\\cdRule\\src\\components\\Table\\pulldown\\src\\pulldown.js","mtime":1635230121448},{"path":"D:\\cdRule\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\thread-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import GlobalConfig from '../../v-x-e-table/src/conf';\nimport vSize from '../../mixins/size';\nimport { UtilTools, DomTools, GlobalEvent } from '../../tools';\nexport default {\n  name: 'VxePulldown',\n  mixins: [vSize],\n  props: {\n    disabled: Boolean,\n    placement: String,\n    size: {\n      type: String,\n      default: () => GlobalConfig.size\n    },\n    destroyOnClose: Boolean,\n    transfer: Boolean\n  },\n\n  data() {\n    return {\n      inited: false,\n      panelIndex: 0,\n      panelStyle: null,\n      panelPlacement: null,\n      currentValue: null,\n      visiblePanel: false,\n      animatVisible: false,\n      isActivated: false\n    };\n  },\n\n  created() {\n    GlobalEvent.on(this, 'mousewheel', this.handleGlobalMousewheelEvent);\n    GlobalEvent.on(this, 'mousedown', this.handleGlobalMousedownEvent);\n    GlobalEvent.on(this, 'blur', this.handleGlobalBlurEvent);\n  },\n\n  beforeDestroy() {\n    const panelElem = this.$refs.panel;\n\n    if (panelElem && panelElem.parentNode) {\n      panelElem.parentNode.removeChild(panelElem);\n    }\n  },\n\n  destroyed() {\n    GlobalEvent.off(this, 'mousewheel');\n    GlobalEvent.off(this, 'mousedown');\n    GlobalEvent.off(this, 'blur');\n  },\n\n  render(h) {\n    const $scopedSlots = this.$scopedSlots,\n          inited = this.inited,\n          vSize = this.vSize,\n          destroyOnClose = this.destroyOnClose,\n          transfer = this.transfer,\n          isActivated = this.isActivated,\n          disabled = this.disabled,\n          animatVisible = this.animatVisible,\n          visiblePanel = this.visiblePanel,\n          panelStyle = this.panelStyle,\n          panelPlacement = this.panelPlacement;\n    const defaultSlot = $scopedSlots.default;\n    const downSlot = $scopedSlots.dropdown;\n    return h('div', {\n      class: ['vxe-pulldown', {\n        [`size--${vSize}`]: vSize,\n        'is--visivle': visiblePanel,\n        'is--disabled': disabled,\n        'is--active': isActivated\n      }]\n    }, [h('div', {\n      ref: 'content',\n      class: 'vxe-pulldown--content'\n    }, defaultSlot ? defaultSlot.call(this, {\n      $pulldown: this\n    }, h) : []), h('div', {\n      ref: 'panel',\n      class: ['vxe-table--ignore-clear vxe-pulldown--panel', {\n        [`size--${vSize}`]: vSize,\n        'is--transfer': transfer,\n        'animat--leave': animatVisible,\n        'animat--enter': visiblePanel\n      }],\n      attrs: {\n        placement: panelPlacement\n      },\n      style: panelStyle\n    }, downSlot ? [h('div', {\n      class: 'vxe-pulldown--wrapper'\n    }, !inited || destroyOnClose && !visiblePanel && !animatVisible ? [] : downSlot.call(this, {\n      $pulldown: this\n    }, h))] : [])]);\n  },\n\n  methods: {\n    handleGlobalMousewheelEvent(evnt) {\n      const $refs = this.$refs,\n            disabled = this.disabled,\n            visiblePanel = this.visiblePanel;\n\n      if (!disabled) {\n        if (visiblePanel) {\n          if (DomTools.getEventTargetNode(evnt, $refs.panel).flag) {\n            this.updatePlacement();\n          } else {\n            this.hidePanel();\n            this.$emit('hide-panel', {\n              $event: evnt\n            });\n          }\n        }\n      }\n    },\n\n    handleGlobalMousedownEvent(evnt) {\n      const $refs = this.$refs,\n            $el = this.$el,\n            disabled = this.disabled,\n            visiblePanel = this.visiblePanel;\n\n      if (!disabled) {\n        this.isActivated = DomTools.getEventTargetNode(evnt, $el).flag || DomTools.getEventTargetNode(evnt, $refs.panel).flag;\n\n        if (visiblePanel && !this.isActivated) {\n          this.hidePanel();\n          this.$emit('hide-panel', {\n            $event: evnt\n          });\n        }\n      }\n    },\n\n    handleGlobalBlurEvent(evnt) {\n      if (this.visiblePanel) {\n        this.isActivated = false;\n        this.hidePanel();\n        this.$emit('hide-panel', {\n          $event: evnt\n        });\n      }\n    },\n\n    updateZindex() {\n      if (this.panelIndex < UtilTools.getLastZIndex()) {\n        this.panelIndex = UtilTools.nextZIndex();\n      }\n    },\n\n    isPanelVisible() {\n      return this.visiblePanel;\n    },\n\n    /**\r\n     * 切换下拉面板\r\n     */\n    togglePanel() {\n      if (this.visiblePanel) {\n        return this.hidePanel();\n      }\n\n      return this.showPanel();\n    },\n\n    /**\r\n     * 显示下拉面板\r\n     */\n    showPanel() {\n      if (!this.inited) {\n        this.inited = true;\n\n        if (this.transfer) {\n          document.body.appendChild(this.$refs.panel);\n        }\n      }\n\n      return new Promise(resolve => {\n        if (!this.disabled) {\n          clearTimeout(this.hidePanelTimeout);\n          this.isActivated = true;\n          this.animatVisible = true;\n          setTimeout(() => {\n            this.visiblePanel = true;\n            this.updatePlacement();\n            setTimeout(() => {\n              resolve(this.updatePlacement());\n            }, 40);\n          }, 10);\n          this.updateZindex();\n        } else {\n          resolve(this.$nextTick());\n        }\n      });\n    },\n\n    /**\r\n     * 隐藏下拉面板\r\n     */\n    hidePanel() {\n      this.visiblePanel = false;\n      return new Promise(resolve => {\n        if (this.animatVisible) {\n          this.hidePanelTimeout = setTimeout(() => {\n            this.animatVisible = false;\n            resolve(this.$nextTick());\n          }, 350);\n        } else {\n          resolve(this.$nextTick());\n        }\n      });\n    },\n\n    /**\r\n     * 手动更新位置\r\n     */\n    updatePlacement() {\n      return this.$nextTick().then(() => {\n        const $refs = this.$refs,\n              transfer = this.transfer,\n              placement = this.placement,\n              panelIndex = this.panelIndex,\n              visiblePanel = this.visiblePanel;\n\n        if (visiblePanel) {\n          const panelElem = $refs.panel;\n          const targetElem = $refs.content;\n\n          if (panelElem && targetElem) {\n            const targetHeight = targetElem.offsetHeight;\n            const targetWidth = targetElem.offsetWidth;\n            const panelHeight = panelElem.offsetHeight;\n            const panelWidth = panelElem.offsetWidth;\n            const marginSize = 5;\n            const panelStyle = {\n              zIndex: panelIndex\n            };\n\n            const _DomTools$getAbsolute = DomTools.getAbsolutePos(targetElem),\n                  boundingTop = _DomTools$getAbsolute.boundingTop,\n                  boundingLeft = _DomTools$getAbsolute.boundingLeft,\n                  visibleHeight = _DomTools$getAbsolute.visibleHeight,\n                  visibleWidth = _DomTools$getAbsolute.visibleWidth;\n\n            let panelPlacement = 'bottom';\n\n            if (transfer) {\n              let left = boundingLeft;\n              let top = boundingTop + targetHeight;\n\n              if (placement === 'top') {\n                panelPlacement = 'top';\n                top = boundingTop - panelHeight;\n              } else if (!placement) {\n                // 如果下面不够放，则向上\n                if (top + panelHeight + marginSize > visibleHeight) {\n                  panelPlacement = 'top';\n                  top = boundingTop - panelHeight;\n                } // 如果上面不够放，则向下（优先）\n\n\n                if (top < marginSize) {\n                  panelPlacement = 'bottom';\n                  top = boundingTop + targetHeight;\n                }\n              } // 如果溢出右边\n\n\n              if (left + panelWidth + marginSize > visibleWidth) {\n                left -= left + panelWidth + marginSize - visibleWidth;\n              } // 如果溢出左边\n\n\n              if (left < marginSize) {\n                left = marginSize;\n              }\n\n              Object.assign(panelStyle, {\n                left: `${left}px`,\n                top: `${top}px`,\n                minWidth: `${targetWidth}px`\n              });\n            } else {\n              if (placement === 'top') {\n                panelPlacement = 'top';\n                panelStyle.bottom = `${targetHeight}px`;\n              } else if (!placement) {\n                // 如果下面不够放，则向上\n                if (boundingTop + targetHeight + panelHeight > visibleHeight) {\n                  // 如果上面不够放，则向下（优先）\n                  if (boundingTop - targetHeight - panelHeight > marginSize) {\n                    panelPlacement = 'top';\n                    panelStyle.bottom = `${targetHeight}px`;\n                  }\n                }\n              }\n            }\n\n            this.panelStyle = panelStyle;\n            this.panelPlacement = panelPlacement;\n          }\n        }\n\n        return this.$nextTick();\n      });\n    }\n\n  }\n};",null]}