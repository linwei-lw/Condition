{"remainingRequest":"D:\\cdRule\\node_modules\\thread-loader\\dist\\cjs.js!D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js!D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js!D:\\cdRule\\src\\components\\Table\\list\\src\\list.js","dependencies":[{"path":"D:\\cdRule\\src\\components\\Table\\list\\src\\list.js","mtime":1635230121491},{"path":"D:\\cdRule\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\thread-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import XEUtils from 'xe-utils';\nimport GlobalConfig from '../../v-x-e-table/src/conf';\nimport vSize from '../../mixins/size';\nimport { GlobalEvent, createResizeEvent } from '../../tools';\nimport { browse } from '../../tools/src/dom';\nexport default {\n  name: 'VxeList',\n  mixins: [vSize],\n  props: {\n    data: Array,\n    height: [Number, String],\n    maxHeight: [Number, String],\n    loading: Boolean,\n    className: [String, Function],\n    size: {\n      type: String,\n      default: () => GlobalConfig.list.size || GlobalConfig.size\n    },\n    autoResize: {\n      type: Boolean,\n      default: () => GlobalConfig.list.autoResize\n    },\n    syncResize: [Boolean, String, Number],\n    scrollY: Object\n  },\n\n  data() {\n    return {\n      scrollYLoad: false,\n      bodyHeight: 0,\n      topSpaceHeight: 0,\n      items: []\n    };\n  },\n\n  computed: {\n    sYOpts() {\n      return Object.assign({}, GlobalConfig.list.scrollY, this.scrollY);\n    },\n\n    styles() {\n      const height = this.height,\n            maxHeight = this.maxHeight;\n      const style = {};\n\n      if (height) {\n        style.height = isNaN(height) ? height : `${height}px`;\n      } else if (maxHeight) {\n        style.height = 'auto';\n        style.maxHeight = isNaN(maxHeight) ? maxHeight : `${maxHeight}px`;\n      }\n\n      return style;\n    }\n\n  },\n  watch: {\n    data(value) {\n      this.loadData(value);\n    },\n\n    syncResize(value) {\n      if (value) {\n        this.recalculate();\n        this.$nextTick(() => setTimeout(() => this.recalculate()));\n      }\n    }\n\n  },\n\n  created() {\n    Object.assign(this, {\n      fullData: [],\n      lastScrollLeft: 0,\n      lastScrollTop: 0,\n      scrollYStore: {\n        startIndex: 0,\n        endIndex: 0,\n        visibleSize: 0\n      }\n    });\n    this.loadData(this.data);\n    GlobalEvent.on(this, 'resize', this.handleGlobalResizeEvent);\n  },\n\n  mounted() {\n    if (this.autoResize) {\n      const resizeObserver = createResizeEvent(() => this.recalculate());\n      resizeObserver.observe(this.$el);\n      this.$resize = resizeObserver;\n    }\n  },\n\n  beforeDestroy() {\n    if (this.$resize) {\n      this.$resize.disconnect();\n    }\n  },\n\n  destroyed() {\n    GlobalEvent.off(this, 'resize');\n  },\n\n  render(h) {\n    const $scopedSlots = this.$scopedSlots,\n          styles = this.styles,\n          bodyHeight = this.bodyHeight,\n          topSpaceHeight = this.topSpaceHeight,\n          items = this.items,\n          className = this.className,\n          loading = this.loading;\n    return h('div', {\n      class: ['vxe-list', className ? XEUtils.isFunction(className) ? className({\n        $list: this\n      }) : className : '', {\n        'is--loading': loading\n      }]\n    }, [h('div', {\n      ref: 'virtualWrapper',\n      class: 'vxe-list--virtual-wrapper',\n      style: styles,\n      on: {\n        scroll: this.scrollEvent\n      }\n    }, [h('div', {\n      ref: 'ySpace',\n      class: 'vxe-list--y-space',\n      style: {\n        height: bodyHeight ? `${bodyHeight}px` : ''\n      }\n    }), h('div', {\n      ref: 'virtualBody',\n      class: 'vxe-list--body',\n      style: {\n        marginTop: topSpaceHeight ? `${topSpaceHeight}px` : ''\n      }\n    }, $scopedSlots.default ? $scopedSlots.default.call(this, {\n      items,\n      $list: this\n    }, h) : [])]), h('div', {\n      class: ['vxe-list--loading vxe-loading', {\n        'is--visible': loading\n      }]\n    }, [h('div', {\n      class: 'vxe-loading--spinner'\n    })])]);\n  },\n\n  methods: {\n    getParentElem() {\n      return this.$el.parentNode;\n    },\n\n    /**\r\n     * 加载数据\r\n     * @param {Array} datas 数据\r\n     */\n    loadData(datas) {\n      const sYOpts = this.sYOpts,\n            scrollYStore = this.scrollYStore;\n      const fullData = datas || [];\n      scrollYStore.startIndex = 0;\n      scrollYStore.visibleIndex = 0;\n      this.fullData = fullData;\n      this.scrollYLoad = sYOpts.enabled && sYOpts.gt > -1 && sYOpts.gt <= fullData.length;\n      this.handleData();\n      return this.computeScrollLoad().then(() => {\n        this.refreshScroll();\n      });\n    },\n\n    /**\r\n     * 重新加载数据\r\n     * @param {Array} datas 数据\r\n     */\n    reloadData(datas) {\n      this.clearScroll();\n      return this.loadData(datas);\n    },\n\n    handleData() {\n      const fullData = this.fullData,\n            scrollYLoad = this.scrollYLoad,\n            scrollYStore = this.scrollYStore;\n      this.items = scrollYLoad ? fullData.slice(scrollYStore.startIndex, scrollYStore.endIndex) : fullData.slice(0);\n      return this.$nextTick();\n    },\n\n    /**\r\n     * 重新计算列表\r\n     */\n    recalculate() {\n      const $el = this.$el;\n\n      if ($el.clientWidth && $el.clientHeight) {\n        return this.computeScrollLoad();\n      }\n\n      return Promise.resolve();\n    },\n\n    /**\r\n     * 清除滚动条\r\n     */\n    clearScroll() {\n      const scrollBodyElem = this.$refs.virtualWrapper;\n\n      if (scrollBodyElem) {\n        scrollBodyElem.scrollTop = 0;\n      }\n\n      return this.$nextTick();\n    },\n\n    /**\r\n     * 刷新滚动条\r\n     */\n    refreshScroll() {\n      const lastScrollLeft = this.lastScrollLeft,\n            lastScrollTop = this.lastScrollTop;\n      return this.clearScroll().then(() => {\n        if (lastScrollLeft || lastScrollTop) {\n          this.lastScrollLeft = 0;\n          this.lastScrollTop = 0;\n          return this.scrollTo(lastScrollLeft, lastScrollTop);\n        }\n      });\n    },\n\n    /**\r\n     * 如果有滚动条，则滚动到对应的位置\r\n     * @param {Number} scrollLeft 左距离\r\n     * @param {Number} scrollTop 上距离\r\n     */\n    scrollTo(scrollLeft, scrollTop) {\n      const scrollBodyElem = this.$refs.virtualWrapper;\n\n      if (XEUtils.isNumber(scrollLeft)) {\n        scrollBodyElem.scrollLeft = scrollLeft;\n      }\n\n      if (XEUtils.isNumber(scrollTop)) {\n        scrollBodyElem.scrollTop = scrollTop;\n      }\n\n      if (this.scrollYLoad) {\n        return new Promise(resolve => setTimeout(() => resolve(this.$nextTick()), 50));\n      }\n\n      return this.$nextTick();\n    },\n\n    computeScrollLoad() {\n      return this.$nextTick().then(() => {\n        const $refs = this.$refs,\n              sYOpts = this.sYOpts,\n              scrollYLoad = this.scrollYLoad,\n              scrollYStore = this.scrollYStore;\n        const virtualWrapperElem = $refs.virtualWrapper,\n              virtualBodyElem = $refs.virtualBody;\n        let rowHeight = 0;\n        let firstItemElem;\n\n        if (virtualBodyElem) {\n          if (sYOpts.sItem) {\n            firstItemElem = virtualBodyElem.querySelector(sYOpts.sItem);\n          }\n\n          if (!firstItemElem) {\n            firstItemElem = virtualBodyElem.children[0];\n          }\n        }\n\n        if (firstItemElem) {\n          rowHeight = firstItemElem.offsetHeight;\n        }\n\n        rowHeight = Math.max(20, rowHeight);\n        scrollYStore.rowHeight = rowHeight; // 计算 Y 逻辑\n\n        if (scrollYLoad) {\n          const visibleYSize = Math.max(8, Math.ceil(virtualWrapperElem.clientHeight / rowHeight));\n          const offsetYSize = sYOpts.oSize ? XEUtils.toNumber(sYOpts.oSize) : browse.msie ? 20 : browse.edge ? 10 : 0;\n          scrollYStore.offsetSize = offsetYSize;\n          scrollYStore.visibleSize = visibleYSize;\n          scrollYStore.endIndex = Math.max(scrollYStore.startIndex, visibleYSize + offsetYSize, scrollYStore.endIndex);\n          this.updateYData();\n        } else {\n          this.updateYSpace();\n        }\n\n        this.rowHeight = rowHeight;\n      });\n    },\n\n    scrollEvent(evnt) {\n      const scrollBodyElem = evnt.target;\n      const scrollTop = scrollBodyElem.scrollTop;\n      const scrollLeft = scrollBodyElem.scrollLeft;\n      const isX = scrollLeft !== this.lastScrollLeft;\n      const isY = scrollTop !== this.lastScrollTop;\n      this.lastScrollTop = scrollTop;\n      this.lastScrollLeft = scrollLeft;\n\n      if (this.scrollYLoad) {\n        this.loadYData(evnt);\n      }\n\n      this.$emit('scroll', {\n        scrollLeft,\n        scrollTop,\n        isX,\n        isY,\n        $event: evnt\n      });\n    },\n\n    loadYData(evnt) {\n      const scrollYStore = this.scrollYStore;\n      const startIndex = scrollYStore.startIndex,\n            endIndex = scrollYStore.endIndex,\n            visibleSize = scrollYStore.visibleSize,\n            offsetSize = scrollYStore.offsetSize,\n            rowHeight = scrollYStore.rowHeight;\n      const scrollBodyElem = evnt.target;\n      const scrollTop = scrollBodyElem.scrollTop;\n      const toVisibleIndex = Math.floor(scrollTop / rowHeight);\n      const offsetStartIndex = Math.max(0, toVisibleIndex - 1 - offsetSize);\n      const offsetEndIndex = toVisibleIndex + visibleSize + offsetSize;\n\n      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {\n        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {\n          scrollYStore.startIndex = offsetStartIndex;\n          scrollYStore.endIndex = offsetEndIndex;\n          this.updateYData();\n        }\n      }\n    },\n\n    updateYData() {\n      this.handleData();\n      this.updateYSpace();\n    },\n\n    updateYSpace() {\n      const scrollYStore = this.scrollYStore,\n            scrollYLoad = this.scrollYLoad,\n            fullData = this.fullData;\n      this.bodyHeight = scrollYLoad ? fullData.length * scrollYStore.rowHeight : 0;\n      this.topSpaceHeight = scrollYLoad ? Math.max(scrollYStore.startIndex * scrollYStore.rowHeight, 0) : 0;\n    },\n\n    handleGlobalResizeEvent() {\n      this.recalculate();\n    }\n\n  }\n};",null]}