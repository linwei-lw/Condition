{"remainingRequest":"D:\\cdRule\\node_modules\\thread-loader\\dist\\cjs.js!D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js!D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js!D:\\cdRule\\src\\common\\util\\Trees.js","dependencies":[{"path":"D:\\cdRule\\src\\common\\util\\Trees.js","mtime":1612227987785},{"path":"D:\\cdRule\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\thread-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/es6.function.name\";\nimport { arrayToMap } from '@/common/util/Arrays.js';\n/**\r\n * 复制树结构体\r\n * @param {Array|Object} tree 树的根结点\r\n * @param {Boolean} [setParent] 是否需要设置父结点\r\n * @param {String} [parentField] 父结点字段\r\n * @param {String} [childrenField] 孩子结点字段\r\n * @returns {Array|Object} 返回复制后的树结构\r\n */\n\nexport function copyTree(tree) {\n  var setParent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var parentField = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'parent';\n  var childrenField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'children';\n  var parent = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var copys = [],\n      isarray = Array.isArray(tree);\n  tree = isarray ? tree : [tree];\n\n  for (var i = 0, len = tree.length, node, copy; i < len; i++) {\n    node = tree[i];\n    copy = {};\n\n    for (var key in node) {\n      if (key != parentField && key != childrenField) {\n        copy[key] = node[key];\n      }\n    }\n\n    if (node[childrenField]) {\n      copy[childrenField] = copyTree(node[childrenField], setParent, parentField, childrenField, copy);\n    }\n\n    setParent && (copy[parentField] = parent);\n    copys.push(copy);\n  }\n\n  return isarray ? copys : copys[0];\n}\n/**\r\n * 将数组转成 TREE 结构体\r\n * @param {Array} array 元素数组\r\n * @param {String} [id] 元素的id字段(默认值:id)\r\n * @param {String} [pid] 元素的父id字段(默认值:pid)\r\n * @param {Object} [map] 元素的map结构\r\n * @param {Object} [root] 元素的根节点\r\n * @param {String} [childrenKey] 保存子节点的字段\r\n * @returns {Array} 返回tree第一层数组\r\n */\n\nexport function arrayToTree(array) {\n  var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'id';\n  var pid = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'pid';\n  var map = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var root = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var childrenKey = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'children';\n  if (!array || array.length == 0) return [];\n  map = map || arrayToMap(array, id);\n  var tree;\n\n  if (root) {\n    root[childrenKey] ? tree = root[childrenKey] : root[childrenKey] = tree = [];\n  } else {\n    tree = [];\n  }\n\n  for (var i = 0, len = array.length, item, parent, sons; i < len; i++) {\n    item = array[i];\n    parent = map[item[pid]];\n\n    if (parent) {\n      sons = parent[childrenKey];\n      !sons && (sons = parent[childrenKey] = []);\n      sons.push(item);\n      item.parent = parent;\n    } else {\n      item.parent = root || null;\n      tree.push(item);\n    }\n  }\n\n  return tree;\n}\n;\n/**\r\n * 从指定树结点nodes中查找符合条件的所有结点，查找规则是：结点属性field的值，等于数组values中其中一个\r\n * @param {Array} nodes 树结点\r\n * @param {Array} values 数组值\r\n * @param {String} field 结点属性\r\n * @param {String} [hasOwnField] 结点必须有该字段\r\n * @returns {Array} 返回符合的结点数组\r\n */\n\nexport function getNodesByValues(nodes, values) {\n  var field = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'id';\n  var hasOwnField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  if (!nodes || !values || values.length == 0) return [];\n  var _values = {};\n\n  for (var i = 0, len = values.length; i < len; i++) {\n    _values[values[i]] = true;\n  }\n\n  nodes = Array.isArray(nodes) ? nodes : [nodes];\n  return _getNodesByValues(nodes, _values, field, hasOwnField, [], values.length);\n}\n\nfunction _getNodesByValues(nodes, values) {\n  var field = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'id';\n  var hasOwnField = arguments.length > 3 ? arguments[3] : undefined;\n  var array = arguments.length > 4 ? arguments[4] : undefined;\n  var left = arguments.length > 5 ? arguments[5] : undefined;\n  if (!nodes || nodes.length == 0) return array;\n\n  for (var i = 0, len = nodes.length, node; i < len; i++) {\n    node = nodes[i];\n\n    if (!hasOwnField || node.hasOwnProperty(hasOwnField)) {\n      if (values[node[field]] === true) {\n        array.push(node);\n        if (--left == 0) return array;\n      }\n    }\n\n    if (node.children && node.children.length > 0) {\n      _getNodesByValues(node.children, values, field, hasOwnField, array, left);\n    }\n  }\n\n  return array;\n}\n/**\r\n * 从指定树结点nodes中查找符合条件的一个结点，查找规则是：结点属性field的值等于value\r\n * @param {Array} nodes 树结点\r\n * @param {Object} value 数值\r\n * @param {String} field 结点属性\r\n * @param {String} [hasOwnField] 结点必须有该字段\r\n * @returns {Object} 返回符合的结点\r\n */\n\n\nexport function getNodeByValue(nodes, value) {\n  var field = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'id';\n  var hasOwnField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  if (!nodes) return null;\n  nodes = Array.isArray(nodes) ? nodes : [nodes];\n  if (nodes.length == 0) return null;\n\n  for (var i = 0, len = nodes.length, node; i < len; i++) {\n    node = nodes[i];\n\n    if (!hasOwnField || node.hasOwnProperty(hasOwnField)) {\n      if (node[field] === value) {\n        return node;\n      }\n    }\n\n    if (node.children && node.children.length > 0) {\n      node = getNodeByValue(node.children, value, field, hasOwnField);\n      if (node) return node;\n    }\n  }\n\n  return null;\n}\n/**\r\n * 从指定树结点nodes中查找符合条件的结点，查找规则是：filter函数返回true\r\n * @param {Array} nodes 树结点\r\n * @param {Function} filter 过滤函数\r\n * @param {String} children children属性\r\n * @returns {Array} 返回结点集合\r\n */\n\nexport function getNodesByFilter(nodes, filter) {\n  var children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'children';\n  var result = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  if (!nodes) return [];\n  result = result || [];\n  nodes = Array.isArray(nodes) ? nodes : [nodes];\n\n  for (var i = 0, len = nodes.length, node; i < len; i++) {\n    node = nodes[i];\n    filter(node) === true && result.push(node);\n    node = node[children];\n\n    if (node && node.length > 0) {\n      getNodesByFilter(node, filter, children, result);\n    }\n  }\n\n  return result;\n}\n/**\r\n * 将树结点，转成MAP结构\r\n * @param {Array} nodes 树结点\r\n * @param {String} key key属性\r\n * @param {String} children children属性\r\n * @param {String} [hasOwnField] 结点必须有该字段\r\n * @param {Map} [map] 覆盖MAP对象\r\n * @returns {Map} 返回MAP结构对象\r\n */\n\nexport function treeToMap(nodes) {\n  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'id';\n  var children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'children';\n  var hasOwnField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var map = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  map = map || {};\n\n  if (!nodes || nodes.length == 0) {\n    return map;\n  }\n\n  for (var i = 0, len = nodes.length, node; i < len; i++) {\n    node = nodes[i];\n\n    if (!hasOwnField || node.hasOwnProperty(hasOwnField)) {\n      map[node[key]] = node;\n    }\n\n    node = node[children];\n\n    if (node && node.length > 0) {\n      treeToMap(node, key, children, hasOwnField, map);\n    }\n  }\n\n  return map;\n}\nexport function treeSearch(tree, text) {\n  var hasOwnField = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var searchFun = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var max = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 99999999;\n  var nodes = tree.getNodes();\n\n  if (nodes && nodes.length == 1) {\n    nodes = nodes[0][tree.setting.data.key.children];\n  }\n\n  if (!nodes || nodes.length == 0) return [];\n  return dgSearch([], nodes, text.toLowerCase(), hasOwnField, searchFun, tree.setting.view.nameFunction, tree.setting.view.hideFunction, tree.setting.data.key, max);\n}\n\nfunction dgSearch(results, nodes, text, hasOwnField, searchFun, nameFun, hideFun, keys, max) {\n  if (!nodes || nodes.length == 0) {\n    return results;\n  }\n\n  for (var i = 0, len = nodes.length, node, value; i < len; i++) {\n    node = nodes[i];\n    if (hideFun && hideFun(node) === true) continue;\n\n    if (!hasOwnField || node.hasOwnProperty(hasOwnField)) {\n      if (searchFun) {\n        if (searchFun(node, text) === true) {\n          results.push(node);\n          if (results.length >= max) return results;\n        }\n      } else {\n        value = nameFun ? nameFun(node) : node[keys.name];\n\n        if (value) {\n          value = value.toLowerCase();\n\n          if (value.indexOf(text) >= 0) {\n            results.push(node);\n            if (results.length >= max) return results;\n          }\n        }\n      }\n    }\n\n    dgSearch(results, node[keys.children], text, hasOwnField, searchFun, nameFun, hideFun, keys, max);\n  }\n\n  return results;\n}",null]}