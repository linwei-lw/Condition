{"remainingRequest":"D:\\cdRule\\node_modules\\thread-loader\\dist\\cjs.js!D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js!D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js!D:\\cdRule\\src\\components\\Table\\tools\\src\\dom.js","dependencies":[{"path":"D:\\cdRule\\src\\components\\Table\\tools\\src\\dom.js","mtime":1635230121384},{"path":"D:\\cdRule\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\thread-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.regexp.replace\";\nimport \"core-js/modules/es6.regexp.match\";\nimport \"core-js/modules/es6.regexp.constructor\";\nimport \"core-js/modules/es6.regexp.replace\";\nimport \"core-js/modules/es6.regexp.match\";\nimport \"core-js/modules/es6.regexp.constructor\";\nimport XEUtils from 'xe-utils';\nimport UtilTools from './utils';\nconst getRowid = UtilTools.getRowid;\nexport const browse = XEUtils.browse();\nconst reClsMap = {};\n\nfunction getClsRE(cls) {\n  if (!reClsMap[cls]) {\n    reClsMap[cls] = new RegExp(`(?:^|\\\\s)${cls}(?!\\\\S)`, 'g');\n  }\n\n  return reClsMap[cls];\n}\n\nfunction getNodeOffset(elem, container, rest) {\n  if (elem) {\n    const parentElem = elem.parentNode;\n    rest.top += elem.offsetTop;\n    rest.left += elem.offsetLeft;\n\n    if (parentElem && parentElem !== document.documentElement && parentElem !== document.body) {\n      rest.top -= parentElem.scrollTop;\n      rest.left -= parentElem.scrollLeft;\n    }\n\n    if (container && (elem === container || elem.offsetParent === container) ? 0 : elem.offsetParent) {\n      return getNodeOffset(elem.offsetParent, container, rest);\n    }\n  }\n\n  return rest;\n}\n\nfunction isScale(val) {\n  return val && /^\\d+%$/.test(val);\n}\n\nfunction hasClass(elem, cls) {\n  return elem && elem.className && elem.className.match && elem.className.match(getClsRE(cls));\n}\n\nfunction removeClass(elem, cls) {\n  if (elem && hasClass(elem, cls)) {\n    elem.className = elem.className.replace(getClsRE(cls), '');\n  }\n}\n\nfunction getDomNode() {\n  const documentElement = document.documentElement;\n  const bodyElem = document.body;\n  return {\n    scrollTop: documentElement.scrollTop || bodyElem.scrollTop,\n    scrollLeft: documentElement.scrollLeft || bodyElem.scrollLeft,\n    visibleHeight: documentElement.clientHeight || bodyElem.clientHeight,\n    visibleWidth: documentElement.clientWidth || bodyElem.clientWidth\n  };\n}\n\nexport function getOffsetHeight(elem) {\n  return elem ? elem.offsetHeight : 0;\n}\nexport function getPaddingTopBottomSize(elem) {\n  if (elem) {\n    const computedStyle = getComputedStyle(elem);\n    const paddingTop = XEUtils.toNumber(computedStyle.paddingTop);\n    const paddingBottom = XEUtils.toNumber(computedStyle.paddingBottom);\n    return paddingTop + paddingBottom;\n  }\n\n  return 0;\n}\nexport function setScrollTop(elem, scrollTop) {\n  if (elem) {\n    elem.scrollTop = scrollTop;\n  }\n}\nexport function setScrollLeft(elem, scrollLeft) {\n  if (elem) {\n    elem.scrollLeft = scrollLeft;\n  }\n}\nexport const DomTools = {\n  browse,\n\n  isPx(val) {\n    return val && /^\\d+(px)?$/.test(val);\n  },\n\n  isScale,\n  hasClass,\n  removeClass,\n\n  addClass(elem, cls) {\n    if (elem && !hasClass(elem, cls)) {\n      removeClass(elem, cls);\n      elem.className = `${elem.className} ${cls}`;\n    }\n  },\n\n  updateCellTitle(overflowElem, column) {\n    const content = column.type === 'html' ? overflowElem.innerText : overflowElem.textContent;\n\n    if (overflowElem.getAttribute('title') !== content) {\n      overflowElem.setAttribute('title', content);\n    }\n  },\n\n  rowToVisible($xetable, row) {\n    const bodyElem = $xetable.$refs.tableBody.$el;\n    const trElem = bodyElem.querySelector(`[rowid=\"${getRowid($xetable, row)}\"]`);\n\n    if (trElem) {\n      const bodyHeight = bodyElem.clientHeight;\n      const bodySrcollTop = bodyElem.scrollTop;\n      const trOffsetTop = trElem.offsetTop + (trElem.offsetParent ? trElem.offsetParent.offsetTop : 0);\n      const trHeight = trElem.clientHeight; // 检测行是否在可视区中\n\n      if (trOffsetTop < bodySrcollTop || trOffsetTop > bodySrcollTop + bodyHeight) {\n        // 向上定位\n        return $xetable.scrollTo(null, trOffsetTop);\n      } else if (trOffsetTop + trHeight >= bodyHeight + bodySrcollTop) {\n        // 向下定位\n        return $xetable.scrollTo(null, bodySrcollTop + trHeight);\n      }\n    } else {\n      // 如果是虚拟渲染跨行滚动\n      if ($xetable.scrollYLoad) {\n        return $xetable.scrollTo(null, ($xetable.afterFullData.indexOf(row) - 1) * $xetable.scrollYStore.rowHeight);\n      }\n    }\n\n    return Promise.resolve();\n  },\n\n  colToVisible($xetable, column) {\n    const bodyElem = $xetable.$refs.tableBody.$el;\n    const tdElem = bodyElem.querySelector(`.${column.id}`);\n\n    if (tdElem) {\n      const bodyWidth = bodyElem.clientWidth;\n      const bodySrcollLeft = bodyElem.scrollLeft;\n      const tdOffsetLeft = tdElem.offsetLeft + (tdElem.offsetParent ? tdElem.offsetParent.offsetLeft : 0);\n      const tdWidth = tdElem.clientWidth; // 检测行是否在可视区中\n\n      if (tdOffsetLeft < bodySrcollLeft || tdOffsetLeft > bodySrcollLeft + bodyWidth) {\n        // 向左定位\n        return $xetable.scrollTo(tdOffsetLeft);\n      } else if (tdOffsetLeft + tdWidth >= bodyWidth + bodySrcollLeft) {\n        // 向右定位\n        return $xetable.scrollTo(bodySrcollLeft + tdWidth);\n      }\n    } else {\n      // 如果是虚拟渲染跨行滚动\n      if ($xetable.scrollXLoad) {\n        const visibleColumn = $xetable.visibleColumn;\n        let scrollLeft = 0;\n\n        for (let index = 0; index < visibleColumn.length; index++) {\n          if (visibleColumn[index] === column) {\n            break;\n          }\n\n          scrollLeft += visibleColumn[index].renderWidth;\n        }\n\n        return $xetable.scrollTo(scrollLeft);\n      }\n    }\n\n    return Promise.resolve();\n  },\n\n  getDomNode,\n\n  /**\r\n   * 检查触发源是否属于目标节点\r\n   */\n  getEventTargetNode(evnt, container, queryCls, queryMethod) {\n    let targetElem;\n    let target = evnt.target;\n\n    while (target && target.nodeType && target !== document) {\n      if (queryCls && hasClass(target, queryCls) && (!queryMethod || queryMethod(target))) {\n        targetElem = target;\n      } else if (target === container) {\n        return {\n          flag: queryCls ? !!targetElem : true,\n          container,\n          targetElem: targetElem\n        };\n      }\n\n      target = target.parentNode;\n    }\n\n    return {\n      flag: false\n    };\n  },\n\n  /**\r\n   * 获取元素相对于 document 的位置\r\n   */\n  getOffsetPos(elem, container) {\n    return getNodeOffset(elem, container, {\n      left: 0,\n      top: 0\n    });\n  },\n\n  getAbsolutePos(elem) {\n    const bounding = elem.getBoundingClientRect();\n    const boundingTop = bounding.top;\n    const boundingLeft = bounding.left;\n\n    const _getDomNode = getDomNode(),\n          scrollTop = _getDomNode.scrollTop,\n          scrollLeft = _getDomNode.scrollLeft,\n          visibleHeight = _getDomNode.visibleHeight,\n          visibleWidth = _getDomNode.visibleWidth;\n\n    return {\n      boundingTop,\n      top: scrollTop + boundingTop,\n      boundingLeft,\n      left: scrollLeft + boundingLeft,\n      visibleHeight,\n      visibleWidth\n    };\n  },\n\n  scrollToView(elem) {\n    const scrollIntoViewIfNeeded = 'scrollIntoViewIfNeeded';\n    const scrollIntoView = 'scrollIntoView';\n\n    if (elem) {\n      if (elem[scrollIntoViewIfNeeded]) {\n        elem[scrollIntoViewIfNeeded]();\n      } else if (elem[scrollIntoView]) {\n        elem[scrollIntoView]();\n      }\n    }\n  },\n\n  triggerEvent(targetElem, type) {\n    let evnt;\n\n    if (typeof Event === 'function') {\n      evnt = new Event(type);\n    } else {\n      evnt = document.createEvent('Event');\n      evnt.initEvent(type, true, true);\n    }\n\n    targetElem.dispatchEvent(evnt);\n  },\n\n  calcHeight($xetable, key) {\n    const val = $xetable[key];\n    let num = 0;\n\n    if (val) {\n      if (val === 'auto') {\n        num = $xetable.parentHeight;\n      } else {\n        const excludeHeight = $xetable.getExcludeHeight();\n\n        if (isScale(val)) {\n          num = Math.floor((XEUtils.toInteger(val) || 1) / 100 * $xetable.parentHeight);\n        } else {\n          num = XEUtils.toNumber(val);\n        }\n\n        num = Math.max(40, num - excludeHeight);\n      }\n    }\n\n    return num;\n  }\n\n};\nexport default DomTools;",null]}