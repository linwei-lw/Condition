{"remainingRequest":"D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js!D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js!D:\\cdRule\\src\\components\\Table\\validator\\src\\mixin.js","dependencies":[{"path":"D:\\cdRule\\src\\components\\Table\\validator\\src\\mixin.js","mtime":1635230120982},{"path":"D:\\cdRule\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.array.find\";\nimport \"core-js/modules/es6.object.keys\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.regexp.constructor\";\nimport \"core-js/modules/es6.array.find\";\nimport \"core-js/modules/es6.object.keys\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.regexp.constructor\";\nimport _classCallCheck from \"D:\\\\cdRule\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\cdRule\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport XEUtils from 'xe-utils';\nimport { UtilTools, DomTools } from \"../../tools\";\nimport { eqEmptyValue } from \"../../tools/src/utils\";\n/**\r\n * 校验规则\r\n */\n\nvar Rule =\n/*#__PURE__*/\nfunction () {\n  function Rule(rule) {\n    _classCallCheck(this, Rule);\n\n    Object.assign(this, {\n      $options: rule,\n      required: rule.required,\n      min: rule.min,\n      max: rule.max,\n      type: rule.type,\n      pattern: rule.pattern,\n      validator: rule.validator,\n      trigger: rule.trigger,\n      maxWidth: rule.maxWidth\n    });\n  }\n  /**\r\n   * 获取校验不通过的消息\r\n   * 支持国际化翻译\r\n   */\n\n\n  _createClass(Rule, [{\n    key: \"message\",\n    get: function get() {\n      return UtilTools.getFuncText(this.$options.message);\n    }\n  }]);\n\n  return Rule;\n}();\n\nfunction validErrorRuleValue(rule, val) {\n  var type = rule.type,\n      min = rule.min,\n      max = rule.max,\n      pattern = rule.pattern;\n  var isNumType = type === 'number';\n  var numVal = isNumType ? XEUtils.toNumber(val) : XEUtils.getSize(val); // 判断数值\n\n  if (isNumType && isNaN(val)) {\n    return true;\n  } // 如果存在 min，判断最小值\n\n\n  if (!XEUtils.eqNull(min) && numVal < XEUtils.toNumber(min)) {\n    return true;\n  } // 如果存在 max，判断最大值\n\n\n  if (!XEUtils.eqNull(max) && numVal > XEUtils.toNumber(max)) {\n    return true;\n  } // 如果存在 pattern，正则校验\n\n\n  if (pattern && !(XEUtils.isRegExp(pattern) ? pattern : new RegExp(pattern)).test(val)) {\n    return true;\n  }\n\n  return false;\n}\n\nexport default {\n  methods: {\n    /**\r\n     * 完整校验，和 validate 的区别就是会给有效数据中的每一行进行校验\r\n     */\n    _fullValidate: function _fullValidate(rows, cb) {\n      return this.beginValidate(rows, cb, true);\n    },\n\n    /**\r\n     * 快速校验，如果存在记录不通过的记录，则返回不再继续校验（异步校验除外）\r\n     */\n    _validate: function _validate(rows, cb) {\n      return this.beginValidate(rows, cb);\n    },\n\n    /**\r\n     * 聚焦到校验通过的单元格并弹出校验错误提示\r\n     */\n    handleValidError: function handleValidError(params) {\n      var _this = this;\n\n      return new Promise(function (resolve) {\n        if (_this.validOpts.autoPos === false) {\n          _this.emitEvent('valid-error', params);\n\n          resolve();\n        } else {\n          _this.handleActived(params, {\n            type: 'valid-error',\n            trigger: 'call'\n          }).then(function () {\n            setTimeout(function () {\n              resolve(_this.showValidTooltip(params));\n            }, 10);\n          });\n        }\n      });\n    },\n\n    /**\r\n     * 对表格数据进行校验\r\n     * 如果不指定数据，则默认只校验临时变动的数据，例如新增或修改\r\n     * 如果传 true 则校验当前表格数据\r\n     * 如果传 row 指定行记录，则只验证传入的行\r\n     * 如果传 rows 为多行记录，则只验证传入的行\r\n     * 如果只传 callback 否则默认验证整个表格数据\r\n     * 返回 Promise 对象，或者使用回调方式\r\n     */\n    beginValidate: function beginValidate(rows, cb, isFull) {\n      var _this2 = this;\n\n      var validRest = {};\n      var editRules = this.editRules,\n          afterFullData = this.afterFullData,\n          treeConfig = this.treeConfig,\n          treeOpts = this.treeOpts;\n      var vaildDatas;\n\n      if (rows === true) {\n        vaildDatas = afterFullData;\n      } else if (rows) {\n        if (XEUtils.isFunction(rows)) {\n          cb = rows;\n        } else {\n          vaildDatas = XEUtils.isArray(rows) ? rows : [rows];\n        }\n      }\n\n      if (!vaildDatas) {\n        vaildDatas = this.getInsertRecords().concat(this.getUpdateRecords());\n      }\n\n      var rowValids = [];\n      this.lastCallTime = Date.now();\n      this.validRuleErr = false; // 如果为快速校验，当存在某列校验不通过时将终止执行\n\n      this.clearValidate();\n\n      if (editRules) {\n        var columns = this.getColumns();\n\n        var handleVaild = function handleVaild(row) {\n          if (isFull || !_this2.validRuleErr) {\n            var colVailds = [];\n            columns.forEach(function (column) {\n              if ((isFull || !_this2.validRuleErr) && XEUtils.has(editRules, column.property)) {\n                colVailds.push(_this2.validCellRules('all', row, column).catch(function (_ref) {\n                  var rule = _ref.rule,\n                      rules = _ref.rules;\n                  var rest = {\n                    rule: rule,\n                    rules: rules,\n                    rowIndex: _this2.getRowIndex(row),\n                    row: row,\n                    columnIndex: _this2.getColumnIndex(column),\n                    column: column,\n                    $table: _this2\n                  };\n\n                  if (!validRest[column.property]) {\n                    validRest[column.property] = [];\n                  }\n\n                  validRest[column.property].push(rest);\n\n                  if (!isFull) {\n                    _this2.validRuleErr = true;\n                    return Promise.reject(rest);\n                  }\n                }));\n              }\n            });\n            rowValids.push(Promise.all(colVailds));\n          }\n        };\n\n        if (treeConfig) {\n          XEUtils.eachTree(vaildDatas, handleVaild, treeOpts);\n        } else {\n          vaildDatas.forEach(handleVaild);\n        }\n\n        return Promise.all(rowValids).then(function () {\n          var ruleProps = Object.keys(validRest);\n          return _this2.$nextTick().then(function () {\n            if (ruleProps.length) {\n              return Promise.reject(validRest[ruleProps[0]][0]);\n            }\n\n            if (cb) {\n              cb();\n            }\n          });\n        }).catch(function (firstErrParams) {\n          return new Promise(function (resolve, reject) {\n            var finish = function finish() {\n              _this2.$nextTick(function () {\n                if (cb) {\n                  cb(validRest);\n                  resolve();\n                } else {\n                  reject(validRest);\n                }\n              });\n            };\n\n            var posAndFinish = function posAndFinish() {\n              firstErrParams.cell = _this2.getCell(firstErrParams.row, firstErrParams.column);\n              DomTools.scrollToView(firstErrParams.cell);\n\n              _this2.handleValidError(firstErrParams).then(finish);\n            };\n            /**\r\n             * 当校验不通过时\r\n             * 将表格滚动到可视区\r\n             * 由于提示信息至少需要占一行，定位向上偏移一行\r\n             */\n\n\n            var row = firstErrParams.row;\n            var rowIndex = afterFullData.indexOf(row);\n            var locatRow = rowIndex > 0 ? afterFullData[rowIndex - 1] : row;\n\n            if (_this2.validOpts.autoPos === false) {\n              finish();\n            } else {\n              if (treeConfig) {\n                _this2.scrollToTreeRow(locatRow).then(posAndFinish);\n              } else {\n                _this2.scrollToRow(locatRow).then(posAndFinish);\n              }\n            }\n          });\n        });\n      }\n\n      return this.$nextTick().then(function () {\n        if (cb) {\n          cb();\n        }\n      });\n    },\n    hasCellRules: function hasCellRules(type, row, column) {\n      var editRules = this.editRules;\n      var property = column.property;\n\n      if (property && editRules) {\n        var rules = XEUtils.get(editRules, property);\n        return rules && XEUtils.find(rules, function (rule) {\n          return type === 'all' || !rule.trigger || type === rule.trigger;\n        });\n      }\n\n      return false;\n    },\n\n    /**\r\n     * 校验数据\r\n     * 按表格行、列顺序依次校验（同步或异步）\r\n     * 校验规则根据索引顺序依次校验，如果是异步则会等待校验完成才会继续校验下一列\r\n     * 如果校验失败则，触发回调或者Promise<不通过列的错误消息>\r\n     * 如果是传回调方式这返回一个校验不通过列的错误消息\r\n     *\r\n     * rule 配置：\r\n     *  required=Boolean 是否必填\r\n     *  min=Number 最小长度\r\n     *  max=Number 最大长度\r\n     *  validator=Function({ cellValue, rule, rules, row, column, rowIndex, columnIndex }) 自定义校验，接收一个 Promise\r\n     *  trigger=blur|change 触发方式（除非特殊场景，否则默认为空就行）\r\n     */\n    validCellRules: function validCellRules(validType, row, column, val) {\n      var _this3 = this;\n\n      var editRules = this.editRules;\n      var property = column.property;\n      var errorRules = [];\n      var syncVailds = [];\n\n      if (property && editRules) {\n        var rules = XEUtils.get(editRules, property);\n\n        if (rules) {\n          var cellValue = XEUtils.isUndefined(val) ? XEUtils.get(row, property) : val;\n          rules.forEach(function (rule) {\n            var type = rule.type,\n                trigger = rule.trigger,\n                required = rule.required;\n\n            if (validType === 'all' || !trigger || validType === trigger) {\n              if (XEUtils.isFunction(rule.validator)) {\n                var customValid = rule.validator({\n                  cellValue: cellValue,\n                  rule: rule,\n                  rules: rules,\n                  row: row,\n                  rowIndex: _this3.getRowIndex(row),\n                  column: column,\n                  columnIndex: _this3.getColumnIndex(column),\n                  $table: _this3\n                });\n\n                if (customValid) {\n                  if (XEUtils.isError(customValid)) {\n                    _this3.validRuleErr = true;\n                    errorRules.push(new Rule({\n                      type: 'custom',\n                      trigger: trigger,\n                      message: customValid.message,\n                      rule: new Rule(rule)\n                    }));\n                  } else if (customValid.catch) {\n                    // 如果为异步校验（注：异步校验是并发无序的）\n                    syncVailds.push(customValid.catch(function (e) {\n                      _this3.validRuleErr = true;\n                      errorRules.push(new Rule({\n                        type: 'custom',\n                        trigger: trigger,\n                        message: e && e.message ? e.message : rule.message,\n                        rule: new Rule(rule)\n                      }));\n                    }));\n                  }\n                }\n              } else {\n                var isArrType = type === 'array';\n                var hasEmpty = isArrType ? !XEUtils.isArray(cellValue) || !cellValue.length : eqEmptyValue(cellValue);\n\n                if (required ? hasEmpty || validErrorRuleValue(rule, cellValue) : !hasEmpty && validErrorRuleValue(rule, cellValue)) {\n                  _this3.validRuleErr = true;\n                  errorRules.push(new Rule(rule));\n                }\n              }\n            }\n          });\n        }\n      }\n\n      return Promise.all(syncVailds).then(function () {\n        if (errorRules.length) {\n          var rest = {\n            rules: errorRules,\n            rule: errorRules[0]\n          };\n          return Promise.reject(rest);\n        }\n      });\n    },\n    _clearValidate: function _clearValidate() {\n      var validTip = this.$refs.validTip;\n      Object.assign(this.validStore, {\n        visible: false,\n        row: null,\n        column: null,\n        content: '',\n        rule: null\n      });\n\n      if (validTip && validTip.visible) {\n        validTip.close();\n      }\n\n      return this.$nextTick();\n    },\n\n    /**\r\n     * 触发校验\r\n     */\n    triggerValidate: function triggerValidate(type) {\n      var _this4 = this;\n\n      var editConfig = this.editConfig,\n          editStore = this.editStore,\n          editRules = this.editRules,\n          validStore = this.validStore;\n      var actived = editStore.actived;\n\n      if (actived.row && editRules) {\n        var _actived$args = actived.args,\n            row = _actived$args.row,\n            column = _actived$args.column,\n            cell = _actived$args.cell;\n\n        if (this.hasCellRules(type, row, column)) {\n          return this.validCellRules(type, row, column).then(function () {\n            if (editConfig.mode === 'row') {\n              if (validStore.visible && validStore.row === row && validStore.column === column) {\n                _this4.clearValidate();\n              }\n            }\n          }).catch(function (_ref2) {\n            var rule = _ref2.rule; // 如果校验不通过与触发方式一致，则聚焦提示错误，否则跳过并不作任何处理\n\n            if (!rule.trigger || type === rule.trigger) {\n              var rest = {\n                rule: rule,\n                row: row,\n                column: column,\n                cell: cell\n              };\n\n              _this4.showValidTooltip(rest);\n\n              return Promise.reject(rest);\n            }\n\n            return Promise.resolve();\n          });\n        }\n      }\n\n      return Promise.resolve();\n    },\n\n    /**\r\n     * 弹出校验错误提示\r\n     */\n    showValidTooltip: function showValidTooltip(params) {\n      var _this5 = this;\n\n      var $refs = this.$refs,\n          height = this.height,\n          tableData = this.tableData,\n          validOpts = this.validOpts;\n      var rule = params.rule,\n          row = params.row,\n          column = params.column,\n          cell = params.cell;\n      var validTip = $refs.validTip;\n      var content = rule.message;\n      return this.$nextTick(function () {\n        Object.assign(_this5.validStore, {\n          row: row,\n          column: column,\n          rule: rule,\n          content: content,\n          visible: true\n        });\n\n        _this5.emitEvent('valid-error', params);\n\n        if (validTip && (validOpts.message === 'tooltip' || validOpts.message === 'default' && !height && tableData.length < 2)) {\n          return validTip.open(cell, content);\n        }\n      });\n    }\n  }\n};",{"version":3,"sources":["D:\\cdRule\\src\\components\\Table\\validator\\src\\mixin.js"],"names":["Rule","Object","$options","required","rule","min","max","type","pattern","validator","trigger","maxWidth","UtilTools","isNumType","numVal","XEUtils","isNaN","methods","_fullValidate","_validate","handleValidError","resolve","setTimeout","beginValidate","validRest","editRules","afterFullData","treeConfig","treeOpts","rows","vaildDatas","cb","rowValids","Date","columns","handleVaild","isFull","colVailds","column","rules","rest","rowIndex","row","columnIndex","$table","Promise","ruleProps","finish","reject","posAndFinish","firstErrParams","DomTools","locatRow","hasCellRules","property","validCellRules","errorRules","syncVailds","cellValue","validType","customValid","message","e","isArrType","hasEmpty","eqEmptyValue","validErrorRuleValue","_clearValidate","validTip","visible","content","triggerValidate","editConfig","editStore","validStore","actived","cell","showValidTooltip","$refs","height","tableData","validOpts","params"],"mappings":";;;;;;;;;;;;AAAA,OAAA,OAAA,MAAA,UAAA;AACA,SAAA,SAAA,EAAA,QAAA;AACA,SAAA,YAAA;AAEA;;;;IAGMA,I;;;AACJ,WAAA,IAAA,CAAA,IAAA,EAAmB;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,IAAA,CAAA;;AACjBC,IAAAA,MAAM,CAANA,MAAAA,CAAAA,IAAAA,EAAoB;AAClBC,MAAAA,QAAQ,EADU,IAAA;AAElBC,MAAAA,QAAQ,EAAEC,IAAI,CAFI,QAAA;AAGlBC,MAAAA,GAAG,EAAED,IAAI,CAHS,GAAA;AAIlBE,MAAAA,GAAG,EAAEF,IAAI,CAJS,GAAA;AAKlBG,MAAAA,IAAI,EAAEH,IAAI,CALQ,IAAA;AAMlBI,MAAAA,OAAO,EAAEJ,IAAI,CANK,OAAA;AAOlBK,MAAAA,SAAS,EAAEL,IAAI,CAPG,SAAA;AAQlBM,MAAAA,OAAO,EAAEN,IAAI,CARK,OAAA;AASlBO,MAAAA,QAAQ,EAAEP,IAAI,CAACO;AATG,KAApBV;AAWD;AAED;;;;;;;;wBAIe;AACb,aAAOW,SAAS,CAATA,WAAAA,CAAsB,KAAA,QAAA,CAA7B,OAAOA,CAAP;AACD;;;;;;AAGH,SAAA,mBAAA,CAAA,IAAA,EAAA,GAAA,EAAyC;AAAA,MAC/BL,IAD+B,GACHH,IADG,CAAA,IAAA;AAAA,MACzBC,GADyB,GACHD,IADG,CAAA,GAAA;AAAA,MACpBE,GADoB,GACHF,IADG,CAAA,GAAA;AAAA,MACfI,OADe,GACHJ,IADG,CAAA,OAAA;AAEvC,MAAMS,SAAS,GAAGN,IAAI,KAAtB,QAAA;AACA,MAAMO,MAAM,GAAGD,SAAS,GAAGE,OAAO,CAAPA,QAAAA,CAAH,GAAGA,CAAH,GAA2BA,OAAO,CAAPA,OAAAA,CAHZ,GAGYA,CAAnD,CAHuC,CAIvC;;AACA,MAAIF,SAAS,IAAIG,KAAK,CAAtB,GAAsB,CAAtB,EAA6B;AAC3B,WAAA,IAAA;AANqC,GAAA,CAQvC;;;AACA,MAAI,CAACD,OAAO,CAAPA,MAAAA,CAAD,GAACA,CAAD,IAAwBD,MAAM,GAAGC,OAAO,CAAPA,QAAAA,CAArC,GAAqCA,CAArC,EAA4D;AAC1D,WAAA,IAAA;AAVqC,GAAA,CAYvC;;;AACA,MAAI,CAACA,OAAO,CAAPA,MAAAA,CAAD,GAACA,CAAD,IAAwBD,MAAM,GAAGC,OAAO,CAAPA,QAAAA,CAArC,GAAqCA,CAArC,EAA4D;AAC1D,WAAA,IAAA;AAdqC,GAAA,CAgBvC;;;AACA,MAAIP,OAAO,IAAI,CAAC,CAACO,OAAO,CAAPA,QAAAA,CAAAA,OAAAA,IAAAA,OAAAA,GAAsC,IAAA,MAAA,CAAvC,OAAuC,CAAvC,EAAA,IAAA,CAAhB,GAAgB,CAAhB,EAAuF;AACrF,WAAA,IAAA;AACD;;AACD,SAAA,KAAA;AACD;;AAED,eAAe;AACbE,EAAAA,OAAO,EAAE;AACP;;;AAGAC,IAAAA,aAJO,EAAA,SAAA,aAAA,CAAA,IAAA,EAAA,EAAA,EAIkB;AACvB,aAAO,KAAA,aAAA,CAAA,IAAA,EAAA,EAAA,EAAP,IAAO,CAAP;AALK,KAAA;;AAOP;;;AAGAC,IAAAA,SAVO,EAAA,SAAA,SAAA,CAAA,IAAA,EAAA,EAAA,EAUc;AACnB,aAAO,KAAA,aAAA,CAAA,IAAA,EAAP,EAAO,CAAP;AAXK,KAAA;;AAaP;;;AAGAC,IAAAA,gBAhBO,EAAA,SAAA,gBAAA,CAAA,MAAA,EAgBmB;AAAA,UAAA,KAAA,GAAA,IAAA;;AACxB,aAAO,IAAA,OAAA,CAAY,UAAA,OAAA,EAAW;AAC5B,YAAI,KAAI,CAAJ,SAAA,CAAA,OAAA,KAAJ,KAAA,EAAsC;AACpC,UAAA,KAAI,CAAJ,SAAA,CAAA,aAAA,EAAA,MAAA;;AACAC,UAAAA,OAAO;AAFT,SAAA,MAGO;AACL,UAAA,KAAI,CAAJ,aAAA,CAAA,MAAA,EAA2B;AAAEd,YAAAA,IAAI,EAAN,aAAA;AAAuBG,YAAAA,OAAO,EAAE;AAAhC,WAA3B,EAAA,IAAA,CAA0E,YAAM;AAC9EY,YAAAA,UAAU,CAAC,YAAM;AACfD,cAAAA,OAAO,CAAC,KAAI,CAAJ,gBAAA,CAARA,MAAQ,CAAD,CAAPA;AADQ,aAAA,EAAVC,EAAU,CAAVA;AADF,WAAA;AAKD;AAVH,OAAO,CAAP;AAjBK,KAAA;;AA8BP;;;;;;;;;AASAC,IAAAA,aAvCO,EAAA,SAAA,aAAA,CAAA,IAAA,EAAA,EAAA,EAAA,MAAA,EAuC0B;AAAA,UAAA,MAAA,GAAA,IAAA;;AAC/B,UAAMC,SAAS,GAAf,EAAA;AAD+B,UAEvBC,SAFuB,GAAA,KAAA,SAAA;AAAA,UAEZC,aAFY,GAAA,KAAA,aAAA;AAAA,UAEGC,UAFH,GAAA,KAAA,UAAA;AAAA,UAEeC,QAFf,GAAA,KAAA,QAAA;AAG/B,UAAA,UAAA;;AACA,UAAIC,IAAI,KAAR,IAAA,EAAmB;AACjBC,QAAAA,UAAU,GAAVA,aAAAA;AADF,OAAA,MAEO,IAAA,IAAA,EAAU;AACf,YAAIf,OAAO,CAAPA,UAAAA,CAAJ,IAAIA,CAAJ,EAA8B;AAC5BgB,UAAAA,EAAE,GAAFA,IAAAA;AADF,SAAA,MAEO;AACLD,UAAAA,UAAU,GAAGf,OAAO,CAAPA,OAAAA,CAAAA,IAAAA,IAAAA,IAAAA,GAA+B,CAA5Ce,IAA4C,CAA5CA;AACD;AACF;;AACD,UAAI,CAAJ,UAAA,EAAiB;AACfA,QAAAA,UAAU,GAAG,KAAA,gBAAA,GAAA,MAAA,CAA+B,KAA5CA,gBAA4C,EAA/B,CAAbA;AACD;;AACD,UAAME,SAAS,GAAf,EAAA;AACA,WAAA,YAAA,GAAoBC,IAAI,CAAxB,GAAoBA,EAApB;AACA,WAAA,YAAA,GAlB+B,KAkB/B,CAlB+B,CAkBL;;AAC1B,WAAA,aAAA;;AACA,UAAA,SAAA,EAAe;AACb,YAAMC,OAAO,GAAG,KAAhB,UAAgB,EAAhB;;AACA,YAAMC,WAAW,GAAG,SAAdA,WAAc,CAAA,GAAA,EAAO;AACzB,cAAIC,MAAM,IAAI,CAAC,MAAI,CAAnB,YAAA,EAAkC;AAChC,gBAAMC,SAAS,GAAf,EAAA;AACAH,YAAAA,OAAO,CAAPA,OAAAA,CAAgB,UAAA,MAAA,EAAY;AAC1B,kBAAI,CAACE,MAAM,IAAI,CAAC,MAAI,CAAhB,YAAA,KAAkCrB,OAAO,CAAPA,GAAAA,CAAAA,SAAAA,EAAuBuB,MAAM,CAAnE,QAAsCvB,CAAtC,EAA+E;AAC7EsB,gBAAAA,SAAS,CAATA,IAAAA,CACE,MAAI,CAAJ,cAAA,CAAA,KAAA,EAAA,GAAA,EAAA,MAAA,EAAA,KAAA,CACS,UAAA,IAAA,EAAqB;AAAA,sBAAlBjC,IAAkB,GAAA,IAAA,CAAlBA,IAAkB;AAAA,sBAAZmC,KAAY,GAAA,IAAA,CAAZA,KAAY;AAC1B,sBAAMC,IAAI,GAAG;AAAEpC,oBAAAA,IAAI,EAAN,IAAA;AAAQmC,oBAAAA,KAAK,EAAb,KAAA;AAAeE,oBAAAA,QAAQ,EAAE,MAAI,CAAJ,WAAA,CAAzB,GAAyB,CAAzB;AAAgDC,oBAAAA,GAAG,EAAnD,GAAA;AAAqDC,oBAAAA,WAAW,EAAE,MAAI,CAAJ,cAAA,CAAlE,MAAkE,CAAlE;AAA+FL,oBAAAA,MAAM,EAArG,MAAA;AAAuGM,oBAAAA,MAAM,EAAE;AAA/G,mBAAb;;AACA,sBAAI,CAACpB,SAAS,CAACc,MAAM,CAArB,QAAc,CAAd,EAAiC;AAC/Bd,oBAAAA,SAAS,CAACc,MAAM,CAAhBd,QAAS,CAATA,GAAAA,EAAAA;AACD;;AACDA,kBAAAA,SAAS,CAACc,MAAM,CAAhBd,QAAS,CAATA,CAAAA,IAAAA,CAAAA,IAAAA;;AACA,sBAAI,CAAJ,MAAA,EAAa;AACX,oBAAA,MAAI,CAAJ,YAAA,GAAA,IAAA;AACA,2BAAOqB,OAAO,CAAPA,MAAAA,CAAP,IAAOA,CAAP;AACD;AAXPR,iBACE,CADFA;AAcD;AAhBHH,aAAAA;AAkBAF,YAAAA,SAAS,CAATA,IAAAA,CAAea,OAAO,CAAPA,GAAAA,CAAfb,SAAea,CAAfb;AACD;AAtBH,SAAA;;AAwBA,YAAA,UAAA,EAAgB;AACdjB,UAAAA,OAAO,CAAPA,QAAAA,CAAAA,UAAAA,EAAAA,WAAAA,EAAAA,QAAAA;AADF,SAAA,MAEO;AACLe,UAAAA,UAAU,CAAVA,OAAAA,CAAAA,WAAAA;AACD;;AACD,eAAO,OAAO,CAAP,GAAA,CAAA,SAAA,EAAA,IAAA,CAA4B,YAAM;AACvC,cAAMgB,SAAS,GAAG7C,MAAM,CAANA,IAAAA,CAAlB,SAAkBA,CAAlB;AACA,iBAAO,MAAI,CAAJ,SAAA,GAAA,IAAA,CAAsB,YAAM;AACjC,gBAAI6C,SAAS,CAAb,MAAA,EAAsB;AACpB,qBAAOD,OAAO,CAAPA,MAAAA,CAAerB,SAAS,CAACsB,SAAS,CAAnBtB,CAAmB,CAAV,CAATA,CAAtB,CAAsBA,CAAfqB,CAAP;AACD;;AACD,gBAAA,EAAA,EAAQ;AACNd,cAAAA,EAAE;AACH;AANH,WAAO,CAAP;AAFK,SAAA,EAAA,KAAA,CAUE,UAAA,cAAA,EAAkB;AACzB,iBAAO,IAAA,OAAA,CAAY,UAAA,OAAA,EAAA,MAAA,EAAqB;AACtC,gBAAMgB,MAAM,GAAG,SAATA,MAAS,GAAM;AACnB,cAAA,MAAI,CAAJ,SAAA,CAAe,YAAM;AACnB,oBAAA,EAAA,EAAQ;AACNhB,kBAAAA,EAAE,CAAFA,SAAE,CAAFA;AACAV,kBAAAA,OAAO;AAFT,iBAAA,MAGO;AACL2B,kBAAAA,MAAM,CAANA,SAAM,CAANA;AACD;AANH,eAAA;AADF,aAAA;;AAUA,gBAAMC,YAAY,GAAG,SAAfA,YAAe,GAAM;AACzBC,cAAAA,cAAc,CAAdA,IAAAA,GAAsB,MAAI,CAAJ,OAAA,CAAaA,cAAc,CAA3B,GAAA,EAAiCA,cAAc,CAArEA,MAAsB,CAAtBA;AACAC,cAAAA,QAAQ,CAARA,YAAAA,CAAsBD,cAAc,CAApCC,IAAAA;;AACA,cAAA,MAAI,CAAJ,gBAAA,CAAA,cAAA,EAAA,IAAA,CAAA,MAAA;AAHF,aAAA;AAKA;;;;;;;AAKA,gBAAMT,GAAG,GAAGQ,cAAc,CAA1B,GAAA;AACA,gBAAMT,QAAQ,GAAGf,aAAa,CAAbA,OAAAA,CAAjB,GAAiBA,CAAjB;AACA,gBAAM0B,QAAQ,GAAGX,QAAQ,GAARA,CAAAA,GAAef,aAAa,CAACe,QAAQ,GAArCA,CAA4B,CAA5BA,GAAjB,GAAA;;AACA,gBAAI,MAAI,CAAJ,SAAA,CAAA,OAAA,KAAJ,KAAA,EAAsC;AACpCM,cAAAA,MAAM;AADR,aAAA,MAEO;AACL,kBAAA,UAAA,EAAgB;AACd,gBAAA,MAAI,CAAJ,eAAA,CAAA,QAAA,EAAA,IAAA,CAAA,YAAA;AADF,eAAA,MAEO;AACL,gBAAA,MAAI,CAAJ,WAAA,CAAA,QAAA,EAAA,IAAA,CAAA,YAAA;AACD;AACF;AAhCH,WAAO,CAAP;AAXF,SAAO,CAAP;AA8CD;;AACD,aAAO,KAAA,SAAA,GAAA,IAAA,CAAsB,YAAM;AACjC,YAAA,EAAA,EAAQ;AACNhB,UAAAA,EAAE;AACH;AAHH,OAAO,CAAP;AAzIK,KAAA;AA+IPsB,IAAAA,YA/IO,EAAA,SAAA,YAAA,CAAA,IAAA,EAAA,GAAA,EAAA,MAAA,EA+I0B;AAAA,UACvB5B,SADuB,GAAA,KAAA,SAAA;AAAA,UAEvB6B,QAFuB,GAEVhB,MAFU,CAAA,QAAA;;AAG/B,UAAIgB,QAAQ,IAAZ,SAAA,EAA2B;AACzB,YAAMf,KAAK,GAAGxB,OAAO,CAAPA,GAAAA,CAAAA,SAAAA,EAAd,QAAcA,CAAd;AACA,eAAOwB,KAAK,IAAI,OAAO,CAAP,IAAA,CAAA,KAAA,EAAoB,UAAA,IAAA,EAAI;AAAA,iBAAIhC,IAAI,KAAJA,KAAAA,IAAkB,CAACH,IAAI,CAAvBG,OAAAA,IAAmCA,IAAI,KAAKH,IAAI,CAApD,OAAA;AAAxC,SAAgB,CAAhB;AACD;;AACD,aAAA,KAAA;AAtJK,KAAA;;AAwJP;;;;;;;;;;;;;;AAcAmD,IAAAA,cAtKO,EAAA,SAAA,cAAA,CAAA,SAAA,EAAA,GAAA,EAAA,MAAA,EAAA,GAAA,EAsKsC;AAAA,UAAA,MAAA,GAAA,IAAA;;AAAA,UACnC9B,SADmC,GAAA,KAAA,SAAA;AAAA,UAEnC6B,QAFmC,GAEtBhB,MAFsB,CAAA,QAAA;AAG3C,UAAMkB,UAAU,GAAhB,EAAA;AACA,UAAMC,UAAU,GAAhB,EAAA;;AACA,UAAIH,QAAQ,IAAZ,SAAA,EAA2B;AACzB,YAAMf,KAAK,GAAGxB,OAAO,CAAPA,GAAAA,CAAAA,SAAAA,EAAd,QAAcA,CAAd;;AACA,YAAA,KAAA,EAAW;AACT,cAAM2C,SAAS,GAAG3C,OAAO,CAAPA,WAAAA,CAAAA,GAAAA,IAA2BA,OAAO,CAAPA,GAAAA,CAAAA,GAAAA,EAA3BA,QAA2BA,CAA3BA,GAAlB,GAAA;AACAwB,UAAAA,KAAK,CAALA,OAAAA,CAAc,UAAA,IAAA,EAAQ;AAAA,gBACZhC,IADY,GACgBH,IADhB,CAAA,IAAA;AAAA,gBACNM,OADM,GACgBN,IADhB,CAAA,OAAA;AAAA,gBACGD,QADH,GACgBC,IADhB,CAAA,QAAA;;AAEpB,gBAAIuD,SAAS,KAATA,KAAAA,IAAuB,CAAvBA,OAAAA,IAAmCA,SAAS,KAAhD,OAAA,EAA8D;AAC5D,kBAAI5C,OAAO,CAAPA,UAAAA,CAAmBX,IAAI,CAA3B,SAAIW,CAAJ,EAAwC;AACtC,oBAAM6C,WAAW,GAAG,IAAI,CAAJ,SAAA,CAAe;AACjCF,kBAAAA,SAAS,EADwB,SAAA;AAEjCtD,kBAAAA,IAAI,EAF6B,IAAA;AAGjCmC,kBAAAA,KAAK,EAH4B,KAAA;AAIjCG,kBAAAA,GAAG,EAJ8B,GAAA;AAKjCD,kBAAAA,QAAQ,EAAE,MAAI,CAAJ,WAAA,CALuB,GAKvB,CALuB;AAMjCH,kBAAAA,MAAM,EAN2B,MAAA;AAOjCK,kBAAAA,WAAW,EAAE,MAAI,CAAJ,cAAA,CAPoB,MAOpB,CAPoB;AAQjCC,kBAAAA,MAAM,EAAE;AARyB,iBAAf,CAApB;;AAUA,oBAAA,WAAA,EAAiB;AACf,sBAAI7B,OAAO,CAAPA,OAAAA,CAAJ,WAAIA,CAAJ,EAAkC;AAChC,oBAAA,MAAI,CAAJ,YAAA,GAAA,IAAA;AACAyC,oBAAAA,UAAU,CAAVA,IAAAA,CAAgB,IAAA,IAAA,CAAS;AAAEjD,sBAAAA,IAAI,EAAN,QAAA;AAAkBG,sBAAAA,OAAO,EAAzB,OAAA;AAA2BmD,sBAAAA,OAAO,EAAED,WAAW,CAA/C,OAAA;AAAyDxD,sBAAAA,IAAI,EAAE,IAAA,IAAA,CAAA,IAAA;AAA/D,qBAAT,CAAhBoD;AAFF,mBAAA,MAGO,IAAII,WAAW,CAAf,KAAA,EAAuB;AAC5B;AACAH,oBAAAA,UAAU,CAAVA,IAAAA,CACE,WAAW,CAAX,KAAA,CAAkB,UAAA,CAAA,EAAK;AACrB,sBAAA,MAAI,CAAJ,YAAA,GAAA,IAAA;AACAD,sBAAAA,UAAU,CAAVA,IAAAA,CAAgB,IAAA,IAAA,CAAS;AAAEjD,wBAAAA,IAAI,EAAN,QAAA;AAAkBG,wBAAAA,OAAO,EAAzB,OAAA;AAA2BmD,wBAAAA,OAAO,EAAEC,CAAC,IAAIA,CAAC,CAANA,OAAAA,GAAiBA,CAAC,CAAlBA,OAAAA,GAA6B1D,IAAI,CAArE,OAAA;AAA+EA,wBAAAA,IAAI,EAAE,IAAA,IAAA,CAAA,IAAA;AAArF,uBAAT,CAAhBoD;AAHJC,qBACE,CADFA;AAMD;AACF;AAxBH,eAAA,MAyBO;AACL,oBAAMM,SAAS,GAAGxD,IAAI,KAAtB,OAAA;AACA,oBAAMyD,QAAQ,GAAGD,SAAS,GAAI,CAAChD,OAAO,CAAPA,OAAAA,CAAD,SAACA,CAAD,IAA+B,CAAC2C,SAAS,CAA7C,MAAA,GAAwDO,YAAY,CAA9F,SAA8F,CAA9F;;AACA,oBAAI9D,QAAQ,GAAI6D,QAAQ,IAAIE,mBAAmB,CAAA,IAAA,EAAnC,SAAmC,CAAnC,GAAyD,CAAA,QAAA,IAAaA,mBAAmB,CAAA,IAAA,EAArG,SAAqG,CAArG,EAAyH;AACvH,kBAAA,MAAI,CAAJ,YAAA,GAAA,IAAA;AACAV,kBAAAA,UAAU,CAAVA,IAAAA,CAAgB,IAAA,IAAA,CAAhBA,IAAgB,CAAhBA;AACD;AACF;AACF;AApCHjB,WAAAA;AAsCD;AACF;;AACD,aAAO,OAAO,CAAP,GAAA,CAAA,UAAA,EAAA,IAAA,CAA6B,YAAM;AACxC,YAAIiB,UAAU,CAAd,MAAA,EAAuB;AACrB,cAAMhB,IAAI,GAAG;AAAED,YAAAA,KAAK,EAAP,UAAA;AAAqBnC,YAAAA,IAAI,EAAEoD,UAAU,CAAA,CAAA;AAArC,WAAb;AACA,iBAAOX,OAAO,CAAPA,MAAAA,CAAP,IAAOA,CAAP;AACD;AAJH,OAAO,CAAP;AAvNK,KAAA;AA8NPsB,IAAAA,cA9NO,EAAA,SAAA,cAAA,GA8NW;AAChB,UAAMC,QAAQ,GAAG,KAAA,KAAA,CAAjB,QAAA;AACAnE,MAAAA,MAAM,CAANA,MAAAA,CAAc,KAAdA,UAAAA,EAA+B;AAC7BoE,QAAAA,OAAO,EADsB,KAAA;AAE7B3B,QAAAA,GAAG,EAF0B,IAAA;AAG7BJ,QAAAA,MAAM,EAHuB,IAAA;AAI7BgC,QAAAA,OAAO,EAJsB,EAAA;AAK7BlE,QAAAA,IAAI,EAAE;AALuB,OAA/BH;;AAOA,UAAImE,QAAQ,IAAIA,QAAQ,CAAxB,OAAA,EAAkC;AAChCA,QAAAA,QAAQ,CAARA,KAAAA;AACD;;AACD,aAAO,KAAP,SAAO,EAAP;AA1OK,KAAA;;AA4OP;;;AAGAG,IAAAA,eA/OO,EAAA,SAAA,eAAA,CAAA,IAAA,EA+OgB;AAAA,UAAA,MAAA,GAAA,IAAA;;AAAA,UACbC,UADa,GAAA,KAAA,UAAA;AAAA,UACDC,SADC,GAAA,KAAA,SAAA;AAAA,UACUhD,SADV,GAAA,KAAA,SAAA;AAAA,UACqBiD,UADrB,GAAA,KAAA,UAAA;AAAA,UAEbC,OAFa,GAEDF,SAFC,CAAA,OAAA;;AAGrB,UAAIE,OAAO,CAAPA,GAAAA,IAAJ,SAAA,EAA8B;AAAA,YAAA,aAAA,GACEA,OAAO,CADT,IAAA;AAAA,YACpBjC,GADoB,GAAA,aAAA,CAAA,GAAA;AAAA,YACfJ,MADe,GAAA,aAAA,CAAA,MAAA;AAAA,YACPsC,IADO,GAAA,aAAA,CAAA,IAAA;;AAE5B,YAAI,KAAA,YAAA,CAAA,IAAA,EAAA,GAAA,EAAJ,MAAI,CAAJ,EAA0C;AACxC,iBAAO,KAAA,cAAA,CAAA,IAAA,EAAA,GAAA,EAAA,MAAA,EAAA,IAAA,CAA4C,YAAM;AACvD,gBAAIJ,UAAU,CAAVA,IAAAA,KAAJ,KAAA,EAA+B;AAC7B,kBAAIE,UAAU,CAAVA,OAAAA,IAAsBA,UAAU,CAAVA,GAAAA,KAAtBA,GAAAA,IAAgDA,UAAU,CAAVA,MAAAA,KAApD,MAAA,EAAkF;AAChF,gBAAA,MAAI,CAAJ,aAAA;AACD;AACF;AALI,WAAA,EAAA,KAAA,CAME,UAAA,KAAA,EAAc;AAAA,gBAAXtE,IAAW,GAAA,KAAA,CAAXA,IAAW,CAAA,CACrB;;AACA,gBAAI,CAACA,IAAI,CAAL,OAAA,IAAiBG,IAAI,KAAKH,IAAI,CAAlC,OAAA,EAA4C;AAC1C,kBAAMoC,IAAI,GAAG;AAAEpC,gBAAAA,IAAI,EAAN,IAAA;AAAQsC,gBAAAA,GAAG,EAAX,GAAA;AAAaJ,gBAAAA,MAAM,EAAnB,MAAA;AAAqBsC,gBAAAA,IAAI,EAAJA;AAArB,eAAb;;AACA,cAAA,MAAI,CAAJ,gBAAA,CAAA,IAAA;;AACA,qBAAO/B,OAAO,CAAPA,MAAAA,CAAP,IAAOA,CAAP;AACD;;AACD,mBAAOA,OAAO,CAAd,OAAOA,EAAP;AAbF,WAAO,CAAP;AAeD;AACF;;AACD,aAAOA,OAAO,CAAd,OAAOA,EAAP;AAtQK,KAAA;;AAwQP;;;AAGAgC,IAAAA,gBA3QO,EAAA,SAAA,gBAAA,CAAA,MAAA,EA2QmB;AAAA,UAAA,MAAA,GAAA,IAAA;;AAAA,UAChBC,KADgB,GAAA,KAAA,KAAA;AAAA,UACTC,MADS,GAAA,KAAA,MAAA;AAAA,UACDC,SADC,GAAA,KAAA,SAAA;AAAA,UACUC,SADV,GAAA,KAAA,SAAA;AAAA,UAEhB7E,IAFgB,GAEY8E,MAFZ,CAAA,IAAA;AAAA,UAEVxC,GAFU,GAEYwC,MAFZ,CAAA,GAAA;AAAA,UAEL5C,MAFK,GAEY4C,MAFZ,CAAA,MAAA;AAAA,UAEGN,IAFH,GAEYM,MAFZ,CAAA,IAAA;AAGxB,UAAMd,QAAQ,GAAGU,KAAK,CAAtB,QAAA;AACA,UAAMR,OAAO,GAAGlE,IAAI,CAApB,OAAA;AACA,aAAO,KAAA,SAAA,CAAe,YAAM;AAC1BH,QAAAA,MAAM,CAANA,MAAAA,CAAc,MAAI,CAAlBA,UAAAA,EAA+B;AAC7ByC,UAAAA,GAAG,EAD0B,GAAA;AAE7BJ,UAAAA,MAAM,EAFuB,MAAA;AAG7BlC,UAAAA,IAAI,EAHyB,IAAA;AAI7BkE,UAAAA,OAAO,EAJsB,OAAA;AAK7BD,UAAAA,OAAO,EAAE;AALoB,SAA/BpE;;AAOA,QAAA,MAAI,CAAJ,SAAA,CAAA,aAAA,EAAA,MAAA;;AACA,YAAImE,QAAQ,KAAKa,SAAS,CAATA,OAAAA,KAAAA,SAAAA,IAAoCA,SAAS,CAATA,OAAAA,KAAAA,SAAAA,IAAmC,CAAnCA,MAAAA,IAA8CD,SAAS,CAATA,MAAAA,GAAnG,CAAY,CAAZ,EAA2H;AACzH,iBAAOZ,QAAQ,CAARA,IAAAA,CAAAA,IAAAA,EAAP,OAAOA,CAAP;AACD;AAXH,OAAO,CAAP;AAaD;AA7RM;AADI,CAAf","sourcesContent":["import XEUtils from 'xe-utils'\r\nimport { UtilTools, DomTools } from '../../tools'\r\nimport { eqEmptyValue } from '../../tools/src/utils'\r\n\r\n/**\r\n * 校验规则\r\n */\r\nclass Rule {\r\n  constructor (rule) {\r\n    Object.assign(this, {\r\n      $options: rule,\r\n      required: rule.required,\r\n      min: rule.min,\r\n      max: rule.max,\r\n      type: rule.type,\r\n      pattern: rule.pattern,\r\n      validator: rule.validator,\r\n      trigger: rule.trigger,\r\n      maxWidth: rule.maxWidth\r\n    })\r\n  }\r\n\r\n  /**\r\n   * 获取校验不通过的消息\r\n   * 支持国际化翻译\r\n   */\r\n  get message () {\r\n    return UtilTools.getFuncText(this.$options.message)\r\n  }\r\n}\r\n\r\nfunction validErrorRuleValue (rule, val) {\r\n  const { type, min, max, pattern } = rule\r\n  const isNumType = type === 'number'\r\n  const numVal = isNumType ? XEUtils.toNumber(val) : XEUtils.getSize(val)\r\n  // 判断数值\r\n  if (isNumType && isNaN(val)) {\r\n    return true\r\n  }\r\n  // 如果存在 min，判断最小值\r\n  if (!XEUtils.eqNull(min) && numVal < XEUtils.toNumber(min)) {\r\n    return true\r\n  }\r\n  // 如果存在 max，判断最大值\r\n  if (!XEUtils.eqNull(max) && numVal > XEUtils.toNumber(max)) {\r\n    return true\r\n  }\r\n  // 如果存在 pattern，正则校验\r\n  if (pattern && !(XEUtils.isRegExp(pattern) ? pattern : new RegExp(pattern)).test(val)) {\r\n    return true\r\n  }\r\n  return false\r\n}\r\n\r\nexport default {\r\n  methods: {\r\n    /**\r\n     * 完整校验，和 validate 的区别就是会给有效数据中的每一行进行校验\r\n     */\r\n    _fullValidate (rows, cb) {\r\n      return this.beginValidate(rows, cb, true)\r\n    },\r\n    /**\r\n     * 快速校验，如果存在记录不通过的记录，则返回不再继续校验（异步校验除外）\r\n     */\r\n    _validate (rows, cb) {\r\n      return this.beginValidate(rows, cb)\r\n    },\r\n    /**\r\n     * 聚焦到校验通过的单元格并弹出校验错误提示\r\n     */\r\n    handleValidError (params) {\r\n      return new Promise(resolve => {\r\n        if (this.validOpts.autoPos === false) {\r\n          this.emitEvent('valid-error', params)\r\n          resolve()\r\n        } else {\r\n          this.handleActived(params, { type: 'valid-error', trigger: 'call' }).then(() => {\r\n            setTimeout(() => {\r\n              resolve(this.showValidTooltip(params))\r\n            }, 10)\r\n          })\r\n        }\r\n      })\r\n    },\r\n    /**\r\n     * 对表格数据进行校验\r\n     * 如果不指定数据，则默认只校验临时变动的数据，例如新增或修改\r\n     * 如果传 true 则校验当前表格数据\r\n     * 如果传 row 指定行记录，则只验证传入的行\r\n     * 如果传 rows 为多行记录，则只验证传入的行\r\n     * 如果只传 callback 否则默认验证整个表格数据\r\n     * 返回 Promise 对象，或者使用回调方式\r\n     */\r\n    beginValidate (rows, cb, isFull) {\r\n      const validRest = {}\r\n      const { editRules, afterFullData, treeConfig, treeOpts } = this\r\n      let vaildDatas\r\n      if (rows === true) {\r\n        vaildDatas = afterFullData\r\n      } else if (rows) {\r\n        if (XEUtils.isFunction(rows)) {\r\n          cb = rows\r\n        } else {\r\n          vaildDatas = XEUtils.isArray(rows) ? rows : [rows]\r\n        }\r\n      }\r\n      if (!vaildDatas) {\r\n        vaildDatas = this.getInsertRecords().concat(this.getUpdateRecords())\r\n      }\r\n      const rowValids = []\r\n      this.lastCallTime = Date.now()\r\n      this.validRuleErr = false // 如果为快速校验，当存在某列校验不通过时将终止执行\r\n      this.clearValidate()\r\n      if (editRules) {\r\n        const columns = this.getColumns()\r\n        const handleVaild = row => {\r\n          if (isFull || !this.validRuleErr) {\r\n            const colVailds = []\r\n            columns.forEach((column) => {\r\n              if ((isFull || !this.validRuleErr) && XEUtils.has(editRules, column.property)) {\r\n                colVailds.push(\r\n                  this.validCellRules('all', row, column)\r\n                    .catch(({ rule, rules }) => {\r\n                      const rest = { rule, rules, rowIndex: this.getRowIndex(row), row, columnIndex: this.getColumnIndex(column), column, $table: this }\r\n                      if (!validRest[column.property]) {\r\n                        validRest[column.property] = []\r\n                      }\r\n                      validRest[column.property].push(rest)\r\n                      if (!isFull) {\r\n                        this.validRuleErr = true\r\n                        return Promise.reject(rest)\r\n                      }\r\n                    })\r\n                )\r\n              }\r\n            })\r\n            rowValids.push(Promise.all(colVailds))\r\n          }\r\n        }\r\n        if (treeConfig) {\r\n          XEUtils.eachTree(vaildDatas, handleVaild, treeOpts)\r\n        } else {\r\n          vaildDatas.forEach(handleVaild)\r\n        }\r\n        return Promise.all(rowValids).then(() => {\r\n          const ruleProps = Object.keys(validRest)\r\n          return this.$nextTick().then(() => {\r\n            if (ruleProps.length) {\r\n              return Promise.reject(validRest[ruleProps[0]][0])\r\n            }\r\n            if (cb) {\r\n              cb()\r\n            }\r\n          })\r\n        }).catch(firstErrParams => {\r\n          return new Promise((resolve, reject) => {\r\n            const finish = () => {\r\n              this.$nextTick(() => {\r\n                if (cb) {\r\n                  cb(validRest)\r\n                  resolve()\r\n                } else {\r\n                  reject(validRest)\r\n                }\r\n              })\r\n            }\r\n            const posAndFinish = () => {\r\n              firstErrParams.cell = this.getCell(firstErrParams.row, firstErrParams.column)\r\n              DomTools.scrollToView(firstErrParams.cell)\r\n              this.handleValidError(firstErrParams).then(finish)\r\n            }\r\n            /**\r\n             * 当校验不通过时\r\n             * 将表格滚动到可视区\r\n             * 由于提示信息至少需要占一行，定位向上偏移一行\r\n             */\r\n            const row = firstErrParams.row\r\n            const rowIndex = afterFullData.indexOf(row)\r\n            const locatRow = rowIndex > 0 ? afterFullData[rowIndex - 1] : row\r\n            if (this.validOpts.autoPos === false) {\r\n              finish()\r\n            } else {\r\n              if (treeConfig) {\r\n                this.scrollToTreeRow(locatRow).then(posAndFinish)\r\n              } else {\r\n                this.scrollToRow(locatRow).then(posAndFinish)\r\n              }\r\n            }\r\n          })\r\n        })\r\n      }\r\n      return this.$nextTick().then(() => {\r\n        if (cb) {\r\n          cb()\r\n        }\r\n      })\r\n    },\r\n    hasCellRules (type, row, column) {\r\n      const { editRules } = this\r\n      const { property } = column\r\n      if (property && editRules) {\r\n        const rules = XEUtils.get(editRules, property)\r\n        return rules && XEUtils.find(rules, rule => type === 'all' || !rule.trigger || type === rule.trigger)\r\n      }\r\n      return false\r\n    },\r\n    /**\r\n     * 校验数据\r\n     * 按表格行、列顺序依次校验（同步或异步）\r\n     * 校验规则根据索引顺序依次校验，如果是异步则会等待校验完成才会继续校验下一列\r\n     * 如果校验失败则，触发回调或者Promise<不通过列的错误消息>\r\n     * 如果是传回调方式这返回一个校验不通过列的错误消息\r\n     *\r\n     * rule 配置：\r\n     *  required=Boolean 是否必填\r\n     *  min=Number 最小长度\r\n     *  max=Number 最大长度\r\n     *  validator=Function({ cellValue, rule, rules, row, column, rowIndex, columnIndex }) 自定义校验，接收一个 Promise\r\n     *  trigger=blur|change 触发方式（除非特殊场景，否则默认为空就行）\r\n     */\r\n    validCellRules (validType, row, column, val) {\r\n      const { editRules } = this\r\n      const { property } = column\r\n      const errorRules = []\r\n      const syncVailds = []\r\n      if (property && editRules) {\r\n        const rules = XEUtils.get(editRules, property)\r\n        if (rules) {\r\n          const cellValue = XEUtils.isUndefined(val) ? XEUtils.get(row, property) : val\r\n          rules.forEach(rule => {\r\n            const { type, trigger, required } = rule\r\n            if (validType === 'all' || !trigger || validType === trigger) {\r\n              if (XEUtils.isFunction(rule.validator)) {\r\n                const customValid = rule.validator({\r\n                  cellValue,\r\n                  rule,\r\n                  rules,\r\n                  row,\r\n                  rowIndex: this.getRowIndex(row),\r\n                  column,\r\n                  columnIndex: this.getColumnIndex(column),\r\n                  $table: this\r\n                })\r\n                if (customValid) {\r\n                  if (XEUtils.isError(customValid)) {\r\n                    this.validRuleErr = true\r\n                    errorRules.push(new Rule({ type: 'custom', trigger, message: customValid.message, rule: new Rule(rule) }))\r\n                  } else if (customValid.catch) {\r\n                    // 如果为异步校验（注：异步校验是并发无序的）\r\n                    syncVailds.push(\r\n                      customValid.catch(e => {\r\n                        this.validRuleErr = true\r\n                        errorRules.push(new Rule({ type: 'custom', trigger, message: e && e.message ? e.message : rule.message, rule: new Rule(rule) }))\r\n                      })\r\n                    )\r\n                  }\r\n                }\r\n              } else {\r\n                const isArrType = type === 'array'\r\n                const hasEmpty = isArrType ? (!XEUtils.isArray(cellValue) || !cellValue.length) : eqEmptyValue(cellValue)\r\n                if (required ? (hasEmpty || validErrorRuleValue(rule, cellValue)) : (!hasEmpty && validErrorRuleValue(rule, cellValue))) {\r\n                  this.validRuleErr = true\r\n                  errorRules.push(new Rule(rule))\r\n                }\r\n              }\r\n            }\r\n          })\r\n        }\r\n      }\r\n      return Promise.all(syncVailds).then(() => {\r\n        if (errorRules.length) {\r\n          const rest = { rules: errorRules, rule: errorRules[0] }\r\n          return Promise.reject(rest)\r\n        }\r\n      })\r\n    },\r\n    _clearValidate () {\r\n      const validTip = this.$refs.validTip\r\n      Object.assign(this.validStore, {\r\n        visible: false,\r\n        row: null,\r\n        column: null,\r\n        content: '',\r\n        rule: null\r\n      })\r\n      if (validTip && validTip.visible) {\r\n        validTip.close()\r\n      }\r\n      return this.$nextTick()\r\n    },\r\n    /**\r\n     * 触发校验\r\n     */\r\n    triggerValidate (type) {\r\n      const { editConfig, editStore, editRules, validStore } = this\r\n      const { actived } = editStore\r\n      if (actived.row && editRules) {\r\n        const { row, column, cell } = actived.args\r\n        if (this.hasCellRules(type, row, column)) {\r\n          return this.validCellRules(type, row, column).then(() => {\r\n            if (editConfig.mode === 'row') {\r\n              if (validStore.visible && validStore.row === row && validStore.column === column) {\r\n                this.clearValidate()\r\n              }\r\n            }\r\n          }).catch(({ rule }) => {\r\n            // 如果校验不通过与触发方式一致，则聚焦提示错误，否则跳过并不作任何处理\r\n            if (!rule.trigger || type === rule.trigger) {\r\n              const rest = { rule, row, column, cell }\r\n              this.showValidTooltip(rest)\r\n              return Promise.reject(rest)\r\n            }\r\n            return Promise.resolve()\r\n          })\r\n        }\r\n      }\r\n      return Promise.resolve()\r\n    },\r\n    /**\r\n     * 弹出校验错误提示\r\n     */\r\n    showValidTooltip (params) {\r\n      const { $refs, height, tableData, validOpts } = this\r\n      const { rule, row, column, cell } = params\r\n      const validTip = $refs.validTip\r\n      const content = rule.message\r\n      return this.$nextTick(() => {\r\n        Object.assign(this.validStore, {\r\n          row,\r\n          column,\r\n          rule,\r\n          content,\r\n          visible: true\r\n        })\r\n        this.emitEvent('valid-error', params)\r\n        if (validTip && (validOpts.message === 'tooltip' || (validOpts.message === 'default' && !height && tableData.length < 2))) {\r\n          return validTip.open(cell, content)\r\n        }\r\n      })\r\n    }\r\n  }\r\n}\r\n"]}]}