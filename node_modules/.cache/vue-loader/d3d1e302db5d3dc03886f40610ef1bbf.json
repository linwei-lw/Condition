{"remainingRequest":"D:\\cdRule\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!D:\\cdRule\\src\\components\\Tree\\index.vue?vue&type=script&lang=js&","dependencies":[{"path":"D:\\cdRule\\src\\components\\Tree\\index.vue","mtime":1662711748081},{"path":"D:\\cdRule\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\cdRule\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n /*\n * 单选树使用例子\n * <Tree ref=\"tree\" style=\"width:100px;height:100%;\" :setting=\"{view:{nameFunction:nameFunction,iconUrlFunction:iconUrlFunction,iconCssFunction:iconCssFunction},callback:{onClick:onTreeClick}}\"/>\n *  mounted() {\n *    let list = [{id:'1',name:'a',pid:'0'},{id:'11',name:'a1',pid:'1'},{id:'12',name:'a2',pid:'1'},...];//id和pid相互关联，形成树的关系\n *    let roots = common.util.Trees.arrayToTree(list);\n *    this.$refs.tree.init(roots);\n *  }\n *  methods: {\n *    nameFunction(node) {// 返回当前结点的显示值，如果不设置该回调函数，默认取node.name\n *      return node.name + '(' + node.count + ')';\n *    },\n *    iconUrlFunction(node, open) {// 返回当前结点的图标绝对路径，如果该结点图标不需要URL，直接返回null\n *        return 'http://wwww.xxxxx/'+node.state+'.png';\n *    },\n *    iconCssFunction(node, open) {// 返回当前结点的图标CSS样式名，如果该结点图标不需要css，直接返回null\n *        return node.isDir ? (open ? 'ico_open' : 'ico_close') : $style.my_leaf_css;\n *    },\n *    onTreeClick(node) {\n *       alert('你点了+node.name+'，找死呀！');\n *    }\n *  }\n\n *  多选树使用例子，P:true是指级联勾父结点,　S:true是指级联勾子结点\n  * <Tree style=\"width:100px;height:100%;\" :setting=\"{check:{enable:true,P:true,S:true},callback:{onCheck:onTreeCheck}}\"/>\n * \n *  methods: {\n *    onTreeCheck(node, chgs, value) {// node是当前结点，chgs是级联的所有结点，value:1是打勾，0是去勾\n *    }\n *  }\n*/\n\n import SearchBox from \"@/components/Tree/SearchBox.vue\";\n\n export default {\n   name: \"Tree\",\n   components: { SearchBox },\n   props: {\n     setting:        { type: Object,  default: ()=>{return {}} },           // 参考ztree的setting配置\n     getTreeRoots: Function,                                                // 调用该方法获取树结点\n     frozenRoot:     { type: Boolean, default: false },                     // 冻结根结点，不显示根结点的+-图标\n     disabled:       { type: Boolean, default: false },                     // 是否可操作\n     border:         { type: Boolean, default: true  },                     // 是否显示边框\n     borderColor:    { type: String,  default: $_theme.border_color_dark},  // 边框颜色\n     loading:        { type: Boolean, default: false },                     // 是否显示加载中\n     searchable:     { type: Boolean, default: true  },                     // 是否显示搜索栏\n     searchFun:      Function,                                             // 查询回调函数 参数(node, searchText) 返回true(符合条件)|false(不符合条件)\n     placeholder:    String,\n     miniBar:        { type: Boolean, default: false },                     // 是否显示mini搜索栏\n     showSearchIcon: { type: Boolean, default: true  },                     // 是否显示搜索图标\n     onSearchItemSelected: Function,                                        // 选中了搜索栏查出的某个结点的回调函数，参数(node)\n     searchMax:      { type: Number, default: 200  },                       // 搜索栏显示的最多数量\n     onTreeInited:   Function\n   },\n\n   _tree: null,\n\n   data() {\n     return {\n       treeId: 'tree_' + $_theme.zindex(),\n       loading2: false,\n     };\n   },\n\n   mounted() {\n     this._tree = this._tree || null;\n     this.getTreeRoots && (this.loading2 = true, this.getTreeRoots(this.init));\n   },\n\n   methods: {\n     init(roots, open = true) {\n       this.loading2 = false;\n       this.destroy();\n       if (open || this.frozenRoot) {\n         if (Array.isArray(roots)) {\n           for (let i=0,len=roots.length; i<len; i++) {\n             roots[i][this.treeId] = {open: true};\n           }\n         } else {\n           roots[this.treeId] = {open: true};\n         }\n       }\n       this._tree = $.fn.zTree.init($(this.$refs.treeUl), this.setting, roots);\n       this.searchable && (this.$refs.searchBox.setTree(this._tree));\n       this.onTreeInited && this.onTreeInited(this._tree);\n       return this._tree;\n     },\n     getCheckedNodes(onlyChecked=true, onlyTop=false, field=null, hasOwnField=null, nodes=null) {\n       return this._tree.getCheckedNodes(onlyChecked, onlyTop, field, hasOwnField, nodes);\n     },\n     checkNodes(nodes, checked=true, checkTypeFlag, callbackFlag) {\n       for (let i=0,len=nodes.length; i<len; i++) {\n         this._tree.checkNode(nodes[i], checked, checkTypeFlag, callbackFlag);\n       }\n     },\n     selectNode(node, isSilent=false) {\n       this._tree.selectNode(node, false, isSilent);\n     },\n     getTree() { return this._tree; },\n     getTreeId() { return this.treeId; },\n     destroy() {\n       if (this._tree === null) return;\n       this._tree.destroy();\n       this._tree = null;\n       if (this.searchable) {\n         this.$refs.searchBox.clear();\n         this.$refs.searchBox.setTree(null);\n       }\n     }\n   },\n\n   beforeDestroy() {\n     this.destroy();\n   }\n }\n",null]}